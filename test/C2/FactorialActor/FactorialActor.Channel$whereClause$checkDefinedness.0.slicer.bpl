type Integer = int;
type Boolean = bool;
type HeapType = <a>[ref,Field (a)]a;
type MaskType = <a>[ref,Field (a)][PermissionComponent]int;
type CreditsType = [ref]int;
type ArgSeq = <T>[int]T;
type string = int;
type Field m0;
type ref;
type PermissionComponent;
type ModuleName;
type TypeName;
type Mu;
const null : ref;
const unique perm$R : PermissionComponent;
const unique perm$N : PermissionComponent;
const Permission$denominator : int;
const Permission$FullFraction : int;
const Permission$Zero : [PermissionComponent]int;
const Permission$Full : [PermissionComponent]int;
const ZeroMask : MaskType;
const unique joinable : Field (int);
const unique token#t : TypeName;
const unique forkK : Field (int);
const channelK : int;
const monitorK : int;
const predicateK : int;
const nostate : HeapType;
const CurrentModule : ModuleName;
const CanAssumeFunctionDefs : bool;
const unique mu : Field (Mu);
const $LockBottom : Mu;
const unique held : Field (int);
const unique rdheld : Field (bool);
const ZeroCredits : CreditsType;
const unique Channel#t : TypeName;
const unique module#default : ModuleName;
const unique Queue#t : TypeName;
const unique FactorialActorChannelExpEP#t : TypeName;
const unique FactorialActorChannelExpEP.state : Field (int);
const unique FactorialActorChannelExpEP.ch : Field (ref);
const unique FactorialActorChannelExpEP.expch : Field (ref);
const unique FactorialActorChannelExpEP.valid : Field (HeapType);
const unique FactorialActorChannelImpEP#t : TypeName;
const unique FactorialActorChannelImpEP.state : Field (int);
const unique FactorialActorChannelImpEP.ch : Field (ref);
const unique FactorialActorChannelImpEP.impch : Field (ref);
const unique FactorialActorChannelImpEP.valid : Field (HeapType);
const unique FactorialActorChannel#t : TypeName;
const unique FactorialActorChannel.imp : Field (ref);
const unique FactorialActorChannel.exp : Field (ref);
const unique FactorialActorChannel.valid : Field (HeapType);
const unique FactorialActorChannel.initImpState : Field (HeapType);
const unique FactorialActorChannel.initExpState : Field (HeapType);
const unique FactorialContChannelExpEP#t : TypeName;
const unique FactorialContChannelExpEP.state : Field (int);
const unique FactorialContChannelExpEP.ch : Field (ref);
const unique FactorialContChannelExpEP.expch : Field (ref);
const unique FactorialContChannelExpEP.valid : Field (HeapType);
const unique FactorialContChannelImpEP#t : TypeName;
const unique FactorialContChannelImpEP.state : Field (int);
const unique FactorialContChannelImpEP.ch : Field (ref);
const unique FactorialContChannelImpEP.impch : Field (ref);
const unique FactorialContChannelImpEP.valid : Field (HeapType);
const unique FactorialContChannel#t : TypeName;
const unique FactorialContChannel.imp : Field (ref);
const unique FactorialContChannel.exp : Field (ref);
const unique FactorialContChannel.valid : Field (HeapType);
const unique FactorialContChannel.initImpState : Field (HeapType);
const unique FactorialContChannel.initExpState : Field (HeapType);
const unique FutureChannelExpEP#t : TypeName;
const unique FutureChannelExpEP.state : Field (int);
const unique FutureChannelExpEP.ch : Field (ref);
const unique FutureChannelExpEP.expch : Field (ref);
const unique FutureChannelExpEP.valid : Field (HeapType);
const unique FutureChannelImpEP#t : TypeName;
const unique FutureChannelImpEP.state : Field (int);
const unique FutureChannelImpEP.ch : Field (ref);
const unique FutureChannelImpEP.impch : Field (ref);
const unique FutureChannelImpEP.valid : Field (HeapType);
const unique FutureChannel#t : TypeName;
const unique FutureChannel.imp : Field (ref);
const unique FutureChannel.exp : Field (ref);
const unique FutureChannel.valid : Field (HeapType);
const unique FutureChannel.initImpState : Field (HeapType);
const unique FutureChannel.initExpState : Field (HeapType);
const unique Future#t : TypeName;
const unique Future.sent : Field (ref);
const unique Future.value : Field (ref);
const unique Future.q : Field (ref);
const unique Message#t : TypeName;
const unique Message.type : Field (int);
const unique Message.sender1 : Field (ref);
const unique Message.sender3 : Field (ref);
const unique Message.sender2 : Field (ref);
const unique Message.sender4 : Field (ref);
const unique Message.receiver1 : Field (ref);
const unique Message.receiver2 : Field (ref);
const unique Message.receiver3 : Field (ref);
const unique Message.receiver4 : Field (ref);
const unique Message.v1 : Field (int);
const unique Message.vo1 : Field (int);
const unique Message.cust1 : Field (ref);
const unique Message.vr1 : Field (int);
const unique Message.old1 : Field (ref);
const unique Message.vr2 : Field (int);
const unique Message.old2 : Field (ref);
const unique Message.vr3 : Field (int);
const unique Message.invValue : Field (HeapType);
const unique Message.invResult1 : Field (HeapType);
const unique Message.invResult2 : Field (HeapType);
const unique Message.invFinalResult : Field (HeapType);
const unique Message.inv : Field (HeapType);
const unique FactorialActor#t : TypeName;
const unique FactorialActor.q : Field (ref);
const unique FactorialCont#t : TypeName;
const unique FactorialCont.q : Field (ref);
const unique FactorialCont.v : Field (int);
const unique FactorialCont.vo : Field (int);
const unique FactorialCont.cust : Field (ref);
const $old_Heap : HeapType;
const $old_Mask : MaskType;
const $old_Credits : CreditsType;
function Fractions(int) : int;
function IsGoodState <T> (T) : bool;
function combine <T,U> (T,U) : T;
function dtype(ref) : TypeName;
function MuBelow(Mu,Mu) : bool;
function Acquire$Heap(int) : HeapType;
function Acquire$Mask(int) : MaskType;
function Acquire$Credits(int) : CreditsType;
function LastSeen$Heap(Mu,int) : HeapType;
function LastSeen$Mask(Mu,int) : MaskType;
function LastSeen$Credits(Mu,int) : CreditsType;
function wf(HeapType,MaskType) : bool;
function IsGoodInhaleState(HeapType,HeapType,MaskType) : bool;
function {:expand  false} CanRead <T> (MaskType,ref,Field (T)) : bool;
function {:expand  false} CanWrite <T> (MaskType,ref,Field (T)) : bool;
function {:expand  true} IsGoodMask(MaskType) : bool;
function DecPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function DecEpsilons <T> (MaskType,ref,Field (T),int) : MaskType;
function IncPerm <T> (MaskType,ref,Field (T),int) : MaskType;
function IncEpsilons <T> (MaskType,ref,Field (T),int) : MaskType;
function Havocing <T,U> (HeapType,ref,Field (T),U) : HeapType;
function Call$Heap(int) : HeapType;
function Call$Mask(int) : MaskType;
function Call$Credits(int) : CreditsType;
function Call$Args(int) : ArgSeq;
function EmptyMask(MaskType) : bool;
function EmptyCredits(CreditsType) : bool;
function NonPredicateField <T> (Field (T)) : bool;
function PredicateField <T> (Field (T)) : bool;
function submask(MaskType,MaskType) : bool;
function ite <T> (bool,T,T) : T;
function #Future.getQ(HeapType,MaskType,ref) : ref;
function ##Future.getQ(HeapType,ref) : ref;
function #Message.factorial(HeapType,MaskType,ref,int) : int;
function #Message.factorial#limited(HeapType,MaskType,ref,int) : int;
function ##Message.factorial(HeapType,ref,int) : int;
function #FactorialActor.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialActor.getQ(HeapType,ref) : ref;
function #FactorialCont.getQ(HeapType,MaskType,ref) : ref;
function ##FactorialCont.getQ(HeapType,ref) : ref;
var Heap : HeapType;
var Mask : MaskType;
var Credits : CreditsType;
procedure Channel$whereClause$checkDefinedness (this : ref,msg#0 : ref)
{
	var whereK#_8 : int;
	var inhaleHeap#_9 : HeapType;
	var inhaleHeap#_9_$_0 : HeapType;
	var Heap_$_0 : HeapType;
	var Mask_$_0 : MaskType;
	var Heap_$_1 : HeapType;
	var Mask_$_1 : MaskType;
$start:
	assume Permission$denominator > 0;
	assume (Permission$Zero[perm$R] == 0) && (Permission$Zero[perm$N] == 0);
	assume (Permission$Full[perm$R] == Permission$FullFraction) && (Permission$Full[perm$N] == 0);
	assume (forall<T> o : ref, f : Field (T) , pc : PermissionComponent :: ( ZeroMask[o,f][pc] == 0 ));
	assume IsGoodMask(ZeroMask);
	assume NonPredicateField(joinable);
	assume NonPredicateField(forkK);
	assume (forall  n : Integer :: {Fractions(n)} ( Fractions(n) == (n * Permission$denominator) ));
	assume (forall  x : Integer, y : Integer :: ( ((0 <= x) && (x <= y)) ==> (Fractions(x) <= Fractions(y)) ));
	assume Permission$FullFraction == Fractions(100);
	assume (0 < channelK) && ((1000 * channelK) < Fractions(1));
	assume (0 < monitorK) && ((1000 * monitorK) < Fractions(1));
	assume (0 < predicateK) && ((1000 * predicateK) < Fractions(1));
	assume (predicateK == channelK) && (channelK == monitorK);
	assume (forall<T,U> a : T, b : U :: {IsGoodState(combine(a,b))} ( IsGoodState(combine(a,b)) <==> (IsGoodState(a) && IsGoodState(b)) ));
	assume IsGoodState(nostate);
	assume NonPredicateField(mu);
	assume (forall  m : Mu, n_$0 : Mu :: {MuBelow(m,n_$0),MuBelow(n_$0,m)} ( !(MuBelow(m,n_$0) && MuBelow(n_$0,m)) ));
	assume (forall  m_$0 : Mu, n_$1 : Mu, o_$0 : Mu :: {MuBelow(m_$0,n_$1),MuBelow(n_$1,o_$0)} ( (MuBelow(m_$0,n_$1) && MuBelow(n_$1,o_$0)) ==> MuBelow(m_$0,o_$0) ));
	assume (forall  m_$1 : Mu, n_$2 : Mu :: ( MuBelow(m_$1,n_$2) ==> (!(n_$2 == $LockBottom)) ));
	assume NonPredicateField(held);
	assume NonPredicateField(rdheld);
	assume (forall  ih : HeapType, h : HeapType, m_$2 : MaskType :: {IsGoodInhaleState(ih,h,m_$2)} ( IsGoodInhaleState(ih,h,m_$2) <==> ((((((forall<T> o_$1 : ref, f_$0 : Field (T)  :: {ih[o_$1,f_$0]} ( CanRead(m_$2,o_$1,f_$0) ==> (ih[o_$1,f_$0] == h[o_$1,f_$0]) ))) && ((forall  o_$2 : ref :: {ih[o_$2,held]} ( (0 < ih[o_$2,held]) <==> (0 < h[o_$2,held]) )))) && ((forall  o_$3 : ref :: {ih[o_$3,rdheld]} ( ih[o_$3,rdheld] <==> h[o_$3,rdheld] )))) && ((forall  o_$4 : ref :: {h[o_$4,held]} ( (0 < h[o_$4,held]) ==> (ih[o_$4,mu] == h[o_$4,mu]) )))) && ((forall  o_$5 : ref :: {h[o_$5,rdheld]} ( h[o_$5,rdheld] ==> (ih[o_$5,mu] == h[o_$5,mu]) )))) ));
	assume (forall<T> m_$3 : MaskType, obj : ref, f_$1 : Field (T)  :: {CanRead(m_$3,obj,f_$1)} {:expand  false}( CanRead(m_$3,obj,f_$1) <==> ((0 < m_$3[obj,f_$1][perm$R]) || (0 < m_$3[obj,f_$1][perm$N])) ));
	assume (forall<T> m_$4 : MaskType, obj_$0 : ref, f_$2 : Field (T)  :: {CanWrite(m_$4,obj_$0,f_$2)} {:expand  false}( CanWrite(m_$4,obj_$0,f_$2) <==> ((m_$4[obj_$0,f_$2][perm$R] == Permission$FullFraction) && (m_$4[obj_$0,f_$2][perm$N] == 0)) ));
	assume (forall  m_$5 : MaskType :: {IsGoodMask(m_$5)} {:expand  true}( IsGoodMask(m_$5) <==> ((forall<T> o_$6 : ref, f_$3 : Field (T)  :: ( ((0 <= m_$5[o_$6,f_$3][perm$R]) && (NonPredicateField(f_$3) ==> ((m_$5[o_$6,f_$3][perm$R] <= Permission$FullFraction) && ((0 < m_$5[o_$6,f_$3][perm$N]) ==> (m_$5[o_$6,f_$3][perm$R] < Permission$FullFraction))))) && ((m_$5[o_$6,f_$3][perm$N] < 0) ==> (0 < m_$5[o_$6,f_$3][perm$R])) ))) ));
	assume (forall  h_$0 : HeapType, m_$6 : MaskType, o_$7 : ref, q : ref :: {wf(h_$0,m_$6),h_$0[o_$7,mu],h_$0[q,mu]} ( (((wf(h_$0,m_$6) && (!(o_$7 == q))) && ((0 < h_$0[o_$7,held]) || h_$0[o_$7,rdheld])) && ((0 < h_$0[q,held]) || h_$0[q,rdheld])) ==> (!(h_$0[o_$7,mu] == h_$0[q,mu])) ));
	assume (forall<T,U> m_$7 : MaskType, o_$8 : ref, f_$4 : Field (T) , howMuch : Integer, q_$0 : ref, g : Field (U)  :: {DecPerm(m_$7,o_$8,f_$4,howMuch)[q_$0,g][perm$R]} ( DecPerm(m_$7,o_$8,f_$4,howMuch)[q_$0,g][perm$R] == ite((o_$8 == q_$0) && (f_$4 == g),m_$7[q_$0,g][perm$R] - howMuch,m_$7[q_$0,g][perm$R]) ));
	assume (forall<T,U> m_$8 : MaskType, o_$9 : ref, f_$5 : Field (T) , howMuch_$0 : Integer, q_$1 : ref, g_$0 : Field (U)  :: {DecPerm(m_$8,o_$9,f_$5,howMuch_$0)[q_$1,g_$0][perm$N]} ( DecEpsilons(m_$8,o_$9,f_$5,howMuch_$0)[q_$1,g_$0][perm$N] == ite((o_$9 == q_$1) && (f_$5 == g_$0),m_$8[q_$1,g_$0][perm$N] - howMuch_$0,m_$8[q_$1,g_$0][perm$N]) ));
	assume (forall<T,U> m_$9 : MaskType, o_$10 : ref, f_$6 : Field (T) , howMuch_$1 : Integer, q_$2 : ref, g_$1 : Field (U)  :: {IncPerm(m_$9,o_$10,f_$6,howMuch_$1)[q_$2,g_$1][perm$R]} ( IncPerm(m_$9,o_$10,f_$6,howMuch_$1)[q_$2,g_$1][perm$R] == ite((o_$10 == q_$2) && (f_$6 == g_$1),m_$9[q_$2,g_$1][perm$R] + howMuch_$1,m_$9[q_$2,g_$1][perm$R]) ));
	assume (forall<T,U> m_$10 : MaskType, o_$11 : ref, f_$7 : Field (T) , howMuch_$2 : Integer, q_$3 : ref, g_$2 : Field (U)  :: {IncPerm(m_$10,o_$11,f_$7,howMuch_$2)[q_$3,g_$2][perm$N]} ( IncEpsilons(m_$10,o_$11,f_$7,howMuch_$2)[q_$3,g_$2][perm$N] == ite((o_$11 == q_$3) && (f_$7 == g_$2),m_$10[q_$3,g_$2][perm$N] + howMuch_$2,m_$10[q_$3,g_$2][perm$N]) ));
	assume (forall<T,U> h_$1 : HeapType, o_$12 : ref, f_$8 : Field (T) , newValue : U, q_$4 : ref, g_$3 : Field (U)  :: {Havocing(h_$1,o_$12,f_$8,newValue)[q_$4,g_$3]} ( Havocing(h_$1,o_$12,f_$8,newValue)[q_$4,g_$3] == ite((o_$12 == q_$4) && (f_$8 == g_$3),newValue,h_$1[q_$4,g_$3]) ));
	assume (forall  m_$11 : MaskType :: {EmptyMask(m_$11)} ( EmptyMask(m_$11) <==> ((forall<T> o_$13 : ref, f_$9 : Field (T)  :: ( NonPredicateField(f_$9) ==> ((m_$11[o_$13,f_$9][perm$R] <= 0) && (m_$11[o_$13,f_$9][perm$N] <= 0)) ))) ));
	assume (forall  o_$14 : ref :: ( ZeroCredits[o_$14] == 0 ));
	assume (forall  c : CreditsType :: {EmptyCredits(c)} ( EmptyCredits(c) <==> ((forall  o_$15 : ref :: ( (!(o_$15 == null)) ==> (c[o_$15] == 0) ))) ));
	assume (forall<T> f_$10 : Field (T)  :: ( NonPredicateField(f_$10) ==> (!PredicateField(f_$10)) ));
	assume (forall<T> f_$11 : Field (T)  :: ( PredicateField(f_$11) ==> (!NonPredicateField(f_$11)) ));
	assume (forall  m1 : MaskType, m2 : MaskType :: {submask(m1,m2)} ( submask(m1,m2) <==> ((forall<T> o_$16 : ref, f_$12 : Field (T)  :: ( (m1[o_$16,f_$12][perm$R] < m2[o_$16,f_$12][perm$R]) || ((m1[o_$16,f_$12][perm$R] == m2[o_$16,f_$12][perm$R]) && (m1[o_$16,f_$12][perm$N] <= m2[o_$16,f_$12][perm$N])) ))) ));
	assume (forall<T> con : Boolean, a_$0 : T, b_$0 : T :: {ite(con,a_$0,b_$0)} ( con ==> (ite(con,a_$0,b_$0) == a_$0) ));
	assume (forall<T> con_$0 : Boolean, a_$1 : T, b_$1 : T :: {ite(con_$0,a_$1,b_$1)} ( (!con_$0) ==> (ite(con_$0,a_$1,b_$1) == b_$1) ));
	assume NonPredicateField(FactorialActorChannelExpEP.state);
	assume NonPredicateField(FactorialActorChannelExpEP.ch);
	assume NonPredicateField(FactorialActorChannelExpEP.expch);
	assume PredicateField(FactorialActorChannelExpEP.valid);
	assume NonPredicateField(FactorialActorChannelImpEP.state);
	assume NonPredicateField(FactorialActorChannelImpEP.ch);
	assume NonPredicateField(FactorialActorChannelImpEP.impch);
	assume PredicateField(FactorialActorChannelImpEP.valid);
	assume NonPredicateField(FactorialActorChannel.imp);
	assume NonPredicateField(FactorialActorChannel.exp);
	assume PredicateField(FactorialActorChannel.valid);
	assume PredicateField(FactorialActorChannel.initImpState);
	assume PredicateField(FactorialActorChannel.initExpState);
	assume NonPredicateField(FactorialContChannelExpEP.state);
	assume NonPredicateField(FactorialContChannelExpEP.ch);
	assume NonPredicateField(FactorialContChannelExpEP.expch);
	assume PredicateField(FactorialContChannelExpEP.valid);
	assume NonPredicateField(FactorialContChannelImpEP.state);
	assume NonPredicateField(FactorialContChannelImpEP.ch);
	assume NonPredicateField(FactorialContChannelImpEP.impch);
	assume PredicateField(FactorialContChannelImpEP.valid);
	assume NonPredicateField(FactorialContChannel.imp);
	assume NonPredicateField(FactorialContChannel.exp);
	assume PredicateField(FactorialContChannel.valid);
	assume PredicateField(FactorialContChannel.initImpState);
	assume PredicateField(FactorialContChannel.initExpState);
	assume NonPredicateField(FutureChannelExpEP.state);
	assume NonPredicateField(FutureChannelExpEP.ch);
	assume NonPredicateField(FutureChannelExpEP.expch);
	assume PredicateField(FutureChannelExpEP.valid);
	assume NonPredicateField(FutureChannelImpEP.state);
	assume NonPredicateField(FutureChannelImpEP.ch);
	assume NonPredicateField(FutureChannelImpEP.impch);
	assume PredicateField(FutureChannelImpEP.valid);
	assume NonPredicateField(FutureChannel.imp);
	assume NonPredicateField(FutureChannel.exp);
	assume PredicateField(FutureChannel.valid);
	assume PredicateField(FutureChannel.initImpState);
	assume PredicateField(FutureChannel.initExpState);
	assume NonPredicateField(Future.sent);
	assume NonPredicateField(Future.value);
	assume NonPredicateField(Future.q);
	assume (forall  Heap_$0 : HeapType, Mask_$0 : MaskType, this_$0 : ref :: {#Future.getQ(Heap_$0,Mask_$0,this_$0)} ( (wf(Heap_$0,Mask_$0) && (CurrentModule == module#default)) ==> (#Future.getQ(Heap_$0,Mask_$0,this_$0) == Heap_$0[this_$0,Future.q]) ));
	assume (forall  Heap_$1 : HeapType, Mask_$1 : MaskType, this_$1 : ref :: {#Future.getQ(Heap_$1,Mask_$1,this_$1)} ( ((wf(Heap_$1,Mask_$1) && IsGoodState(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])))) && CanAssumeFunctionDefs) ==> (#Future.getQ(Heap_$1,Mask_$1,this_$1) == ##Future.getQ(combine(nostate,combine(Heap_$1[this_$1,Future.q],Heap_$1[Heap_$1[this_$1,Future.q],FutureChannel.valid])),this_$1)) ));
	assume NonPredicateField(Message.type);
	assume NonPredicateField(Message.sender1);
	assume NonPredicateField(Message.sender3);
	assume NonPredicateField(Message.sender2);
	assume NonPredicateField(Message.sender4);
	assume NonPredicateField(Message.receiver1);
	assume NonPredicateField(Message.receiver2);
	assume NonPredicateField(Message.receiver3);
	assume NonPredicateField(Message.receiver4);
	assume NonPredicateField(Message.v1);
	assume NonPredicateField(Message.vo1);
	assume NonPredicateField(Message.cust1);
	assume NonPredicateField(Message.vr1);
	assume NonPredicateField(Message.old1);
	assume NonPredicateField(Message.vr2);
	assume NonPredicateField(Message.old2);
	assume NonPredicateField(Message.vr3);
	assume (forall  Heap_$2 : HeapType, Mask_$2 : MaskType, this_$2 : ref, v#49 : Integer :: {#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49)} ( (wf(Heap_$2,Mask_$2) && (CurrentModule == module#default)) ==> (#Message.factorial(Heap_$2,Mask_$2,this_$2,v#49) == ite(v#49 == 0,1,v#49 * #Message.factorial(Heap_$2,Mask_$2,this_$2,v#49 - 1))) ));
	assume (forall  Heap_$3 : HeapType, Mask_$3 : MaskType, this_$3 : ref, v#49_$0 : Integer :: {#Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0)} ( #Message.factorial(Heap_$3,Mask_$3,this_$3,v#49_$0) == #Message.factorial#limited(Heap_$3,Mask_$3,this_$3,v#49_$0) ));
	assume (forall  Heap_$4 : HeapType, Mask_$4 : MaskType, this_$4 : ref, v#49_$1 : Integer :: {#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1)} ( ((wf(Heap_$4,Mask_$4) && IsGoodState(combine(nostate,nostate))) && CanAssumeFunctionDefs) ==> (#Message.factorial#limited(Heap_$4,Mask_$4,this_$4,v#49_$1) == ##Message.factorial(combine(nostate,nostate),this_$4,v#49_$1)) ));
	assume (forall  Heap_$5 : HeapType, Mask_$5 : MaskType, this_$5 : ref, v#49_$2 : Integer :: {#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2)} ( (wf(Heap_$5,Mask_$5) && CanAssumeFunctionDefs) ==> ((v#49_$2 == 0) ==> (#Message.factorial(Heap_$5,Mask_$5,this_$5,v#49_$2) == 1)) ));
	assume (forall  Heap_$6 : HeapType, Mask_$6 : MaskType, this_$6 : ref, v#49_$3 : Integer :: {#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3)} ( (wf(Heap_$6,Mask_$6) && CanAssumeFunctionDefs) ==> ((v#49_$3 > 0) ==> (#Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3) == (v#49_$3 * #Message.factorial(Heap_$6,Mask_$6,this_$6,v#49_$3 - 1)))) ));
	assume PredicateField(Message.invValue);
	assume PredicateField(Message.invResult1);
	assume PredicateField(Message.invResult2);
	assume PredicateField(Message.invFinalResult);
	assume PredicateField(Message.inv);
	assume NonPredicateField(FactorialActor.q);
	assume (forall  Heap_$7 : HeapType, Mask_$7 : MaskType, this_$7 : ref :: {#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7)} ( (wf(Heap_$7,Mask_$7) && (CurrentModule == module#default)) ==> (#FactorialActor.getQ(Heap_$7,Mask_$7,this_$7) == Heap_$7[this_$7,FactorialActor.q]) ));
	assume (forall  Heap_$8 : HeapType, Mask_$8 : MaskType, this_$8 : ref :: {#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8)} ( ((wf(Heap_$8,Mask_$8) && IsGoodState(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialActor.getQ(Heap_$8,Mask_$8,this_$8) == ##FactorialActor.getQ(combine(nostate,combine(Heap_$8[this_$8,FactorialActor.q],Heap_$8[Heap_$8[this_$8,FactorialActor.q],FactorialActorChannel.valid])),this_$8)) ));
	assume NonPredicateField(FactorialCont.q);
	assume NonPredicateField(FactorialCont.v);
	assume NonPredicateField(FactorialCont.vo);
	assume NonPredicateField(FactorialCont.cust);
	assume (forall  Heap_$9 : HeapType, Mask_$9 : MaskType, this_$9 : ref :: {#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9)} ( (wf(Heap_$9,Mask_$9) && (CurrentModule == module#default)) ==> (#FactorialCont.getQ(Heap_$9,Mask_$9,this_$9) == Heap_$9[this_$9,FactorialCont.q]) ));
	assume (forall  Heap_$10 : HeapType, Mask_$10 : MaskType, this_$10 : ref :: {#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10)} ( ((wf(Heap_$10,Mask_$10) && IsGoodState(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])))) && CanAssumeFunctionDefs) ==> (#FactorialCont.getQ(Heap_$10,Mask_$10,this_$10) == ##FactorialCont.getQ(combine(nostate,combine(Heap_$10[this_$10,FactorialCont.q],Heap_$10[Heap_$10[this_$10,FactorialCont.q],FactorialContChannel.valid])),this_$10)) ));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume IsGoodMask(Mask);
	assume (this == null) || (dtype(this) == Channel#t);
	assume (msg#0 == null) || (dtype(msg#0) == Message#t);
	assume !(this == null);
	assume wf(Heap,Mask);
	goto anon0;
anon0:
	assume (0 < whereK#_8) && ((1000 * whereK#_8) < Fractions(1));
	assume IsGoodInhaleState(inhaleHeap#_9_$_0,Heap,ZeroMask);
	assume !(msg#0 == null);
	assume !(msg#0 == null);
	assume Heap_$_0 == Heap[msg#0,Message.type := inhaleHeap#_9_$_0[msg#0,Message.type]];
	assume wf(Heap_$_0,ZeroMask);
	assume true;
	assume channelK > 0;
	assume Mask_$_0 == ZeroMask[msg#0,Message.type := ZeroMask[msg#0,Message.type][perm$R := ZeroMask[msg#0,Message.type][perm$R] + channelK]];
	assume IsGoodMask(Mask_$_0);
	assume IsGoodState(inhaleHeap#_9_$_0[msg#0,Message.type]);
	assume wf(Heap_$_0,Mask_$_0);
	assume wf(inhaleHeap#_9_$_0,Mask_$_0);
	assert { :msg "  6.66: Receiver might be null." } !(msg#0 == null);
	assume !(msg#0 == null);
	assume Heap_$_1 == Heap_$_0[msg#0,Message.inv := inhaleHeap#_9_$_0[msg#0,Message.inv]];
	assume wf(Heap_$_1,Mask_$_0);
	assume inhaleHeap#_9_$_0[msg#0,Message.inv] == Heap_$_1;
	assume Fractions(100) > 0;
	assume Mask_$_1 == Mask_$_0[msg#0,Message.inv := Mask_$_0[msg#0,Message.inv][perm$R := Mask_$_0[msg#0,Message.inv][perm$R] + Fractions(100)]];
	assume IsGoodMask(Mask_$_1);
	assume IsGoodState(inhaleHeap#_9_$_0[msg#0,Message.inv]);
	assume wf(Heap_$_1,Mask_$_1);
	assume wf(inhaleHeap#_9_$_0,Mask_$_1);
	assume IsGoodMask(Mask_$_1);
	assume wf(Heap_$_1,Mask_$_1);
	goto $exit;
}
