type Integer = int;
type Boolean = bool;
type Set T = [T]bool;
type HeapType = <alpha>[ref,Field (alpha)]alpha;
type ref;
type Seq m0;
type BoxType;
type ClassName;
type DatatypeType;
type DtCtorId;
type Field m0;
type TickType;
const $$Language$Dafny : bool;
const null : ref;
const unique class.int : ClassName;
const unique class.bool : ClassName;
const unique class.set : ClassName;
const unique class.seq : ClassName;
const $ModuleContextHeight : int;
const $FunctionContextHeight : int;
const $InMethodContext : bool;
const unique alloc : Field (bool);
const unique class.object : ClassName;
const unique class.array : ClassName;
const unique class.Map : ClassName;
const unique Map.Keys : Field (Seq (BoxType));
const unique Map.Values : Field (Seq (BoxType));
const unique Map.Repr : Field (Set (BoxType) );
const unique Map.head : Field (ref);
const unique Map.nodes : Field (Seq (BoxType));
const unique class.Node : ClassName;
const unique Node.key : Field (BoxType);
const unique Node.val : Field (BoxType);
const unique Node.next : Field (ref);
const unique class._default : ClassName;
const $old_$Heap : HeapType;
const $old_$Tick : TickType;
function Set#Empty <T> () : Set (T) ;
function Set#Singleton <T> (T) : Set (T) ;
function Set#UnionOne <T> (Set (T) ,T) : Set (T) ;
function Set#Union <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Intersection <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Difference <T> (Set (T) ,Set (T) ) : Set (T) ;
function Set#Subset <T> (Set (T) ,Set (T) ) : bool;
function Set#Equal <T> (Set (T) ,Set (T) ) : bool;
function Set#Disjoint <T> (Set (T) ,Set (T) ) : bool;
function Set#Choose <T> (Set (T) ,TickType) : T;
function Seq#Length <T> (Seq (T)) : int;
function Seq#Empty <T> () : Seq (T);
function Seq#Singleton <T> (T) : Seq (T);
function Seq#Build <T> (Seq (T),int,T,int) : Seq (T);
function Seq#Append <T> (Seq (T),Seq (T)) : Seq (T);
function Seq#Index <T> (Seq (T),int) : T;
function Seq#Update <T> (Seq (T),int,T) : Seq (T);
function Seq#Contains <T> (Seq (T),T) : bool;
function Seq#Equal <T> (Seq (T),Seq (T)) : bool;
function Seq#SameUntil <T> (Seq (T),Seq (T),int) : bool;
function Seq#Take <T> (Seq (T),int) : Seq (T);
function Seq#Drop <T> (Seq (T),int) : Seq (T);
function $Box <T> (T) : BoxType;
function $Unbox <T> (BoxType) : T;
function $IsCanonicalBoolBox(BoxType) : bool;
function dtype(ref) : ClassName;
function TypeParams(ref,int) : ClassName;
function TypeTuple(ClassName,ClassName) : ClassName;
function TypeTupleCar(ClassName) : ClassName;
function TypeTupleCdr(ClassName) : ClassName;
function DtType(DatatypeType) : ClassName;
function DtTypeParams(DatatypeType,int) : ClassName;
function DatatypeCtorId(DatatypeType) : DtCtorId;
function DtRank(DatatypeType) : int;
function FDim <T> (Field (T)) : int;
function IndexField(int) : Field (BoxType);
function IndexField_Inverse <T> (Field (T)) : int;
function MultiIndexField(Field (BoxType),int) : Field (BoxType);
function MultiIndexField_Inverse0 <T> (Field (T)) : Field (T);
function MultiIndexField_Inverse1 <T> (Field (T)) : int;
function DeclType <T> (Field (T)) : ClassName;
function DtAlloc(DatatypeType,HeapType) : bool;
function GenericAlloc(BoxType,HeapType) : bool;
function {:inline  true} read <alpha> (H:HeapType,r:ref,f:Field (alpha)) : alpha {H[r,f]}
function {:inline  true} update <alpha> (H_$0:HeapType,r_$0:ref,f_$0:Field (alpha),v:alpha) : HeapType {H_$0[r_$0,f_$0 := v]}
function $IsGoodHeap(HeapType) : bool;
function $HeapSucc(HeapType,HeapType) : bool;
function array.Length(ref) : int;
function Map.Valid(HeapType,ref) : bool;
function Map.Valid#canCall(HeapType,ref) : bool;
function lambda#0(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
function lambda#1(ref,ref,HeapType,Field (bool)) : <alpha>[ref,Field (alpha)]bool;
function lambda#2(ref,ref,HeapType,Field (bool)) : <alpha>[ref,Field (alpha)]bool;
function lambda#3(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#4(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#5(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
function lambda#6(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
function lambda#7(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
function lambda#8(Field (Set (BoxType) ),ref,HeapType,Field (bool),ref) : <alpha>[ref,Field (alpha)]bool;
function lambda#9(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
function lambda#10(Field (bool),ref,HeapType) : <alpha>[ref,Field (alpha)]bool;
var $Heap : HeapType;
var $Tick : TickType;
procedure Map.Remove (this : ref,key#16 : BoxType)
{
	var $_Frame : <beta>[ref,Field (beta)]bool;
	var p#20 : ref;
	var n#21 : int;
	var prev#22 : ref;
	var $rhs#0 : ref;
	var $rhs#1 : int;
	var $rhs#2 : ref;
	var key#36 : BoxType;
	var $rhs#3 : Seq (BoxType);
	var $rhs#4 : Seq (BoxType);
	var $rhs#5 : Seq (BoxType);
	var $rhs#6 : ref;
	var $rhs#7 : ref;
	var $_Frame_$_0 : <beta>[ref,Field (beta)]bool;
	var $Heap_$_0 : HeapType;
	var $Tick_$_0 : TickType;
	var call4formal_$_p#24_$_0 : ref;
	var call5formal_$_n#25_$_0 : int;
	var call6formal_$_prev#26_$_0 : ref;
	var $rhs#3_$_0 : Seq (BoxType);
	var $Heap_$_1 : HeapType;
	var $rhs#4_$_0 : Seq (BoxType);
	var $Heap_$_2 : HeapType;
	var $rhs#5_$_0 : Seq (BoxType);
	var $Heap_$_3 : HeapType;
	var $rhs#6_$_0 : ref;
	var $Heap_$_4 : HeapType;
	var $rhs#7_$_0 : ref;
	var $Heap_$_5 : HeapType;
	var $Heap_$_6 : HeapType;
	var $_$_condition : bool;
	var $_$_condition_$0 : bool;
$start:
	assume $$Language$Dafny;
	assume (forall<T> o : T :: {(Set#Empty() : Set (T) )[o]} ( !(Set#Empty() : Set (T) )[o] ));
	assume (forall<T> r_$1 : T :: {Set#Singleton(r_$1)} ( Set#Singleton(r_$1)[r_$1] ));
	assume (forall<T> r_$2 : T, o_$0 : T :: {Set#Singleton(r_$2)[o_$0]} ( Set#Singleton(r_$2)[o_$0] <==> (r_$2 == o_$0) ));
	assume (forall<T> a : Set (T) , x : T, o_$1 : T :: {Set#UnionOne(a,x)[o_$1]} ( Set#UnionOne(a,x)[o_$1] <==> ((o_$1 == x) || a[o_$1]) ));
	assume (forall<T> a_$0 : Set (T) , x_$0 : T :: {Set#UnionOne(a_$0,x_$0)} ( Set#UnionOne(a_$0,x_$0)[x_$0] ));
	assume (forall<T> a_$1 : Set (T) , x_$1 : T, y : T :: {Set#UnionOne(a_$1,x_$1),a_$1[y]} ( a_$1[y] ==> Set#UnionOne(a_$1,x_$1)[y] ));
	assume (forall<T> a_$2 : Set (T) , b : Set (T) , o_$2 : T :: {Set#Union(a_$2,b)[o_$2]} ( Set#Union(a_$2,b)[o_$2] <==> (a_$2[o_$2] || b[o_$2]) ));
	assume (forall<T> a_$3 : Set (T) , b_$0 : Set (T) , y_$0 : T :: {Set#Union(a_$3,b_$0),a_$3[y_$0]} ( a_$3[y_$0] ==> Set#Union(a_$3,b_$0)[y_$0] ));
	assume (forall<T> a_$4 : Set (T) , b_$1 : Set (T) , y_$1 : T :: {Set#Union(a_$4,b_$1),b_$1[y_$1]} ( b_$1[y_$1] ==> Set#Union(a_$4,b_$1)[y_$1] ));
	assume (forall<T> a_$5 : Set (T) , b_$2 : Set (T)  :: {Set#Union(a_$5,b_$2)} ( Set#Disjoint(a_$5,b_$2) ==> ((Set#Difference(Set#Union(a_$5,b_$2),a_$5) == b_$2) && (Set#Difference(Set#Union(a_$5,b_$2),b_$2) == a_$5)) ));
	assume (forall<T> a_$6 : Set (T) , b_$3 : Set (T) , o_$3 : T :: {Set#Intersection(a_$6,b_$3)[o_$3]} ( Set#Intersection(a_$6,b_$3)[o_$3] <==> (a_$6[o_$3] && b_$3[o_$3]) ));
	assume (forall<T> a_$7 : Set (T) , b_$4 : Set (T)  :: {Set#Union(Set#Union(a_$7,b_$4),b_$4)} ( Set#Union(Set#Union(a_$7,b_$4),b_$4) == Set#Union(a_$7,b_$4) ));
	assume (forall<T> a_$8 : Set (T) , b_$5 : Set (T)  :: {Set#Union(a_$8,Set#Union(a_$8,b_$5))} ( Set#Union(a_$8,Set#Union(a_$8,b_$5)) == Set#Union(a_$8,b_$5) ));
	assume (forall<T> a_$9 : Set (T) , b_$6 : Set (T)  :: {Set#Intersection(Set#Intersection(a_$9,b_$6),b_$6)} ( Set#Intersection(Set#Intersection(a_$9,b_$6),b_$6) == Set#Intersection(a_$9,b_$6) ));
	assume (forall<T> a_$10 : Set (T) , b_$7 : Set (T)  :: {Set#Intersection(a_$10,Set#Intersection(a_$10,b_$7))} ( Set#Intersection(a_$10,Set#Intersection(a_$10,b_$7)) == Set#Intersection(a_$10,b_$7) ));
	assume (forall<T> a_$11 : Set (T) , b_$8 : Set (T) , o_$4 : T :: {Set#Difference(a_$11,b_$8)[o_$4]} ( Set#Difference(a_$11,b_$8)[o_$4] <==> (a_$11[o_$4] && (!b_$8[o_$4])) ));
	assume (forall<T> a_$12 : Set (T) , b_$9 : Set (T) , y_$2 : T :: {Set#Difference(a_$12,b_$9),b_$9[y_$2]} ( b_$9[y_$2] ==> (!Set#Difference(a_$12,b_$9)[y_$2]) ));
	assume (forall<T> a_$13 : Set (T) , b_$10 : Set (T)  :: {Set#Subset(a_$13,b_$10)} ( Set#Subset(a_$13,b_$10) <==> ((forall  o_$5 : T :: {a_$13[o_$5]} {b_$10[o_$5]} ( a_$13[o_$5] ==> b_$10[o_$5] ))) ));
	assume (forall<T> a_$14 : Set (T) , b_$11 : Set (T)  :: {Set#Equal(a_$14,b_$11)} ( Set#Equal(a_$14,b_$11) <==> ((forall  o_$6 : T :: {a_$14[o_$6]} {b_$11[o_$6]} ( a_$14[o_$6] <==> b_$11[o_$6] ))) ));
	assume (forall<T> a_$15 : Set (T) , b_$12 : Set (T)  :: {Set#Equal(a_$15,b_$12)} ( Set#Equal(a_$15,b_$12) ==> (a_$15 == b_$12) ));
	assume (forall<T> a_$16 : Set (T) , b_$13 : Set (T)  :: {Set#Disjoint(a_$16,b_$13)} ( Set#Disjoint(a_$16,b_$13) <==> ((forall  o_$7 : T :: {a_$16[o_$7]} {b_$13[o_$7]} ( (!a_$16[o_$7]) || (!b_$13[o_$7]) ))) ));
	assume (forall<T> a_$17 : Set (T) , tick : TickType :: {Set#Choose(a_$17,tick)} ( (!(a_$17 == (Set#Empty() : Set (T) ))) ==> a_$17[Set#Choose(a_$17,tick)] ));
	assume (forall<T> s : Seq (T)  :: {Seq#Length(s)} ( 0 <= Seq#Length(s) ));
	assume (forall<T> :: Seq#Length((Seq#Empty() : Seq (T) )) == 0);
	assume (forall<T> s_$0 : Seq (T)  :: {Seq#Length(s_$0)} ( (Seq#Length(s_$0) == 0) ==> (s_$0 == (Seq#Empty() : Seq (T) )) ));
	assume (forall<T> t : T :: {Seq#Length(Seq#Singleton(t))} ( Seq#Length(Seq#Singleton(t)) == 1 ));
	assume (forall<T> s_$1 : Seq (T) , i : Integer, v_$0 : T, len : Integer :: {Seq#Length(Seq#Build(s_$1,i,v_$0,len))} ( (0 <= len) ==> (Seq#Length(Seq#Build(s_$1,i,v_$0,len)) == len) ));
	assume (forall<T> s0 : Seq (T) , s1 : Seq (T)  :: {Seq#Length(Seq#Append(s0,s1))} ( Seq#Length(Seq#Append(s0,s1)) == (Seq#Length(s0) + Seq#Length(s1)) ));
	assume (forall<T> t_$0 : T :: {Seq#Index(Seq#Singleton(t_$0),0)} ( Seq#Index(Seq#Singleton(t_$0),0) == t_$0 ));
	assume (forall<T> s0_$0 : Seq (T) , s1_$0 : Seq (T) , n : Integer :: {Seq#Index(Seq#Append(s0_$0,s1_$0),n)} ( ((n < Seq#Length(s0_$0)) ==> (Seq#Index(Seq#Append(s0_$0,s1_$0),n) == Seq#Index(s0_$0,n))) && ((Seq#Length(s0_$0) <= n) ==> (Seq#Index(Seq#Append(s0_$0,s1_$0),n) == Seq#Index(s1_$0,n - Seq#Length(s0_$0)))) ));
	assume (forall<T> s_$2 : Seq (T) , i_$0 : Integer, v_$1 : T, len_$0 : Integer, n_$0 : Integer :: {Seq#Index(Seq#Build(s_$2,i_$0,v_$1,len_$0),n_$0)} ( ((0 <= n_$0) && (n_$0 < len_$0)) ==> (((i_$0 == n_$0) ==> (Seq#Index(Seq#Build(s_$2,i_$0,v_$1,len_$0),n_$0) == v_$1)) && ((!(i_$0 == n_$0)) ==> (Seq#Index(Seq#Build(s_$2,i_$0,v_$1,len_$0),n_$0) == Seq#Index(s_$2,n_$0)))) ));
	assume (forall<T> s_$3 : Seq (T) , i_$1 : Integer, v_$2 : T :: {Seq#Length(Seq#Update(s_$3,i_$1,v_$2))} ( ((0 <= i_$1) && (i_$1 < Seq#Length(s_$3))) ==> (Seq#Length(Seq#Update(s_$3,i_$1,v_$2)) == Seq#Length(s_$3)) ));
	assume (forall<T> s_$4 : Seq (T) , i_$2 : Integer, v_$3 : T, n_$1 : Integer :: {Seq#Index(Seq#Update(s_$4,i_$2,v_$3),n_$1)} ( ((0 <= n_$1) && (n_$1 < Seq#Length(s_$4))) ==> (((i_$2 == n_$1) ==> (Seq#Index(Seq#Update(s_$4,i_$2,v_$3),n_$1) == v_$3)) && ((!(i_$2 == n_$1)) ==> (Seq#Index(Seq#Update(s_$4,i_$2,v_$3),n_$1) == Seq#Index(s_$4,n_$1)))) ));
	assume (forall<T> s_$5 : Seq (T) , x_$2 : T :: {Seq#Contains(s_$5,x_$2)} ( Seq#Contains(s_$5,x_$2) <==> ((exists  i_$3 : Integer :: {Seq#Index(s_$5,i_$3)} ( ((0 <= i_$3) && (i_$3 < Seq#Length(s_$5))) && (Seq#Index(s_$5,i_$3) == x_$2) ))) ));
	assume (forall  x_$3 : ref :: {Seq#Contains((Seq#Empty() : Seq (ref) ),x_$3)} ( !Seq#Contains((Seq#Empty() : Seq (ref) ),x_$3) ));
	assume (forall<T> s0_$1 : Seq (T) , s1_$1 : Seq (T) , x_$4 : T :: {Seq#Contains(Seq#Append(s0_$1,s1_$1),x_$4)} ( Seq#Contains(Seq#Append(s0_$1,s1_$1),x_$4) <==> (Seq#Contains(s0_$1,x_$4) || Seq#Contains(s1_$1,x_$4)) ));
	assume (forall<T> s_$6 : Seq (T) , i_$4 : Integer, v_$4 : T, len_$1 : Integer, x_$5 : T :: {Seq#Contains(Seq#Build(s_$6,i_$4,v_$4,len_$1),x_$5)} ( Seq#Contains(Seq#Build(s_$6,i_$4,v_$4,len_$1),x_$5) <==> ((((0 <= i_$4) && (i_$4 < len_$1)) && (x_$5 == v_$4)) || ((exists  j : Integer :: {Seq#Index(s_$6,j)} ( ((((0 <= j) && (j < Seq#Length(s_$6))) && (j < len_$1)) && (!(j == i_$4))) && (Seq#Index(s_$6,j) == x_$5) )))) ));
	assume (forall<T> s_$7 : Seq (T) , n_$2 : Integer, x_$6 : T :: {Seq#Contains(Seq#Take(s_$7,n_$2),x_$6)} ( Seq#Contains(Seq#Take(s_$7,n_$2),x_$6) <==> ((exists  i_$5 : Integer :: {Seq#Index(s_$7,i_$5)} ( (((0 <= i_$5) && (i_$5 < n_$2)) && (i_$5 < Seq#Length(s_$7))) && (Seq#Index(s_$7,i_$5) == x_$6) ))) ));
	assume (forall<T> s_$8 : Seq (T) , n_$3 : Integer, x_$7 : T :: {Seq#Contains(Seq#Drop(s_$8,n_$3),x_$7)} ( Seq#Contains(Seq#Drop(s_$8,n_$3),x_$7) <==> ((exists  i_$6 : Integer :: {Seq#Index(s_$8,i_$6)} ( (((0 <= n_$3) && (n_$3 <= i_$6)) && (i_$6 < Seq#Length(s_$8))) && (Seq#Index(s_$8,i_$6) == x_$7) ))) ));
	assume (forall<T> s0_$2 : Seq (T) , s1_$2 : Seq (T)  :: {Seq#Equal(s0_$2,s1_$2)} ( Seq#Equal(s0_$2,s1_$2) <==> ((Seq#Length(s0_$2) == Seq#Length(s1_$2)) && ((forall  j_$0 : Integer :: {Seq#Index(s0_$2,j_$0)} {Seq#Index(s1_$2,j_$0)} ( ((0 <= j_$0) && (j_$0 < Seq#Length(s0_$2))) ==> (Seq#Index(s0_$2,j_$0) == Seq#Index(s1_$2,j_$0)) )))) ));
	assume (forall<T> a_$18 : Seq (T) , b_$14 : Seq (T)  :: {Seq#Equal(a_$18,b_$14)} ( Seq#Equal(a_$18,b_$14) ==> (a_$18 == b_$14) ));
	assume (forall<T> s0_$3 : Seq (T) , s1_$3 : Seq (T) , n_$4 : Integer :: {Seq#SameUntil(s0_$3,s1_$3,n_$4)} ( Seq#SameUntil(s0_$3,s1_$3,n_$4) <==> ((forall  j_$1 : Integer :: {Seq#Index(s0_$3,j_$1)} {Seq#Index(s1_$3,j_$1)} ( ((0 <= j_$1) && (j_$1 < n_$4)) ==> (Seq#Index(s0_$3,j_$1) == Seq#Index(s1_$3,j_$1)) ))) ));
	assume (forall<T> s_$9 : Seq (T) , n_$5 : Integer :: {Seq#Length(Seq#Take(s_$9,n_$5))} ( (0 <= n_$5) ==> (((n_$5 <= Seq#Length(s_$9)) ==> (Seq#Length(Seq#Take(s_$9,n_$5)) == n_$5)) && ((Seq#Length(s_$9) < n_$5) ==> (Seq#Length(Seq#Take(s_$9,n_$5)) == Seq#Length(s_$9)))) ));
	assume (forall<T> s_$10 : Seq (T) , n_$6 : Integer, j_$2 : Integer :: {Seq#Index(Seq#Take(s_$10,n_$6),j_$2)} {:weight  25}( (((0 <= j_$2) && (j_$2 < n_$6)) && (j_$2 < Seq#Length(s_$10))) ==> (Seq#Index(Seq#Take(s_$10,n_$6),j_$2) == Seq#Index(s_$10,j_$2)) ));
	assume (forall<T> s_$11 : Seq (T) , n_$7 : Integer :: {Seq#Length(Seq#Drop(s_$11,n_$7))} ( (0 <= n_$7) ==> (((n_$7 <= Seq#Length(s_$11)) ==> (Seq#Length(Seq#Drop(s_$11,n_$7)) == (Seq#Length(s_$11) - n_$7))) && ((Seq#Length(s_$11) < n_$7) ==> (Seq#Length(Seq#Drop(s_$11,n_$7)) == 0))) ));
	assume (forall<T> s_$12 : Seq (T) , n_$8 : Integer, j_$3 : Integer :: {Seq#Index(Seq#Drop(s_$12,n_$8),j_$3)} {:weight  25}( (((0 <= n_$8) && (0 <= j_$3)) && (j_$3 < (Seq#Length(s_$12) - n_$8))) ==> (Seq#Index(Seq#Drop(s_$12,n_$8),j_$3) == Seq#Index(s_$12,j_$3 + n_$8)) ));
	assume (forall<T> s_$13 : Seq (T) , t_$1 : Seq (T)  :: {Seq#Append(s_$13,t_$1)} ( (Seq#Take(Seq#Append(s_$13,t_$1),Seq#Length(s_$13)) == s_$13) && (Seq#Drop(Seq#Append(s_$13,t_$1),Seq#Length(s_$13)) == t_$1) ));
	assume (forall<T> x_$8 : T :: {$Box(x_$8)} ( ($Unbox($Box(x_$8)) : T) == x_$8 ));
	assume (forall  b_$15 : BoxType :: {($Unbox(b_$15) : Integer)} ( $Box(($Unbox(b_$15) : Integer)) == b_$15 ));
	assume (forall  b_$16 : BoxType :: {($Unbox(b_$16) : ref)} ( $Box(($Unbox(b_$16) : ref)) == b_$16 ));
	assume (forall  b_$17 : BoxType :: {($Unbox(b_$17) : [BoxType]Boolean)} ( $Box(($Unbox(b_$17) : [BoxType]Boolean)) == b_$17 ));
	assume (forall  b_$18 : BoxType :: {($Unbox(b_$18) : Seq (BoxType) )} ( $Box(($Unbox(b_$18) : Seq (BoxType) )) == b_$18 ));
	assume (forall  b_$19 : BoxType :: {($Unbox(b_$19) : DatatypeType)} ( $Box(($Unbox(b_$19) : DatatypeType)) == b_$19 ));
	assume $IsCanonicalBoolBox($Box(false)) && $IsCanonicalBoolBox($Box(true));
	assume (forall  b_$20 : BoxType :: {($Unbox(b_$20) : Boolean)} ( $IsCanonicalBoolBox(b_$20) ==> ($Box(($Unbox(b_$20) : Boolean)) == b_$20) ));
	assume (forall  a_$19 : ClassName, b_$21 : ClassName :: {TypeTuple(a_$19,b_$21)} ( (TypeTupleCar(TypeTuple(a_$19,b_$21)) == a_$19) && (TypeTupleCdr(TypeTuple(a_$19,b_$21)) == b_$21) ));
	assume (forall  i_$7 : Integer :: {IndexField(i_$7)} ( FDim(IndexField(i_$7)) == 1 ));
	assume (forall  i_$8 : Integer :: {IndexField(i_$8)} ( IndexField_Inverse(IndexField(i_$8)) == i_$8 ));
	assume (forall  f_$1 : Field (BoxType) , i_$9 : Integer :: {MultiIndexField(f_$1,i_$9)} ( FDim(MultiIndexField(f_$1,i_$9)) == (FDim(f_$1) + 1) ));
	assume (forall  f_$2 : Field (BoxType) , i_$10 : Integer :: {MultiIndexField(f_$2,i_$10)} ( (MultiIndexField_Inverse0(MultiIndexField(f_$2,i_$10)) == f_$2) && (MultiIndexField_Inverse1(MultiIndexField(f_$2,i_$10)) == i_$10) ));
	assume FDim(alloc) == 0;
	assume (forall  h : HeapType, k : HeapType, d : DatatypeType :: {$HeapSucc(h,k),DtAlloc(d,h)} {$HeapSucc(h,k),DtAlloc(d,k)} ( $HeapSucc(h,k) ==> (DtAlloc(d,h) ==> DtAlloc(d,k)) ));
	assume (forall  h_$0 : HeapType, k_$0 : HeapType, d_$0 : BoxType :: {$HeapSucc(h_$0,k_$0),GenericAlloc(d_$0,h_$0)} {$HeapSucc(h_$0,k_$0),GenericAlloc(d_$0,k_$0)} ( $HeapSucc(h_$0,k_$0) ==> (GenericAlloc(d_$0,h_$0) ==> GenericAlloc(d_$0,k_$0)) ));
	assume (forall  b_$22 : BoxType, h_$1 : HeapType :: {GenericAlloc(b_$22,h_$1),h_$1[($Unbox(b_$22) : ref),alloc]} ( GenericAlloc(b_$22,h_$1) ==> ((($Unbox(b_$22) : ref) == null) || h_$1[($Unbox(b_$22) : ref),alloc]) ));
	assume (forall  b_$23 : BoxType, h_$2 : HeapType, i_$11 : Integer :: {GenericAlloc(b_$23,h_$2),Seq#Index(($Unbox(b_$23) : Seq (BoxType) ),i_$11)} ( ((GenericAlloc(b_$23,h_$2) && (0 <= i_$11)) && (i_$11 < Seq#Length(($Unbox(b_$23) : Seq (BoxType) )))) ==> GenericAlloc(Seq#Index(($Unbox(b_$23) : Seq (BoxType) ),i_$11),h_$2) ));
	assume (forall  b_$24 : BoxType, h_$3 : HeapType, t_$2 : BoxType :: {GenericAlloc(b_$24,h_$3),($Unbox(b_$24) : [BoxType]Boolean)[t_$2]} ( (GenericAlloc(b_$24,h_$3) && ($Unbox(b_$24) : [BoxType]Boolean)[t_$2]) ==> GenericAlloc(t_$2,h_$3) ));
	assume (forall  b_$25 : BoxType, h_$4 : HeapType :: {GenericAlloc(b_$25,h_$4),DtType(($Unbox(b_$25) : DatatypeType))} ( GenericAlloc(b_$25,h_$4) ==> DtAlloc(($Unbox(b_$25) : DatatypeType),h_$4) ));
	assume (forall  b_$26 : Boolean, h_$5 : HeapType :: ( $IsGoodHeap(h_$5) ==> GenericAlloc($Box(b_$26),h_$5) ));
	assume (forall  x_$9 : Integer, h_$6 : HeapType :: ( $IsGoodHeap(h_$6) ==> GenericAlloc($Box(x_$9),h_$6) ));
	assume (forall  r_$3 : ref, h_$7 : HeapType :: {GenericAlloc($Box(r_$3),h_$7)} ( ($IsGoodHeap(h_$7) && ((r_$3 == null) || h_$7[r_$3,alloc])) ==> GenericAlloc($Box(r_$3),h_$7) ));
	assume (forall<alpha> f : Field (alpha) , r : ref, H : HeapType :: ( read(H,r,f) == H[r,f] ));
	assume (forall<alpha> v : alpha, f_$0 : Field (alpha) , r_$0 : ref, H_$0 : HeapType :: ( update(H_$0,r_$0,f_$0,v) == H_$0[r_$0,f_$0 := v] ));
	assume (forall<alpha> h_$8 : HeapType, r_$4 : ref, f_$3 : Field (alpha) , x_$10 : alpha :: {update(h_$8,r_$4,f_$3,x_$10)} ( $HeapSucc(h_$8,update(h_$8,r_$4,f_$3,x_$10)) ));
	assume (forall  a_$20 : HeapType, b_$27 : HeapType, c : HeapType :: {$HeapSucc(a_$20,b_$27),$HeapSucc(b_$27,c)} ( ($HeapSucc(a_$20,b_$27) && $HeapSucc(b_$27,c)) ==> $HeapSucc(a_$20,c) ));
	assume (forall  h_$9 : HeapType, k_$1 : HeapType :: {$HeapSucc(h_$9,k_$1)} ( $HeapSucc(h_$9,k_$1) ==> ((forall  o_$8 : ref :: {read(k_$1,o_$8,alloc)} ( read(h_$9,o_$8,alloc) ==> read(k_$1,o_$8,alloc) ))) ));
	assume (forall  x_$11 : Integer, y_$3 : Integer :: {x_$11 mod y_$3} {x_$11 div y_$3} ( (x_$11 mod y_$3) == (x_$11 - ((x_$11 div y_$3) * y_$3)) ));
	assume (forall  x_$12 : Integer, y_$4 : Integer :: {x_$12 mod y_$4} ( (0 < y_$4) ==> ((0 <= (x_$12 mod y_$4)) && ((x_$12 mod y_$4) < y_$4)) ));
	assume (forall  x_$13 : Integer, y_$5 : Integer :: {x_$13 mod y_$5} ( (y_$5 < 0) ==> ((y_$5 < (x_$13 mod y_$5)) && ((x_$13 mod y_$5) <= 0)) ));
	assume (forall  a_$21 : Integer, b_$28 : Integer, d_$1 : Integer :: {a_$21 mod d_$1,b_$28 mod d_$1} ( (((2 <= d_$1) && ((a_$21 mod d_$1) == (b_$28 mod d_$1))) && (a_$21 < b_$28)) ==> ((a_$21 + d_$1) <= b_$28) ));
	assume (forall  o_$9 : ref :: ( 0 <= array.Length(o_$9) ));
	assume (FDim(Map.Keys) == 0) && (DeclType(Map.Keys) == class.Map);
	assume (forall  $h : HeapType, $o : ref :: {read($h,$o,Map.Keys)} ( (($IsGoodHeap($h) && (!($o == null))) && read($h,$o,alloc)) ==> ((forall  $i#0 : Integer :: {Seq#Index(read($h,$o,Map.Keys),$i#0)} ( ((0 <= $i#0) && ($i#0 < Seq#Length(read($h,$o,Map.Keys)))) ==> GenericAlloc(Seq#Index(read($h,$o,Map.Keys),$i#0),$h) ))) ));
	assume (FDim(Map.Values) == 0) && (DeclType(Map.Values) == class.Map);
	assume (forall  $h_$0 : HeapType, $o_$0 : ref :: {read($h_$0,$o_$0,Map.Values)} ( (($IsGoodHeap($h_$0) && (!($o_$0 == null))) && read($h_$0,$o_$0,alloc)) ==> ((forall  $i#1 : Integer :: {Seq#Index(read($h_$0,$o_$0,Map.Values),$i#1)} ( ((0 <= $i#1) && ($i#1 < Seq#Length(read($h_$0,$o_$0,Map.Values)))) ==> GenericAlloc(Seq#Index(read($h_$0,$o_$0,Map.Values),$i#1),$h_$0) ))) ));
	assume (FDim(Map.Repr) == 0) && (DeclType(Map.Repr) == class.Map);
	assume (forall  $h_$1 : HeapType, $o_$1 : ref :: {read($h_$1,$o_$1,Map.Repr)} ( (($IsGoodHeap($h_$1) && (!($o_$1 == null))) && read($h_$1,$o_$1,alloc)) ==> ((forall  $t#2 : BoxType :: {read($h_$1,$o_$1,Map.Repr)[$t#2]} ( read($h_$1,$o_$1,Map.Repr)[$t#2] ==> ((($Unbox($t#2) : ref) == null) || read($h_$1,($Unbox($t#2) : ref),alloc)) ))) ));
	assume (FDim(Map.head) == 0) && (DeclType(Map.head) == class.Map);
	assume (forall  $h_$2 : HeapType, $o_$2 : ref :: {read($h_$2,$o_$2,Map.head)} ( (($IsGoodHeap($h_$2) && (!($o_$2 == null))) && read($h_$2,$o_$2,alloc)) ==> ((read($h_$2,$o_$2,Map.head) == null) || (read($h_$2,read($h_$2,$o_$2,Map.head),alloc) && (dtype(read($h_$2,$o_$2,Map.head)) == class.Node))) ));
	assume (FDim(Map.nodes) == 0) && (DeclType(Map.nodes) == class.Map);
	assume (forall  $h_$3 : HeapType, $o_$3 : ref :: {read($h_$3,$o_$3,Map.nodes)} ( (($IsGoodHeap($h_$3) && (!($o_$3 == null))) && read($h_$3,$o_$3,alloc)) ==> ((forall  $i#3 : Integer :: {Seq#Index(read($h_$3,$o_$3,Map.nodes),$i#3)} ( ((0 <= $i#3) && ($i#3 < Seq#Length(read($h_$3,$o_$3,Map.nodes)))) ==> ((($Unbox(Seq#Index(read($h_$3,$o_$3,Map.nodes),$i#3)) : ref) == null) || (read($h_$3,($Unbox(Seq#Index(read($h_$3,$o_$3,Map.nodes),$i#3)) : ref),alloc) && (dtype(($Unbox(Seq#Index(read($h_$3,$o_$3,Map.nodes),$i#3)) : ref)) == class.Node))) ))) ));
	assume (FDim(Node.key) == 0) && (DeclType(Node.key) == class.Node);
	assume (FDim(Node.val) == 0) && (DeclType(Node.val) == class.Node);
	assume (FDim(Node.next) == 0) && (DeclType(Node.next) == class.Node);
	assume ((0 < $ModuleContextHeight) || ((0 == $ModuleContextHeight) && ((4 <= $FunctionContextHeight) || $InMethodContext))) ==> ((forall  $Heap_$0 : HeapType, this_$0 : ref :: {Map.Valid($Heap_$0,this_$0)} ( (Map.Valid#canCall($Heap_$0,this_$0) || (((((((!(0 == $ModuleContextHeight)) || (!(4 == $FunctionContextHeight))) || $InMethodContext) && $IsGoodHeap($Heap_$0)) && (!(this_$0 == null))) && read($Heap_$0,this_$0,alloc)) && (dtype(this_$0) == class.Map))) ==> ((((((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] ==> true) && ((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] && (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) == Seq#Length(read($Heap_$0,this_$0,Map.Values)))) ==> true)) && (((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] && (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) == Seq#Length(read($Heap_$0,this_$0,Map.Values)))) && (Seq#Length(read($Heap_$0,this_$0,Map.nodes)) == (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) + 1))) ==> true)) && ((((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] && (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) == Seq#Length(read($Heap_$0,this_$0,Map.Values)))) && (Seq#Length(read($Heap_$0,this_$0,Map.nodes)) == (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) + 1))) && (read($Heap_$0,this_$0,Map.head) == ($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),0)) : ref))) ==> ((forall  i#0 : Integer :: ( true ==> (((0 <= i#0) ==> true) && (((0 <= i#0) && (i#0 < Seq#Length(read($Heap_$0,this_$0,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref) == null)) ==> true) && (((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref))]) ==> true)) && ((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref))]) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.key) == Seq#Index(read($Heap_$0,this_$0,Map.Keys),i#0))) ==> true)) && (((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref))]) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.key) == Seq#Index(read($Heap_$0,this_$0,Map.Keys),i#0))) && (!Seq#Contains(Seq#Drop(read($Heap_$0,this_$0,Map.Keys),i#0 + 1),read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.key)))) ==> true)) && ((((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref))]) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.key) == Seq#Index(read($Heap_$0,this_$0,Map.Keys),i#0))) && (!Seq#Contains(Seq#Drop(read($Heap_$0,this_$0,Map.Keys),i#0 + 1),read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.key)))) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0)) : ref),Node.val) == Seq#Index(read($Heap_$0,this_$0,Map.Values),i#0))) ==> true)))) ))))) && (((((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] && (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) == Seq#Length(read($Heap_$0,this_$0,Map.Values)))) && (Seq#Length(read($Heap_$0,this_$0,Map.nodes)) == (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) + 1))) && (read($Heap_$0,this_$0,Map.head) == ($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),0)) : ref))) && ((forall  i#0_$0 : Integer :: ( true ==> (((0 <= i#0_$0) && (i#0_$0 < Seq#Length(read($Heap_$0,this_$0,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref))]) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref),Node.key) == Seq#Index(read($Heap_$0,this_$0,Map.Keys),i#0_$0))) && (!Seq#Contains(Seq#Drop(read($Heap_$0,this_$0,Map.Keys),i#0_$0 + 1),read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref),Node.key)))) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref),Node.val) == Seq#Index(read($Heap_$0,this_$0,Map.Values),i#0_$0))) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$0 + 1)) : ref)))) )))) ==> true)) && (Map.Valid($Heap_$0,this_$0) <==> (((((read($Heap_$0,this_$0,Map.Repr)[$Box(this_$0)] && (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) == Seq#Length(read($Heap_$0,this_$0,Map.Values)))) && (Seq#Length(read($Heap_$0,this_$0,Map.nodes)) == (Seq#Length(read($Heap_$0,this_$0,Map.Keys)) + 1))) && (read($Heap_$0,this_$0,Map.head) == ($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),0)) : ref))) && ((forall  i#0_$1 : Integer :: ( true ==> (((0 <= i#0_$1) && (i#0_$1 < Seq#Length(read($Heap_$0,this_$0,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref) == null)) && read($Heap_$0,this_$0,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref))]) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref),Node.key) == Seq#Index(read($Heap_$0,this_$0,Map.Keys),i#0_$1))) && (!Seq#Contains(Seq#Drop(read($Heap_$0,this_$0,Map.Keys),i#0_$1 + 1),read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref),Node.key)))) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref),Node.val) == Seq#Index(read($Heap_$0,this_$0,Map.Values),i#0_$1))) && (read($Heap_$0,($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),i#0_$1 + 1)) : ref)))) )))) && (($Unbox(Seq#Index(read($Heap_$0,this_$0,Map.nodes),Seq#Length(read($Heap_$0,this_$0,Map.nodes)) - 1)) : ref) == null)))) )));
	assume (forall  $h0 : HeapType, $h1 : HeapType, this_$1 : ref :: {$HeapSucc($h0,$h1),Map.Valid($h1,this_$1)} ( ((((((($IsGoodHeap($h0) && $IsGoodHeap($h1)) && (!(this_$1 == null))) && read($h0,this_$1,alloc)) && (dtype(this_$1) == class.Map)) && read($h1,this_$1,alloc)) && (dtype(this_$1) == class.Map)) && $HeapSucc($h0,$h1)) ==> (((forall<alpha> $o_$4 : ref, $f : Field (alpha)  :: ( ((((!($o_$4 == null)) && read($h0,$o_$4,alloc)) && read($h1,$o_$4,alloc)) && (($o_$4 == this_$1) || read($h0,this_$1,Map.Repr)[$Box($o_$4)])) ==> (read($h0,$o_$4,$f) == read($h1,$o_$4,$f)) ))) ==> (Map.Valid($h0,this_$1) <==> Map.Valid($h1,this_$1))) ));
	assume (forall  $h_$4 : HeapType, $o_$5 : ref :: {read($h_$4,$o_$5,Node.key)} ( (($IsGoodHeap($h_$4) && (!($o_$5 == null))) && read($h_$4,$o_$5,alloc)) ==> GenericAlloc(read($h_$4,$o_$5,Node.key),$h_$4) ));
	assume (forall  $h_$5 : HeapType, $o_$6 : ref :: {read($h_$5,$o_$6,Node.val)} ( (($IsGoodHeap($h_$5) && (!($o_$6 == null))) && read($h_$5,$o_$6,alloc)) ==> GenericAlloc(read($h_$5,$o_$6,Node.val),$h_$5) ));
	assume (forall  $h_$6 : HeapType, $o_$7 : ref :: {read($h_$6,$o_$7,Node.next)} ( (($IsGoodHeap($h_$6) && (!($o_$7 == null))) && read($h_$6,$o_$7,alloc)) ==> ((read($h_$6,$o_$7,Node.next) == null) || (read($h_$6,read($h_$6,$o_$7,Node.next),alloc) && (dtype(read($h_$6,$o_$7,Node.next)) == class.Node))) ));
	assume (forall<alpha> $o_$8 : ref, $f_$0 : Field (alpha) , Map.Repr_$0 : Field (Set (BoxType) ) , null_$0 : ref, $Heap_$1 : HeapType, alloc_$0 : Field (Boolean) , this_$2 : ref :: {lambda#0(Map.Repr_$0,null_$0,$Heap_$1,alloc_$0,this_$2)[$o_$8,$f_$0]} ( lambda#0(Map.Repr_$0,null_$0,$Heap_$1,alloc_$0,this_$2)[$o_$8,$f_$0] <==> (((!($o_$8 == null_$0)) && read($Heap_$1,$o_$8,alloc_$0)) ==> (($o_$8 == this_$2) || read($Heap_$1,this_$2,Map.Repr_$0)[$Box($o_$8)])) ));
	assume (forall<alpha> $o_$9 : ref, $f_$1 : Field (alpha) , this_$3 : ref, null_$1 : ref, $Heap_$2 : HeapType, alloc_$1 : Field (Boolean)  :: {lambda#1(this_$3,null_$1,$Heap_$2,alloc_$1)[$o_$9,$f_$1]} ( lambda#1(this_$3,null_$1,$Heap_$2,alloc_$1)[$o_$9,$f_$1] <==> (((!($o_$9 == null_$1)) && read($Heap_$2,$o_$9,alloc_$1)) ==> ($o_$9 == this_$3)) ));
	assume (forall<alpha> $o_$10 : ref, $f_$2 : Field (alpha) , this_$4 : ref, null_$2 : ref, $Heap_$3 : HeapType, alloc_$2 : Field (Boolean)  :: {lambda#2(this_$4,null_$2,$Heap_$3,alloc_$2)[$o_$10,$f_$2]} ( lambda#2(this_$4,null_$2,$Heap_$3,alloc_$2)[$o_$10,$f_$2] <==> (((!($o_$10 == null_$2)) && read($Heap_$3,$o_$10,alloc_$2)) ==> ($o_$10 == this_$4)) ));
	assume (forall<alpha> $o_$11 : ref, $f_$3 : Field (alpha) , alloc_$3 : Field (Boolean) , null_$3 : ref, $Heap_$4 : HeapType :: {lambda#3(alloc_$3,null_$3,$Heap_$4)[$o_$11,$f_$3]} ( lambda#3(alloc_$3,null_$3,$Heap_$4)[$o_$11,$f_$3] <==> (((!($o_$11 == null_$3)) && read($Heap_$4,$o_$11,alloc_$3)) ==> false) ));
	assume (forall<alpha> $o_$12 : ref, $f_$4 : Field (alpha) , alloc_$4 : Field (Boolean) , null_$4 : ref, $Heap_$5 : HeapType :: {lambda#4(alloc_$4,null_$4,$Heap_$5)[$o_$12,$f_$4]} ( lambda#4(alloc_$4,null_$4,$Heap_$5)[$o_$12,$f_$4] <==> (((!($o_$12 == null_$4)) && read($Heap_$5,$o_$12,alloc_$4)) ==> false) ));
	assume (forall<alpha> $o_$13 : ref, $f_$5 : Field (alpha) , Map.Repr_$1 : Field (Set (BoxType) ) , null_$5 : ref, $Heap_$6 : HeapType, alloc_$5 : Field (Boolean) , this_$5 : ref :: {lambda#5(Map.Repr_$1,null_$5,$Heap_$6,alloc_$5,this_$5)[$o_$13,$f_$5]} ( lambda#5(Map.Repr_$1,null_$5,$Heap_$6,alloc_$5,this_$5)[$o_$13,$f_$5] <==> (((!($o_$13 == null_$5)) && read($Heap_$6,$o_$13,alloc_$5)) ==> read($Heap_$6,this_$5,Map.Repr_$1)[$Box($o_$13)]) ));
	assume (forall<alpha> $o_$14 : ref, $f_$6 : Field (alpha) , Map.Repr_$2 : Field (Set (BoxType) ) , null_$6 : ref, $Heap_$7 : HeapType, alloc_$6 : Field (Boolean) , this_$6 : ref :: {lambda#6(Map.Repr_$2,null_$6,$Heap_$7,alloc_$6,this_$6)[$o_$14,$f_$6]} ( lambda#6(Map.Repr_$2,null_$6,$Heap_$7,alloc_$6,this_$6)[$o_$14,$f_$6] <==> (((!($o_$14 == null_$6)) && read($Heap_$7,$o_$14,alloc_$6)) ==> read($Heap_$7,this_$6,Map.Repr_$2)[$Box($o_$14)]) ));
	assume (forall<alpha> $o_$15 : ref, $f_$7 : Field (alpha) , Map.Repr_$3 : Field (Set (BoxType) ) , null_$7 : ref, $Heap_$8 : HeapType, alloc_$7 : Field (Boolean) , this_$7 : ref :: {lambda#7(Map.Repr_$3,null_$7,$Heap_$8,alloc_$7,this_$7)[$o_$15,$f_$7]} ( lambda#7(Map.Repr_$3,null_$7,$Heap_$8,alloc_$7,this_$7)[$o_$15,$f_$7] <==> (((!($o_$15 == null_$7)) && read($Heap_$8,$o_$15,alloc_$7)) ==> read($Heap_$8,this_$7,Map.Repr_$3)[$Box($o_$15)]) ));
	assume (forall<alpha> $o_$16 : ref, $f_$8 : Field (alpha) , Map.Repr_$4 : Field (Set (BoxType) ) , null_$8 : ref, $Heap_$9 : HeapType, alloc_$8 : Field (Boolean) , this_$8 : ref :: {lambda#8(Map.Repr_$4,null_$8,$Heap_$9,alloc_$8,this_$8)[$o_$16,$f_$8]} ( lambda#8(Map.Repr_$4,null_$8,$Heap_$9,alloc_$8,this_$8)[$o_$16,$f_$8] <==> (((!($o_$16 == null_$8)) && read($Heap_$9,$o_$16,alloc_$8)) ==> read($Heap_$9,this_$8,Map.Repr_$4)[$Box($o_$16)]) ));
	assume (forall<alpha> $o_$17 : ref, $f_$9 : Field (alpha) , alloc_$9 : Field (Boolean) , null_$9 : ref, $Heap_$10 : HeapType :: {lambda#9(alloc_$9,null_$9,$Heap_$10)[$o_$17,$f_$9]} ( lambda#9(alloc_$9,null_$9,$Heap_$10)[$o_$17,$f_$9] <==> (((!($o_$17 == null_$9)) && read($Heap_$10,$o_$17,alloc_$9)) ==> false) ));
	assume (forall<alpha> $o_$18 : ref, $f_$10 : Field (alpha) , alloc_$10 : Field (Boolean) , null_$10 : ref, $Heap_$11 : HeapType :: {lambda#10(alloc_$10,null_$10,$Heap_$11)[$o_$18,$f_$10]} ( lambda#10(alloc_$10,null_$10,$Heap_$11)[$o_$18,$f_$10] <==> (((!($o_$18 == null_$10)) && read($Heap_$11,$o_$18,alloc_$10)) ==> false) ));
	goto PreconditionGeneratedEntry;
$exit:
	assume false;
PreconditionGeneratedEntry:
	assume $IsGoodHeap($Heap);
	assume ((!(this == null)) && read($Heap,this,alloc)) && (dtype(this) == class.Map);
	assume GenericAlloc(key#16,$Heap);
	assume (p#20 == null) || (read($Heap,p#20,alloc) && (dtype(p#20) == class.Node));
	assume (prev#22 == null) || (read($Heap,prev#22,alloc) && (dtype(prev#22) == class.Node));
	assume ($rhs#0 == null) || (read($Heap,$rhs#0,alloc) && (dtype($rhs#0) == class.Node));
	assume ($rhs#2 == null) || (read($Heap,$rhs#2,alloc) && (dtype($rhs#2) == class.Node));
	assume (0 == $ModuleContextHeight) && $InMethodContext;
	assume ((((((Map.Valid#canCall($Heap,this) && Map.Valid($Heap,this)) && read($Heap,this,Map.Repr)[$Box(this)]) && (Seq#Length(read($Heap,this,Map.Keys)) == Seq#Length(read($Heap,this,Map.Values)))) && (Seq#Length(read($Heap,this,Map.nodes)) == (Seq#Length(read($Heap,this,Map.Keys)) + 1))) && (read($Heap,this,Map.head) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),0)) : ref))) && ((forall  i#0_$2 : Integer :: ( true ==> (((0 <= i#0_$2) && (i#0_$2 < Seq#Length(read($Heap,this,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref) == null)) && read($Heap,this,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref))]) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref),Node.key) == Seq#Index(read($Heap,this,Map.Keys),i#0_$2))) && (!Seq#Contains(Seq#Drop(read($Heap,this,Map.Keys),i#0_$2 + 1),read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref),Node.key)))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref),Node.val) == Seq#Index(read($Heap,this,Map.Values),i#0_$2))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$2 + 1)) : ref)))) )))) && (($Unbox(Seq#Index(read($Heap,this,Map.nodes),Seq#Length(read($Heap,this,Map.nodes)) - 1)) : ref) == null);
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || read($Heap,this,Map.Repr)[$Box(this)]);
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length(read($Heap,this,Map.Keys)) == Seq#Length(read($Heap,this,Map.Values))));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length(read($Heap,this,Map.nodes)) == (Seq#Length(read($Heap,this,Map.Keys)) + 1)));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (read($Heap,this,Map.head) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),0)) : ref)));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ((forall  i#0_$3 : Integer :: ( true ==> (((0 <= i#0_$3) && (i#0_$3 < Seq#Length(read($Heap,this,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref) == null)) && read($Heap,this,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref))]) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref),Node.key) == Seq#Index(read($Heap,this,Map.Keys),i#0_$3))) && (!Seq#Contains(Seq#Drop(read($Heap,this,Map.Keys),i#0_$3 + 1),read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref),Node.key)))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref),Node.val) == Seq#Index(read($Heap,this,Map.Values),i#0_$3))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$3 + 1)) : ref)))) ))));
	assume Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (($Unbox(Seq#Index(read($Heap,this,Map.nodes),Seq#Length(read($Heap,this,Map.nodes)) - 1)) : ref) == null));
	goto anon0;
anon0:
	assume $_Frame_$_0 == lambda#8(Map.Repr,null,$Heap,alloc,this);
	assume true;
	assume true;
	assume true;
	assume true;
	assert  (forall<alpha> $o_$19 : ref, $f_$11 : Field (alpha)  :: ( false ==> $_Frame_$_0[$o_$19,$f_$11] ));
	assume (call4formal_$_p#24_$_0 == null) || (read($Heap,call4formal_$_p#24_$_0,alloc) && (dtype(call4formal_$_p#24_$_0) == class.Node));
	assume (call6formal_$_prev#26_$_0 == null) || (read($Heap,call6formal_$_prev#26_$_0,alloc) && (dtype(call6formal_$_prev#26_$_0) == class.Node));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || read($Heap,this,Map.Repr)[$Box(this)]);
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length(read($Heap,this,Map.Keys)) == Seq#Length(read($Heap,this,Map.Values))));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (Seq#Length(read($Heap,this,Map.nodes)) == (Seq#Length(read($Heap,this,Map.Keys)) + 1)));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (read($Heap,this,Map.head) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),0)) : ref)));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || ((forall  i#0_$4 : Integer :: ( true ==> (((0 <= i#0_$4) && (i#0_$4 < Seq#Length(read($Heap,this,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref) == null)) && read($Heap,this,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref))]) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref),Node.key) == Seq#Index(read($Heap,this,Map.Keys),i#0_$4))) && (!Seq#Contains(Seq#Drop(read($Heap,this,Map.Keys),i#0_$4 + 1),read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref),Node.key)))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref),Node.val) == Seq#Index(read($Heap,this,Map.Values),i#0_$4))) && (read($Heap,($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap,this,Map.nodes),i#0_$4 + 1)) : ref)))) ))));
	assert  Map.Valid#canCall($Heap,this) ==> (Map.Valid($Heap,this) || (($Unbox(Seq#Index(read($Heap,this,Map.nodes),Seq#Length(read($Heap,this,Map.nodes)) - 1)) : ref) == null));
	assume $IsGoodHeap($Heap_$_0);
	assume (call4formal_$_p#24_$_0 == null) || (read($Heap_$_0,call4formal_$_p#24_$_0,alloc) && (dtype(call4formal_$_p#24_$_0) == class.Node));
	assume (call6formal_$_prev#26_$_0 == null) || (read($Heap_$_0,call6formal_$_prev#26_$_0,alloc) && (dtype(call6formal_$_prev#26_$_0) == class.Node));
	assume (call4formal_$_p#24_$_0 == null) ==> (!Seq#Contains(read($Heap_$_0,this,Map.Keys),key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (0 <= call5formal_$_n#25_$_0);
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (call5formal_$_n#25_$_0 < Seq#Length(read($Heap_$_0,this,Map.Keys)));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (Seq#Index(read($Heap_$_0,this,Map.Keys),call5formal_$_n#25_$_0) == key#16);
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (!Seq#Contains(Seq#Take(read($Heap_$_0,this,Map.Keys),call5formal_$_n#25_$_0),key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (!Seq#Contains(Seq#Drop(read($Heap_$_0,this,Map.Keys),call5formal_$_n#25_$_0 + 1),key#16));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (call4formal_$_p#24_$_0 == ($Unbox(Seq#Index(read($Heap_$_0,this,Map.nodes),call5formal_$_n#25_$_0)) : ref));
	assume (!(call4formal_$_p#24_$_0 == null)) ==> (((call5formal_$_n#25_$_0 == 0) && (call6formal_$_prev#26_$_0 == null)) || ((0 < call5formal_$_n#25_$_0) && (call6formal_$_prev#26_$_0 == ($Unbox(Seq#Index(read($Heap_$_0,this,Map.nodes),call5formal_$_n#25_$_0 - 1)) : ref))));
	assume (forall<alpha> $o_$20 : ref, $f_$12 : Field (alpha)  :: {read($Heap_$_0,$o_$20,$f_$12)} ( ((!($o_$20 == null)) && read($Heap,$o_$20,alloc)) ==> (read($Heap_$_0,$o_$20,$f_$12) == read($Heap,$o_$20,$f_$12)) ));
	assume $HeapSucc($Heap,$Heap_$_0);
	assume true;
	assume true;
	if ($_$_condition) { goto anon5_Then; } else { goto anon5_Else; }
anon5_Then:
	assume !(call4formal_$_p#24_$_0 == null);
	assume true;
	assert  $_Frame_$_0[this,Map.Keys];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length(read($Heap_$_0,this,Map.Keys)));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length(read($Heap_$_0,this,Map.Keys)));
	assume true;
	assume $rhs#3_$_0 == Seq#Append(Seq#Take(read($Heap_$_0,this,Map.Keys),call5formal_$_n#25_$_0),Seq#Drop(read($Heap_$_0,this,Map.Keys),call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_1 == update($Heap_$_0,this,Map.Keys,$rhs#3_$_0);
	assume $IsGoodHeap($Heap_$_1);
	assume true;
	assert  $_Frame_$_0[this,Map.Values];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length(read($Heap_$_1,this,Map.Values)));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length(read($Heap_$_1,this,Map.Values)));
	assume true;
	assume $rhs#4_$_0 == Seq#Append(Seq#Take(read($Heap_$_1,this,Map.Values),call5formal_$_n#25_$_0),Seq#Drop(read($Heap_$_1,this,Map.Values),call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_2 == update($Heap_$_1,this,Map.Values,$rhs#4_$_0);
	assume $IsGoodHeap($Heap_$_2);
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length(read($Heap_$_2,this,Map.Keys)));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length(read($Heap,this,Map.Keys)));
	assume true;
	assert  Seq#Equal(Seq#Drop(read($Heap_$_2,this,Map.Keys),call5formal_$_n#25_$_0),Seq#Drop(read($Heap,this,Map.Keys),call5formal_$_n#25_$_0 + 1));
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length(read($Heap_$_2,this,Map.Values)));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length(read($Heap,this,Map.Values)));
	assume true;
	assert  Seq#Equal(Seq#Drop(read($Heap_$_2,this,Map.Values),call5formal_$_n#25_$_0),Seq#Drop(read($Heap,this,Map.Values),call5formal_$_n#25_$_0 + 1));
	assume true;
	assert  $_Frame_$_0[this,Map.nodes];
	assert  (0 <= call5formal_$_n#25_$_0) && (call5formal_$_n#25_$_0 <= Seq#Length(read($Heap_$_2,this,Map.nodes)));
	assert  (0 <= (call5formal_$_n#25_$_0 + 1)) && ((call5formal_$_n#25_$_0 + 1) <= Seq#Length(read($Heap_$_2,this,Map.nodes)));
	assume true;
	assume $rhs#5_$_0 == Seq#Append(Seq#Take(read($Heap_$_2,this,Map.nodes),call5formal_$_n#25_$_0),Seq#Drop(read($Heap_$_2,this,Map.nodes),call5formal_$_n#25_$_0 + 1));
	assume $Heap_$_3 == update($Heap_$_2,this,Map.nodes,$rhs#5_$_0);
	assume $IsGoodHeap($Heap_$_3);
	assume true;
	if ($_$_condition_$0) { goto anon6_Then; } else { goto anon6_Else; }
anon5_Else:
	assume call4formal_$_p#24_$_0 == null;
	assume $Heap_$_6 == $Heap_$_0;
	goto GeneratedUnifiedExit;
anon6_Then:
	assume call6formal_$_prev#26_$_0 == null;
	assume true;
	assert  $_Frame_$_0[this,Map.head];
	assert  !(read($Heap_$_3,this,Map.head) == null);
	assume true;
	assume $rhs#6_$_0 == read($Heap_$_3,read($Heap_$_3,this,Map.head),Node.next);
	assume $Heap_$_4 == update($Heap_$_3,this,Map.head,$rhs#6_$_0);
	assume $IsGoodHeap($Heap_$_4);
	assume $Heap_$_6 == $Heap_$_4;
	goto GeneratedUnifiedExit;
anon6_Else:
	assume !(call6formal_$_prev#26_$_0 == null);
	assert  !(call6formal_$_prev#26_$_0 == null);
	assume true;
	assert  $_Frame_$_0[call6formal_$_prev#26_$_0,Node.next];
	assert  !(call4formal_$_p#24_$_0 == null);
	assume true;
	assume $rhs#7_$_0 == read($Heap_$_3,call4formal_$_p#24_$_0,Node.next);
	assume $Heap_$_5 == update($Heap_$_3,call6formal_$_prev#26_$_0,Node.next,$rhs#7_$_0);
	assume $IsGoodHeap($Heap_$_5);
	assume $Heap_$_6 == $Heap_$_5;
	goto GeneratedUnifiedExit;
GeneratedUnifiedExit:
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || read($Heap_$_6,this,Map.Repr)[$Box(this)]);
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (Seq#Length(read($Heap_$_6,this,Map.Keys)) == Seq#Length(read($Heap_$_6,this,Map.Values))));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (Seq#Length(read($Heap_$_6,this,Map.nodes)) == (Seq#Length(read($Heap_$_6,this,Map.Keys)) + 1)));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (read($Heap_$_6,this,Map.head) == ($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),0)) : ref)));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || ((forall  i#0_$5 : Integer :: ( true ==> (((0 <= i#0_$5) && (i#0_$5 < Seq#Length(read($Heap_$_6,this,Map.Keys)))) ==> ((((((!(($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref) == null)) && read($Heap_$_6,this,Map.Repr)[$Box(($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref))]) && (read($Heap_$_6,($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref),Node.key) == Seq#Index(read($Heap_$_6,this,Map.Keys),i#0_$5))) && (!Seq#Contains(Seq#Drop(read($Heap_$_6,this,Map.Keys),i#0_$5 + 1),read($Heap_$_6,($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref),Node.key)))) && (read($Heap_$_6,($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref),Node.val) == Seq#Index(read($Heap_$_6,this,Map.Values),i#0_$5))) && (read($Heap_$_6,($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5)) : ref),Node.next) == ($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),i#0_$5 + 1)) : ref)))) ))));
	assert  Map.Valid#canCall($Heap_$_6,this) ==> (Map.Valid($Heap_$_6,this) || (($Unbox(Seq#Index(read($Heap_$_6,this,Map.nodes),Seq#Length(read($Heap_$_6,this,Map.nodes)) - 1)) : ref) == null));
	assert  (forall  $o_$21 : ref :: ( (((!($o_$21 == null)) && read($Heap_$_6,this,Map.Repr)[$Box($o_$21)]) && (!read($Heap,this,Map.Repr)[$Box($o_$21)])) ==> (!read($Heap,$o_$21,alloc)) ));
	assert  (forall  k#17 : BoxType :: ( GenericAlloc(k#17,$Heap_$_6) ==> (Seq#Contains(read($Heap_$_6,this,Map.Keys),k#17) ==> Seq#Contains(read($Heap,this,Map.Keys),k#17)) ));
	assert  (forall  k#18 : BoxType :: ( GenericAlloc(k#18,$Heap_$_6) ==> (Seq#Contains(read($Heap,this,Map.Keys),k#18) ==> (Seq#Contains(read($Heap_$_6,this,Map.Keys),k#18) || (k#18 == key#16))) ));
	assert  (!Seq#Contains(read($Heap,this,Map.Keys),key#16)) ==> Seq#Equal(read($Heap_$_6,this,Map.Keys),read($Heap,this,Map.Keys));
	assert  (!Seq#Contains(read($Heap,this,Map.Keys),key#16)) ==> Seq#Equal(read($Heap_$_6,this,Map.Values),read($Heap,this,Map.Values));
	assert  Seq#Contains(read($Heap,this,Map.Keys),key#16) ==> (Seq#Length(read($Heap_$_6,this,Map.Keys)) == (Seq#Length(read($Heap,this,Map.Keys)) - 1));
	assert  Seq#Contains(read($Heap,this,Map.Keys),key#16) ==> (!Seq#Contains(read($Heap_$_6,this,Map.Keys),key#16));
	assert  Seq#Contains(read($Heap,this,Map.Keys),key#16) ==> ((exists  h#19 : Integer :: ( (((((0 <= h#19) && (h#19 < Seq#Length(read($Heap,this,Map.Keys)))) && Seq#Equal(Seq#Take(read($Heap_$_6,this,Map.Keys),h#19),Seq#Take(read($Heap,this,Map.Keys),h#19))) && Seq#Equal(Seq#Take(read($Heap_$_6,this,Map.Values),h#19),Seq#Take(read($Heap,this,Map.Values),h#19))) && Seq#Equal(Seq#Drop(read($Heap_$_6,this,Map.Keys),h#19),Seq#Drop(read($Heap,this,Map.Keys),h#19 + 1))) && Seq#Equal(Seq#Drop(read($Heap_$_6,this,Map.Values),h#19),Seq#Drop(read($Heap,this,Map.Values),h#19 + 1)) )));
	goto $exit;
}
