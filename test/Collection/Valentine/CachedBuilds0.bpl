// Dafny program verifier version 1.7.0.00806, Copyright (c) 2003-2013, Microsoft.
// Command Line Options: /print:CachedBuilds0.bpl CachedBuilds0.dfy

const $$Language$Dafny: bool;

axiom $$Language$Dafny;

function {:identity} Lit<T>(x: T) : T;

axiom (forall<T> x: T :: {:identity} { Lit(x): T } Lit(x): T == x);

axiom (forall<T> x: T :: { $Box(Lit(x)) } $Box(Lit(x)) == Lit($Box(x)));

type ref;

const null: ref;

type Set T = [T]bool;

function Set#Card<T>(Set T) : int;

axiom (forall<T> s: Set T :: { Set#Card(s) } 0 <= Set#Card(s));

function Set#Empty<T>() : Set T;

axiom (forall<T> o: T :: { Set#Empty()[o] } !Set#Empty()[o]);

axiom (forall<T> s: Set T :: { Set#Card(s) } (Set#Card(s) == 0 <==> s == Set#Empty()) && (Set#Card(s) != 0 ==> (exists x: T :: s[x])));

function Set#Singleton<T>(T) : Set T;

axiom (forall<T> r: T :: { Set#Singleton(r) } Set#Singleton(r)[r]);

axiom (forall<T> r: T, o: T :: { Set#Singleton(r)[o] } Set#Singleton(r)[o] <==> r == o);

axiom (forall<T> r: T :: { Set#Card(Set#Singleton(r)) } Set#Card(Set#Singleton(r)) == 1);

function Set#UnionOne<T>(Set T, T) : Set T;

axiom (forall<T> a: Set T, x: T, o: T :: { Set#UnionOne(a, x)[o] } Set#UnionOne(a, x)[o] <==> o == x || a[o]);

axiom (forall<T> a: Set T, x: T :: { Set#UnionOne(a, x) } Set#UnionOne(a, x)[x]);

axiom (forall<T> a: Set T, x: T, y: T :: { Set#UnionOne(a, x), a[y] } a[y] ==> Set#UnionOne(a, x)[y]);

axiom (forall<T> a: Set T, x: T :: { Set#Card(Set#UnionOne(a, x)) } a[x] ==> Set#Card(Set#UnionOne(a, x)) == Set#Card(a));

axiom (forall<T> a: Set T, x: T :: { Set#Card(Set#UnionOne(a, x)) } !a[x] ==> Set#Card(Set#UnionOne(a, x)) == Set#Card(a) + 1);

function Set#Union<T>(Set T, Set T) : Set T;

axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Union(a, b)[o] } Set#Union(a, b)[o] <==> a[o] || b[o]);

axiom (forall<T> a: Set T, b: Set T, y: T :: { Set#Union(a, b), a[y] } a[y] ==> Set#Union(a, b)[y]);

axiom (forall<T> a: Set T, b: Set T, y: T :: { Set#Union(a, b), b[y] } b[y] ==> Set#Union(a, b)[y]);

axiom (forall<T> a: Set T, b: Set T :: { Set#Union(a, b) } Set#Disjoint(a, b) ==> Set#Difference(Set#Union(a, b), a) == b && Set#Difference(Set#Union(a, b), b) == a);

function Set#Intersection<T>(Set T, Set T) : Set T;

axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Intersection(a, b)[o] } Set#Intersection(a, b)[o] <==> a[o] && b[o]);

axiom (forall<T> a: Set T, b: Set T :: { Set#Union(Set#Union(a, b), b) } Set#Union(Set#Union(a, b), b) == Set#Union(a, b));

axiom (forall<T> a: Set T, b: Set T :: { Set#Union(a, Set#Union(a, b)) } Set#Union(a, Set#Union(a, b)) == Set#Union(a, b));

axiom (forall<T> a: Set T, b: Set T :: { Set#Intersection(Set#Intersection(a, b), b) } Set#Intersection(Set#Intersection(a, b), b) == Set#Intersection(a, b));

axiom (forall<T> a: Set T, b: Set T :: { Set#Intersection(a, Set#Intersection(a, b)) } Set#Intersection(a, Set#Intersection(a, b)) == Set#Intersection(a, b));

axiom (forall<T> a: Set T, b: Set T :: { Set#Card(Set#Union(a, b)) } { Set#Card(Set#Intersection(a, b)) } Set#Card(Set#Union(a, b)) + Set#Card(Set#Intersection(a, b)) == Set#Card(a) + Set#Card(b));

function Set#Difference<T>(Set T, Set T) : Set T;

axiom (forall<T> a: Set T, b: Set T, o: T :: { Set#Difference(a, b)[o] } Set#Difference(a, b)[o] <==> a[o] && !b[o]);

axiom (forall<T> a: Set T, b: Set T, y: T :: { Set#Difference(a, b), b[y] } b[y] ==> !Set#Difference(a, b)[y]);

axiom (forall<T> a: Set T, b: Set T :: { Set#Card(Set#Difference(a, b)) } Set#Card(Set#Difference(a, b)) + Set#Card(Set#Difference(b, a)) + Set#Card(Set#Intersection(a, b)) == Set#Card(Set#Union(a, b)) && Set#Card(Set#Difference(a, b)) == Set#Card(a) - Set#Card(Set#Intersection(a, b)));

function Set#Subset<T>(Set T, Set T) : bool;

axiom (forall<T> a: Set T, b: Set T :: { Set#Subset(a, b) } Set#Subset(a, b) <==> (forall o: T :: { a[o] } { b[o] } a[o] ==> b[o]));

function Set#Equal<T>(Set T, Set T) : bool;

axiom (forall<T> a: Set T, b: Set T :: { Set#Equal(a, b) } Set#Equal(a, b) <==> (forall o: T :: { a[o] } { b[o] } a[o] <==> b[o]));

axiom (forall<T> a: Set T, b: Set T :: { Set#Equal(a, b) } Set#Equal(a, b) ==> a == b);

function Set#Disjoint<T>(Set T, Set T) : bool;

axiom (forall<T> a: Set T, b: Set T :: { Set#Disjoint(a, b) } Set#Disjoint(a, b) <==> (forall o: T :: { a[o] } { b[o] } !a[o] || !b[o]));

function Math#min(a: int, b: int) : int;

axiom (forall a: int, b: int :: { Math#min(a, b) } a <= b <==> Math#min(a, b) == a);

axiom (forall a: int, b: int :: { Math#min(a, b) } b <= a <==> Math#min(a, b) == b);

axiom (forall a: int, b: int :: { Math#min(a, b) } Math#min(a, b) == a || Math#min(a, b) == b);

function Math#clip(a: int) : int;

axiom (forall a: int :: { Math#clip(a) } 0 <= a ==> Math#clip(a) == a);

axiom (forall a: int :: { Math#clip(a) } a < 0 ==> Math#clip(a) == 0);

type MultiSet T = [T]int;

function $IsGoodMultiSet<T>(ms: MultiSet T) : bool;

axiom (forall<T> ms: MultiSet T :: { $IsGoodMultiSet(ms) } $IsGoodMultiSet(ms) <==> (forall bx: T :: { ms[bx] } 0 <= ms[bx]));

function MultiSet#Card<T>(MultiSet T) : int;

axiom (forall<T> s: MultiSet T :: { MultiSet#Card(s) } 0 <= MultiSet#Card(s));

axiom (forall<T> s: MultiSet T, x: T, n: int :: { MultiSet#Card(s[x := n]) } 0 <= n ==> MultiSet#Card(s[x := n]) == MultiSet#Card(s) - s[x] + n);

function MultiSet#Empty<T>() : MultiSet T;

axiom (forall<T> o: T :: { MultiSet#Empty()[o] } MultiSet#Empty()[o] == 0);

axiom (forall<T> s: MultiSet T :: { MultiSet#Card(s) } (MultiSet#Card(s) == 0 <==> s == MultiSet#Empty()) && (MultiSet#Card(s) != 0 ==> (exists x: T :: 0 < s[x])));

function MultiSet#Singleton<T>(T) : MultiSet T;

axiom (forall<T> r: T, o: T :: { MultiSet#Singleton(r)[o] } (MultiSet#Singleton(r)[o] == 1 <==> r == o) && (MultiSet#Singleton(r)[o] == 0 <==> r != o));

axiom (forall<T> r: T :: { MultiSet#Singleton(r) } MultiSet#Singleton(r) == MultiSet#UnionOne(MultiSet#Empty(), r));

function MultiSet#UnionOne<T>(MultiSet T, T) : MultiSet T;

axiom (forall<T> a: MultiSet T, x: T, o: T :: { MultiSet#UnionOne(a, x)[o] } 0 < MultiSet#UnionOne(a, x)[o] <==> o == x || 0 < a[o]);

axiom (forall<T> a: MultiSet T, x: T :: { MultiSet#UnionOne(a, x) } MultiSet#UnionOne(a, x)[x] == a[x] + 1);

axiom (forall<T> a: MultiSet T, x: T, y: T :: { MultiSet#UnionOne(a, x), a[y] } 0 < a[y] ==> 0 < MultiSet#UnionOne(a, x)[y]);

axiom (forall<T> a: MultiSet T, x: T, y: T :: { MultiSet#UnionOne(a, x), a[y] } x != y ==> a[y] == MultiSet#UnionOne(a, x)[y]);

axiom (forall<T> a: MultiSet T, x: T :: { MultiSet#Card(MultiSet#UnionOne(a, x)) } MultiSet#Card(MultiSet#UnionOne(a, x)) == MultiSet#Card(a) + 1);

function MultiSet#Union<T>(MultiSet T, MultiSet T) : MultiSet T;

axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Union(a, b)[o] } MultiSet#Union(a, b)[o] == a[o] + b[o]);

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Card(MultiSet#Union(a, b)) } MultiSet#Card(MultiSet#Union(a, b)) == MultiSet#Card(a) + MultiSet#Card(b));

function MultiSet#Intersection<T>(MultiSet T, MultiSet T) : MultiSet T;

axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Intersection(a, b)[o] } MultiSet#Intersection(a, b)[o] == Math#min(a[o], b[o]));

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Intersection(MultiSet#Intersection(a, b), b) } MultiSet#Intersection(MultiSet#Intersection(a, b), b) == MultiSet#Intersection(a, b));

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Intersection(a, MultiSet#Intersection(a, b)) } MultiSet#Intersection(a, MultiSet#Intersection(a, b)) == MultiSet#Intersection(a, b));

function MultiSet#Difference<T>(MultiSet T, MultiSet T) : MultiSet T;

axiom (forall<T> a: MultiSet T, b: MultiSet T, o: T :: { MultiSet#Difference(a, b)[o] } MultiSet#Difference(a, b)[o] == Math#clip(a[o] - b[o]));

axiom (forall<T> a: MultiSet T, b: MultiSet T, y: T :: { MultiSet#Difference(a, b), b[y], a[y] } a[y] <= b[y] ==> MultiSet#Difference(a, b)[y] == 0);

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Card(MultiSet#Difference(a, b)) } MultiSet#Card(MultiSet#Difference(a, b)) + MultiSet#Card(MultiSet#Difference(b, a)) + 2 * MultiSet#Card(MultiSet#Intersection(a, b)) == MultiSet#Card(MultiSet#Union(a, b)) && MultiSet#Card(MultiSet#Difference(a, b)) == MultiSet#Card(a) - MultiSet#Card(MultiSet#Intersection(a, b)));

function MultiSet#Subset<T>(MultiSet T, MultiSet T) : bool;

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Subset(a, b) } MultiSet#Subset(a, b) <==> (forall o: T :: { a[o] } { b[o] } a[o] <= b[o]));

function MultiSet#Equal<T>(MultiSet T, MultiSet T) : bool;

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Equal(a, b) } MultiSet#Equal(a, b) <==> (forall o: T :: { a[o] } { b[o] } a[o] == b[o]));

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Equal(a, b) } MultiSet#Equal(a, b) ==> a == b);

function MultiSet#Disjoint<T>(MultiSet T, MultiSet T) : bool;

axiom (forall<T> a: MultiSet T, b: MultiSet T :: { MultiSet#Disjoint(a, b) } MultiSet#Disjoint(a, b) <==> (forall o: T :: { a[o] } { b[o] } a[o] == 0 || b[o] == 0));

function MultiSet#FromSet<T>(Set T) : MultiSet T;

axiom (forall<T> s: Set T, a: T :: { MultiSet#FromSet(s)[a] } (MultiSet#FromSet(s)[a] == 0 <==> !s[a]) && (MultiSet#FromSet(s)[a] == 1 <==> s[a]));

axiom (forall<T> s: Set T :: { MultiSet#Card(MultiSet#FromSet(s)) } MultiSet#Card(MultiSet#FromSet(s)) == Set#Card(s));

function MultiSet#FromSeq<T>(Seq T) : MultiSet T;

axiom (forall<T> s: Seq T :: { MultiSet#FromSeq(s) } $IsGoodMultiSet(MultiSet#FromSeq(s)));

axiom (forall<T> s: Seq T, v: T :: { MultiSet#FromSeq(Seq#Build(s, v)) } MultiSet#FromSeq(Seq#Build(s, v)) == MultiSet#UnionOne(MultiSet#FromSeq(s), v));

axiom (forall<T>  :: MultiSet#FromSeq(Seq#Empty(): Seq T) == MultiSet#Empty(): MultiSet T);

axiom (forall<T> a: Seq T, b: Seq T :: { MultiSet#FromSeq(Seq#Append(a, b)) } MultiSet#FromSeq(Seq#Append(a, b)) == MultiSet#Union(MultiSet#FromSeq(a), MultiSet#FromSeq(b)));

axiom (forall<T> s: Seq T, i: int, v: T, x: T :: { MultiSet#FromSeq(Seq#Update(s, i, v))[x] } 0 <= i && i < Seq#Length(s) ==> MultiSet#FromSeq(Seq#Update(s, i, v))[x] == MultiSet#Union(MultiSet#Difference(MultiSet#FromSeq(s), MultiSet#Singleton(Seq#Index(s, i))), MultiSet#Singleton(v))[x]);

axiom (forall<T> s: Seq T, x: T :: { MultiSet#FromSeq(s)[x] } (exists i: int :: { Seq#Index(s, i) } 0 <= i && i < Seq#Length(s) && x == Seq#Index(s, i)) <==> 0 < MultiSet#FromSeq(s)[x]);

type Seq _;

function Seq#Length<T>(Seq T) : int;

axiom (forall<T> s: Seq T :: { Seq#Length(s) } 0 <= Seq#Length(s));

function Seq#Empty<T>() : Seq T;

axiom (forall<T>  :: Seq#Length(Seq#Empty(): Seq T) == 0);

axiom (forall<T> s: Seq T :: { Seq#Length(s) } Seq#Length(s) == 0 ==> s == Seq#Empty());

function Seq#Singleton<T>(T) : Seq T;

axiom (forall<T> t: T :: { Seq#Length(Seq#Singleton(t)) } Seq#Length(Seq#Singleton(t)) == 1);

function Seq#Build<T>(s: Seq T, val: T) : Seq T;

axiom (forall<T> s: Seq T, v: T :: { Seq#Length(Seq#Build(s, v)) } Seq#Length(Seq#Build(s, v)) == 1 + Seq#Length(s));

axiom (forall<T> s: Seq T, i: int, v: T :: { Seq#Index(Seq#Build(s, v), i) } (i == Seq#Length(s) ==> Seq#Index(Seq#Build(s, v), i) == v) && (i != Seq#Length(s) ==> Seq#Index(Seq#Build(s, v), i) == Seq#Index(s, i)));

function Seq#Append<T>(Seq T, Seq T) : Seq T;

axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Length(Seq#Append(s0, s1)) } Seq#Length(Seq#Append(s0, s1)) == Seq#Length(s0) + Seq#Length(s1));

function Seq#Index<T>(Seq T, int) : T;

axiom (forall<T> t: T :: { Seq#Index(Seq#Singleton(t), 0) } Seq#Index(Seq#Singleton(t), 0) == t);

axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#Index(Seq#Append(s0, s1), n) } (n < Seq#Length(s0) ==> Seq#Index(Seq#Append(s0, s1), n) == Seq#Index(s0, n)) && (Seq#Length(s0) <= n ==> Seq#Index(Seq#Append(s0, s1), n) == Seq#Index(s1, n - Seq#Length(s0))));

function Seq#Update<T>(Seq T, int, T) : Seq T;

axiom (forall<T> s: Seq T, i: int, v: T :: { Seq#Length(Seq#Update(s, i, v)) } 0 <= i && i < Seq#Length(s) ==> Seq#Length(Seq#Update(s, i, v)) == Seq#Length(s));

axiom (forall<T> s: Seq T, i: int, v: T, n: int :: { Seq#Index(Seq#Update(s, i, v), n) } 0 <= n && n < Seq#Length(s) ==> (i == n ==> Seq#Index(Seq#Update(s, i, v), n) == v) && (i != n ==> Seq#Index(Seq#Update(s, i, v), n) == Seq#Index(s, n)));

function Seq#Contains<T>(Seq T, T) : bool;

axiom (forall<T> s: Seq T, x: T :: { Seq#Contains(s, x) } Seq#Contains(s, x) <==> (exists i: int :: { Seq#Index(s, i) } 0 <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

axiom (forall x: ref :: { Seq#Contains(Seq#Empty(), x) } !Seq#Contains(Seq#Empty(), x));

axiom (forall<T> s0: Seq T, s1: Seq T, x: T :: { Seq#Contains(Seq#Append(s0, s1), x) } Seq#Contains(Seq#Append(s0, s1), x) <==> Seq#Contains(s0, x) || Seq#Contains(s1, x));

axiom (forall<T> s: Seq T, v: T, x: T :: { Seq#Contains(Seq#Build(s, v), x) } Seq#Contains(Seq#Build(s, v), x) <==> v == x || Seq#Contains(s, x));

axiom (forall<T> s: Seq T, n: int, x: T :: { Seq#Contains(Seq#Take(s, n), x) } Seq#Contains(Seq#Take(s, n), x) <==> (exists i: int :: { Seq#Index(s, i) } 0 <= i && i < n && i < Seq#Length(s) && Seq#Index(s, i) == x));

axiom (forall<T> s: Seq T, n: int, x: T :: { Seq#Contains(Seq#Drop(s, n), x) } Seq#Contains(Seq#Drop(s, n), x) <==> (exists i: int :: { Seq#Index(s, i) } 0 <= n && n <= i && i < Seq#Length(s) && Seq#Index(s, i) == x));

function Seq#Equal<T>(Seq T, Seq T) : bool;

axiom (forall<T> s0: Seq T, s1: Seq T :: { Seq#Equal(s0, s1) } Seq#Equal(s0, s1) <==> Seq#Length(s0) == Seq#Length(s1) && (forall j: int :: { Seq#Index(s0, j) } { Seq#Index(s1, j) } 0 <= j && j < Seq#Length(s0) ==> Seq#Index(s0, j) == Seq#Index(s1, j)));

axiom (forall<T> a: Seq T, b: Seq T :: { Seq#Equal(a, b) } Seq#Equal(a, b) ==> a == b);

function Seq#SameUntil<T>(Seq T, Seq T, int) : bool;

axiom (forall<T> s0: Seq T, s1: Seq T, n: int :: { Seq#SameUntil(s0, s1, n) } Seq#SameUntil(s0, s1, n) <==> (forall j: int :: { Seq#Index(s0, j) } { Seq#Index(s1, j) } 0 <= j && j < n ==> Seq#Index(s0, j) == Seq#Index(s1, j)));

function Seq#Take<T>(s: Seq T, howMany: int) : Seq T;

axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Take(s, n)) } 0 <= n ==> (n <= Seq#Length(s) ==> Seq#Length(Seq#Take(s, n)) == n) && (Seq#Length(s) < n ==> Seq#Length(Seq#Take(s, n)) == Seq#Length(s)));

axiom (forall<T> s: Seq T, n: int, j: int :: {:weight 25} { Seq#Index(Seq#Take(s, n), j) } 0 <= j && j < n && j < Seq#Length(s) ==> Seq#Index(Seq#Take(s, n), j) == Seq#Index(s, j));

function Seq#Drop<T>(s: Seq T, howMany: int) : Seq T;

axiom (forall<T> s: Seq T, n: int :: { Seq#Length(Seq#Drop(s, n)) } 0 <= n ==> (n <= Seq#Length(s) ==> Seq#Length(Seq#Drop(s, n)) == Seq#Length(s) - n) && (Seq#Length(s) < n ==> Seq#Length(Seq#Drop(s, n)) == 0));

axiom (forall<T> s: Seq T, n: int, j: int :: {:weight 25} { Seq#Index(Seq#Drop(s, n), j) } 0 <= n && 0 <= j && j < Seq#Length(s) - n ==> Seq#Index(Seq#Drop(s, n), j) == Seq#Index(s, j + n));

axiom (forall<T> s: Seq T, t: Seq T :: { Seq#Append(s, t) } Seq#Take(Seq#Append(s, t), Seq#Length(s)) == s && Seq#Drop(Seq#Append(s, t), Seq#Length(s)) == t);

function Seq#FromArray(h: HeapType, a: ref) : Seq BoxType;

axiom (forall h: HeapType, a: ref :: { Seq#Length(Seq#FromArray(h, a)) } Seq#Length(Seq#FromArray(h, a)) == _System.array.Length(a));

axiom (forall h: HeapType, a: ref :: { Seq#FromArray(h, a): Seq BoxType } (forall i: int :: 0 <= i && i < Seq#Length(Seq#FromArray(h, a)) ==> Seq#Index(Seq#FromArray(h, a), i) == read(h, a, IndexField(i))));

axiom (forall<alpha> h: HeapType, o: ref, f: Field alpha, v: alpha, a: ref :: { Seq#FromArray(update(h, o, f, v), a) } o != a ==> Seq#FromArray(update(h, o, f, v), a) == Seq#FromArray(h, a));

axiom (forall h: HeapType, i: int, v: BoxType, a: ref :: { Seq#FromArray(update(h, a, IndexField(i), v), a) } 0 <= i && i < _System.array.Length(a) ==> Seq#FromArray(update(h, a, IndexField(i), v), a) == Seq#Update(Seq#FromArray(h, a), i, v));

axiom (forall<T> s: Seq T, i: int, v: T, n: int :: { Seq#Take(Seq#Update(s, i, v), n) } 0 <= i && i < n && n <= Seq#Length(s) ==> Seq#Take(Seq#Update(s, i, v), n) == Seq#Update(Seq#Take(s, n), i, v));

axiom (forall<T> s: Seq T, i: int, v: T, n: int :: { Seq#Take(Seq#Update(s, i, v), n) } n <= i && i < Seq#Length(s) ==> Seq#Take(Seq#Update(s, i, v), n) == Seq#Take(s, n));

axiom (forall<T> s: Seq T, i: int, v: T, n: int :: { Seq#Drop(Seq#Update(s, i, v), n) } 0 <= n && n <= i && i < Seq#Length(s) ==> Seq#Drop(Seq#Update(s, i, v), n) == Seq#Update(Seq#Drop(s, n), i - n, v));

axiom (forall<T> s: Seq T, i: int, v: T, n: int :: { Seq#Drop(Seq#Update(s, i, v), n) } 0 <= i && i < n && n < Seq#Length(s) ==> Seq#Drop(Seq#Update(s, i, v), n) == Seq#Drop(s, n));

axiom (forall h: HeapType, a: ref, n0: int, n1: int :: { Seq#Take(Seq#FromArray(h, a), n0), Seq#Take(Seq#FromArray(h, a), n1) } n0 + 1 == n1 && 0 <= n0 && n1 <= _System.array.Length(a) ==> Seq#Take(Seq#FromArray(h, a), n1) == Seq#Build(Seq#Take(Seq#FromArray(h, a), n0), read(h, a, IndexField(n0): Field BoxType)));

axiom (forall<T> s: Seq T, v: T, n: int :: { Seq#Drop(Seq#Build(s, v), n) } 0 <= n && n <= Seq#Length(s) ==> Seq#Drop(Seq#Build(s, v), n) == Seq#Build(Seq#Drop(s, n), v));

function Seq#Rank<T>(Seq T) : int;

axiom (forall s: Seq BoxType, i: int :: { DtRank($Unbox(Seq#Index(s, i)): DatatypeType) } 0 <= i && i < Seq#Length(s) ==> DtRank($Unbox(Seq#Index(s, i)): DatatypeType) < Seq#Rank(s));

axiom (forall<T> s: Seq T, i: int :: { Seq#Rank(Seq#Drop(s, i)) } 0 < i && i <= Seq#Length(s) ==> Seq#Rank(Seq#Drop(s, i)) < Seq#Rank(s));

axiom (forall<T> s: Seq T, i: int :: { Seq#Rank(Seq#Take(s, i)) } 0 <= i && i < Seq#Length(s) ==> Seq#Rank(Seq#Take(s, i)) < Seq#Rank(s));

axiom (forall<T> s: Seq T, i: int, j: int :: { Seq#Rank(Seq#Append(Seq#Take(s, i), Seq#Drop(s, j))) } 0 <= i && i < j && j <= Seq#Length(s) ==> Seq#Rank(Seq#Append(Seq#Take(s, i), Seq#Drop(s, j))) < Seq#Rank(s));

axiom Seq#Take(Seq#Empty(): Seq BoxType, 0) == Seq#Empty();

axiom Seq#Drop(Seq#Empty(): Seq BoxType, 0) == Seq#Empty();

type Map _ _;

function Map#Domain<U,V>(Map U V) : [U]bool;

function Map#Elements<U,V>(Map U V) : [U]V;

function Map#Card<U,V>(Map U V) : int;

axiom (forall<U,V> m: Map U V :: { Map#Card(m) } 0 <= Map#Card(m));

function Map#Empty<U,V>() : Map U V;

axiom (forall<U,V> u: U :: { Map#Domain(Map#Empty(): Map U V)[u] } !Map#Domain(Map#Empty(): Map U V)[u]);

axiom (forall<U,V> m: Map U V :: { Map#Card(m) } Map#Card(m) == 0 <==> m == Map#Empty());

function Map#Glue<U,V>([U]bool, [U]V) : Map U V;

axiom (forall<U,V> a: [U]bool, b: [U]V :: { Map#Domain(Map#Glue(a, b)) } Map#Domain(Map#Glue(a, b)) == a);

axiom (forall<U,V> a: [U]bool, b: [U]V :: { Map#Elements(Map#Glue(a, b)) } Map#Elements(Map#Glue(a, b)) == b);

function Map#Build<U,V>(Map U V, U, V) : Map U V;

axiom (forall<U,V> m: Map U V, u: U, u': U, v: V :: { Map#Domain(Map#Build(m, u, v))[u'] } { Map#Elements(Map#Build(m, u, v))[u'] } (u' == u ==> Map#Domain(Map#Build(m, u, v))[u'] && Map#Elements(Map#Build(m, u, v))[u'] == v) && (u' != u ==> Map#Domain(Map#Build(m, u, v))[u'] == Map#Domain(m)[u'] && Map#Elements(Map#Build(m, u, v))[u'] == Map#Elements(m)[u']));

axiom (forall<U,V> m: Map U V, u: U, v: V :: { Map#Card(Map#Build(m, u, v)) } Map#Domain(m)[u] ==> Map#Card(Map#Build(m, u, v)) == Map#Card(m));

axiom (forall<U,V> m: Map U V, u: U, v: V :: { Map#Card(Map#Build(m, u, v)) } !Map#Domain(m)[u] ==> Map#Card(Map#Build(m, u, v)) == Map#Card(m) + 1);

function Map#Equal<U,V>(Map U V, Map U V) : bool;

axiom (forall<U,V> m: Map U V, m': Map U V :: { Map#Equal(m, m') } Map#Equal(m, m') <==> (forall u: U :: Map#Domain(m)[u] == Map#Domain(m')[u]) && (forall u: U :: Map#Domain(m)[u] ==> Map#Elements(m)[u] == Map#Elements(m')[u]));

axiom (forall<U,V> m: Map U V, m': Map U V :: { Map#Equal(m, m') } Map#Equal(m, m') ==> m == m');

function Map#Disjoint<U,V>(Map U V, Map U V) : bool;

axiom (forall<U,V> m: Map U V, m': Map U V :: { Map#Disjoint(m, m') } Map#Disjoint(m, m') <==> (forall o: U :: { Map#Domain(m)[o] } { Map#Domain(m')[o] } !Map#Domain(m)[o] || !Map#Domain(m')[o]));

type BoxType;

function $Box<T>(T) : BoxType;

function $Unbox<T>(BoxType) : T;

axiom (forall<T> x: T :: { $Box(x) } $Unbox($Box(x)) == x);

axiom (forall b: BoxType :: { $Unbox(b): int } $Box($Unbox(b): int) == b);

axiom (forall b: BoxType :: { $Unbox(b): ref } $Box($Unbox(b): ref) == b);

axiom (forall b: BoxType :: { $Unbox(b): Set BoxType } $Box($Unbox(b): Set BoxType) == b);

axiom (forall b: BoxType :: { $Unbox(b): Seq BoxType } $Box($Unbox(b): Seq BoxType) == b);

axiom (forall b: BoxType :: { $Unbox(b): Map BoxType BoxType } $Box($Unbox(b): Map BoxType BoxType) == b);

axiom (forall b: BoxType :: { $Unbox(b): DatatypeType } $Box($Unbox(b): DatatypeType) == b);

function $IsCanonicalBoolBox(BoxType) : bool;

axiom $IsCanonicalBoolBox($Box(false)) && $IsCanonicalBoolBox($Box(true));

axiom (forall b: BoxType :: { $Unbox(b): bool } $IsCanonicalBoolBox(b) ==> $Box($Unbox(b): bool) == b);

function $IsGoodSet_Extended<T>(s: Set BoxType, dummy: T) : bool;

axiom (forall<T> ss: Set BoxType, dummy: T, bx: BoxType :: { $IsGoodSet_Extended(ss, dummy), ss[bx] } $IsGoodSet_Extended(ss, dummy) ==> ss[bx] ==> bx == $Box($Unbox(bx): T));

function $IsGoodMultiSet_Extended<T>(ms: MultiSet BoxType, dummy: T) : bool;

axiom (forall<T> ms: MultiSet BoxType, dummy: T, bx: BoxType :: { $IsGoodMultiSet_Extended(ms, dummy), ms[bx] } $IsGoodMultiSet_Extended(ms, dummy) ==> 0 < ms[bx] ==> bx == $Box($Unbox(bx): T));

type ClassName;

const unique class._System.int: ClassName;

const unique class._System.bool: ClassName;

const unique class._System.set: ClassName;

const unique class._System.seq: ClassName;

const unique class._System.multiset: ClassName;

const unique class._System.array: ClassName;

function dtype(ref) : ClassName;

function TypeParams(ref, int) : ClassName;

function TypeTuple(a: ClassName, b: ClassName) : ClassName;

function TypeTupleCar(ClassName) : ClassName;

function TypeTupleCdr(ClassName) : ClassName;

axiom (forall a: ClassName, b: ClassName :: { TypeTuple(a, b) } TypeTupleCar(TypeTuple(a, b)) == a && TypeTupleCdr(TypeTuple(a, b)) == b);

type DatatypeType;

function DtType(DatatypeType) : ClassName;

function DtTypeParams(DatatypeType, int) : ClassName;

type DtCtorId;

function DatatypeCtorId(DatatypeType) : DtCtorId;

function DtRank(DatatypeType) : int;

const $ModuleContextHeight: int;

const $FunctionContextHeight: int;

type LayerType;

const $LZ: LayerType;

function $LS(LayerType) : LayerType;

type Field _;

function FDim<T>(Field T) : int;

function IndexField(int) : Field BoxType;

axiom (forall i: int :: { IndexField(i) } FDim(IndexField(i)) == 1);

function IndexField_Inverse<T>(Field T) : int;

axiom (forall i: int :: { IndexField(i) } IndexField_Inverse(IndexField(i)) == i);

function MultiIndexField(Field BoxType, int) : Field BoxType;

axiom (forall f: Field BoxType, i: int :: { MultiIndexField(f, i) } FDim(MultiIndexField(f, i)) == FDim(f) + 1);

function MultiIndexField_Inverse0<T>(Field T) : Field T;

function MultiIndexField_Inverse1<T>(Field T) : int;

axiom (forall f: Field BoxType, i: int :: { MultiIndexField(f, i) } MultiIndexField_Inverse0(MultiIndexField(f, i)) == f && MultiIndexField_Inverse1(MultiIndexField(f, i)) == i);

function DeclType<T>(Field T) : ClassName;

type NameFamily;

function DeclName<T>(Field T) : NameFamily;

function FieldOfDecl<alpha>(ClassName, NameFamily) : Field alpha;

axiom (forall<T> cl: ClassName, nm: NameFamily :: { FieldOfDecl(cl, nm): Field T } DeclType(FieldOfDecl(cl, nm): Field T) == cl && DeclName(FieldOfDecl(cl, nm): Field T) == nm);

function $IsGhostField<T>(Field T) : bool;

const unique alloc: Field bool;

axiom FDim(alloc) == 0 && !$IsGhostField(alloc);

function DtAlloc(DatatypeType, HeapType) : bool;

axiom (forall h: HeapType, k: HeapType, d: DatatypeType :: { $HeapSucc(h, k), DtAlloc(d, h) } { $HeapSucc(h, k), DtAlloc(d, k) } $HeapSucc(h, k) ==> DtAlloc(d, h) ==> DtAlloc(d, k));

function GenericAlloc(BoxType, HeapType) : bool;

axiom (forall h: HeapType, k: HeapType, d: BoxType :: { $HeapSucc(h, k), GenericAlloc(d, h) } { $HeapSucc(h, k), GenericAlloc(d, k) } $HeapSucc(h, k) ==> GenericAlloc(d, h) ==> GenericAlloc(d, k));

axiom (forall b: BoxType, h: HeapType :: { GenericAlloc(b, h), h[$Unbox(b): ref, alloc] } GenericAlloc(b, h) ==> $Unbox(b): ref == null || h[$Unbox(b): ref, alloc]);

axiom (forall b: BoxType, h: HeapType, i: int :: { GenericAlloc(b, h), Seq#Index($Unbox(b): Seq BoxType, i) } GenericAlloc(b, h) && 0 <= i && i < Seq#Length($Unbox(b): Seq BoxType) ==> GenericAlloc(Seq#Index($Unbox(b): Seq BoxType, i), h));

axiom (forall b: BoxType, h: HeapType, i: BoxType :: { GenericAlloc(b, h), Map#Domain($Unbox(b): Map BoxType BoxType)[i] } GenericAlloc(b, h) && Map#Domain($Unbox(b): Map BoxType BoxType)[i] ==> GenericAlloc(Map#Elements($Unbox(b): Map BoxType BoxType)[i], h));

axiom (forall b: BoxType, h: HeapType, t: BoxType :: { GenericAlloc(b, h), Map#Domain($Unbox(b): Map BoxType BoxType)[t] } GenericAlloc(b, h) && Map#Domain($Unbox(b): Map BoxType BoxType)[t] ==> GenericAlloc(t, h));

axiom (forall b: BoxType, h: HeapType, t: BoxType :: { GenericAlloc(b, h), ($Unbox(b): Set BoxType)[t] } GenericAlloc(b, h) && ($Unbox(b): Set BoxType)[t] ==> GenericAlloc(t, h));

axiom (forall b: BoxType, h: HeapType :: { GenericAlloc(b, h), DtType($Unbox(b): DatatypeType) } GenericAlloc(b, h) ==> DtAlloc($Unbox(b): DatatypeType, h));

axiom (forall b: bool, h: HeapType :: $IsGoodHeap(h) ==> GenericAlloc($Box(b), h));

axiom (forall x: int, h: HeapType :: $IsGoodHeap(h) ==> GenericAlloc($Box(x), h));

axiom (forall r: ref, h: HeapType :: { GenericAlloc($Box(r), h) } $IsGoodHeap(h) && (r == null || h[r, alloc]) ==> GenericAlloc($Box(r), h));

axiom (forall r: ref, f: Field BoxType, h: HeapType :: { GenericAlloc(read(h, r, f), h) } $IsGoodHeap(h) && r != null && read(h, r, alloc) ==> GenericAlloc(read(h, r, f), h));

function _System.array.Length(a: ref) : int;

axiom (forall o: ref :: 0 <= _System.array.Length(o));

type HeapType = <alpha>[ref,Field alpha]alpha;

function {:inline true} read<alpha>(H: HeapType, r: ref, f: Field alpha) : alpha
{
  H[r, f]
}

function {:inline true} update<alpha>(H: HeapType, r: ref, f: Field alpha, v: alpha) : HeapType
{
  H[r, f := v]
}

function $IsGoodHeap(HeapType) : bool;

var $Heap: HeapType where $IsGoodHeap($Heap);

function $HeapSucc(HeapType, HeapType) : bool;

axiom (forall<alpha> h: HeapType, r: ref, f: Field alpha, x: alpha :: { update(h, r, f, x) } $IsGoodHeap(update(h, r, f, x)) ==> $HeapSucc(h, update(h, r, f, x)));

axiom (forall a: HeapType, b: HeapType, c: HeapType :: { $HeapSucc(a, b), $HeapSucc(b, c) } $HeapSucc(a, b) && $HeapSucc(b, c) ==> $HeapSucc(a, c));

axiom (forall h: HeapType, k: HeapType :: { $HeapSucc(h, k) } $HeapSucc(h, k) ==> (forall o: ref :: { read(k, o, alloc) } read(h, o, alloc) ==> read(k, o, alloc)));

function $HeapSuccGhost(HeapType, HeapType) : bool;

axiom (forall h: HeapType, k: HeapType :: { $HeapSuccGhost(h, k) } $HeapSuccGhost(h, k) ==> $HeapSucc(h, k) && (forall<alpha> o: ref, f: Field alpha :: { read(k, o, f) } !$IsGhostField(f) ==> read(h, o, f) == read(k, o, f)));

type TickType;

var $Tick: TickType;

procedure $YieldHavoc(this: ref, rds: Set BoxType, nw: Set BoxType);
  modifies $Heap;
  ensures (forall<alpha> $o: ref, $f: Field alpha :: { read($Heap, $o, $f) } $o != null && read(old($Heap), $o, alloc) ==> $o == this || rds[$Box($o)] || nw[$Box($o)] ==> read($Heap, $o, $f) == read(old($Heap), $o, $f));
  ensures $HeapSucc(old($Heap), $Heap);



procedure $IterHavoc0(this: ref, rds: Set BoxType, modi: Set BoxType);
  modifies $Heap;
  ensures (forall<alpha> $o: ref, $f: Field alpha :: { read($Heap, $o, $f) } $o != null && read(old($Heap), $o, alloc) ==> rds[$Box($o)] && !modi[$Box($o)] && $o != this ==> read($Heap, $o, $f) == read(old($Heap), $o, $f));
  ensures $HeapSucc(old($Heap), $Heap);



procedure $IterHavoc1(this: ref, modi: Set BoxType, nw: Set BoxType);
  modifies $Heap;
  ensures (forall<alpha> $o: ref, $f: Field alpha :: { read($Heap, $o, $f) } $o != null && read(old($Heap), $o, alloc) ==> read($Heap, $o, $f) == read(old($Heap), $o, $f) || $o == this || modi[$Box($o)] || nw[$Box($o)]);
  ensures $HeapSucc(old($Heap), $Heap);



procedure $IterCollectNewObjects(prevHeap: HeapType, newHeap: HeapType, this: ref, NW: Field (Set BoxType)) returns (s: Set BoxType);
  ensures (forall bx: BoxType :: { s[bx] } s[bx] <==> read(newHeap, this, NW)[bx] || ($Unbox(bx) != null && !read(prevHeap, $Unbox(bx): ref, alloc) && read(newHeap, $Unbox(bx): ref, alloc)));



const unique class._System.object: ClassName;

const unique class._module.StateC: ClassName;

function #_module.StateC.S(BoxType, BoxType) : DatatypeType;

axiom (forall a0#0: BoxType, a1#1: BoxType :: DtType(#_module.StateC.S(a0#0, a1#1)) == class._module.StateC);

const unique ##_module.StateC.S: DtCtorId;

axiom (forall a0#2: BoxType, a1#3: BoxType :: DatatypeCtorId(#_module.StateC.S(a0#2, a1#3)) == ##_module.StateC.S);

axiom (forall d: DatatypeType :: _module.StateC.S_q(d) ==> (exists a0#4: BoxType, a1#5: BoxType :: d == #_module.StateC.S(a0#4, a1#5)));

function _module.StateC.S_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.StateC.S_q(this) } _module.StateC.S_q(this) <==> DatatypeCtorId(this) == ##_module.StateC.S);

axiom (forall a0#6: BoxType, a1#7: BoxType, $h: HeapType :: { DtAlloc(#_module.StateC.S(a0#6, a1#7), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.StateC.S(a0#6, a1#7), $h) <==> GenericAlloc(a0#6, $h) && GenericAlloc(a1#7, $h)));

axiom (forall a0#8: BoxType, a1#9: BoxType :: { #_module.StateC.S(Lit(a0#8), Lit(a1#9)) } #_module.StateC.S(Lit(a0#8), Lit(a1#9)) == Lit(#_module.StateC.S(a0#8, a1#9)));

function _module.StateC.st(this: DatatypeType) : BoxType;

axiom (forall a0#10: BoxType, a1#11: BoxType :: _module.StateC.st(#_module.StateC.S(a0#10, a1#11)) == a0#10);

axiom (forall a0#12: BoxType, a1#13: BoxType :: DtRank($Unbox(a0#12): DatatypeType) < DtRank(#_module.StateC.S(a0#12, a1#13)));

function _module.StateC.c(this: DatatypeType) : BoxType;

axiom (forall a0#14: BoxType, a1#15: BoxType :: _module.StateC.c(#_module.StateC.S(a0#14, a1#15)) == a1#15);

axiom (forall a0#16: BoxType, a1#17: BoxType :: DtRank($Unbox(a1#17): DatatypeType) < DtRank(#_module.StateC.S(a0#16, a1#17)));

function $IsA#_module.StateC(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.StateC(d) } $IsA#_module.StateC(d) <==> _module.StateC.S_q(d));

axiom (forall d: DatatypeType :: { _module.StateC.S_q(d) } DtType(d) == class._module.StateC ==> _module.StateC.S_q(d));

const unique class._module.Program: ClassName;

function #_module.Program.Program(Seq BoxType) : DatatypeType;

axiom (forall a0#18: Seq BoxType :: DtType(#_module.Program.Program(a0#18)) == class._module.Program);

const unique ##_module.Program.Program: DtCtorId;

axiom (forall a0#19: Seq BoxType :: DatatypeCtorId(#_module.Program.Program(a0#19)) == ##_module.Program.Program);

axiom (forall d: DatatypeType :: _module.Program.Program_q(d) ==> (exists a0#20: Seq BoxType :: d == #_module.Program.Program(a0#20)));

function _module.Program.Program_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Program.Program_q(this) } _module.Program.Program_q(this) <==> DatatypeCtorId(this) == ##_module.Program.Program);

axiom (forall a0#21: Seq BoxType, $h: HeapType :: { DtAlloc(#_module.Program.Program(a0#21), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Program.Program(a0#21), $h) <==> (forall $i#22: int :: { Seq#Index(a0#21, $i#22) } 0 <= $i#22 && $i#22 < Seq#Length(a0#21) ==> DtAlloc($Unbox(Seq#Index(a0#21, $i#22)): DatatypeType, $h) && DtType($Unbox(Seq#Index(a0#21, $i#22)): DatatypeType) == class._module.Statement)));

axiom (forall a0#23: Seq BoxType :: { #_module.Program.Program(Lit(a0#23)) } #_module.Program.Program(Lit(a0#23)) == Lit(#_module.Program.Program(a0#23)));

function _module.Program.stmts(this: DatatypeType) : Seq BoxType;

axiom (forall a0#24: Seq BoxType :: _module.Program.stmts(#_module.Program.Program(a0#24)) == a0#24);

axiom (forall a0#25: Seq BoxType, i: int :: 0 <= i && i < Seq#Length(a0#25) ==> DtRank($Unbox(Seq#Index(a0#25, i)): DatatypeType) < DtRank(#_module.Program.Program(a0#25)));

axiom (forall a0#26: Seq BoxType :: Seq#Rank(a0#26) < DtRank(#_module.Program.Program(a0#26)));

function $IsA#_module.Program(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Program(d) } $IsA#_module.Program(d) <==> _module.Program.Program_q(d));

axiom (forall d: DatatypeType :: { _module.Program.Program_q(d) } DtType(d) == class._module.Program ==> _module.Program.Program_q(d));

const unique class._module.Statement: ClassName;

function #_module.Statement.stmtVariable(BoxType, DatatypeType) : DatatypeType;

axiom (forall a0#27: BoxType, a1#28: DatatypeType :: DtType(#_module.Statement.stmtVariable(a0#27, a1#28)) == class._module.Statement);

const unique ##_module.Statement.stmtVariable: DtCtorId;

axiom (forall a0#29: BoxType, a1#30: DatatypeType :: DatatypeCtorId(#_module.Statement.stmtVariable(a0#29, a1#30)) == ##_module.Statement.stmtVariable);

axiom (forall d: DatatypeType :: _module.Statement.stmtVariable_q(d) ==> (exists a0#31: BoxType, a1#32: DatatypeType :: d == #_module.Statement.stmtVariable(a0#31, a1#32)));

function _module.Statement.stmtVariable_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Statement.stmtVariable_q(this) } _module.Statement.stmtVariable_q(this) <==> DatatypeCtorId(this) == ##_module.Statement.stmtVariable);

axiom (forall a0#33: BoxType, a1#34: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Statement.stmtVariable(a0#33, a1#34), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Statement.stmtVariable(a0#33, a1#34), $h) <==> GenericAlloc(a0#33, $h) && DtAlloc(a1#34, $h) && DtType(a1#34) == class._module.Expression));

axiom (forall a0#35: BoxType, a1#36: DatatypeType :: { #_module.Statement.stmtVariable(Lit(a0#35), Lit(a1#36)) } #_module.Statement.stmtVariable(Lit(a0#35), Lit(a1#36)) == Lit(#_module.Statement.stmtVariable(a0#35, a1#36)));

function _module.Statement.id(this: DatatypeType) : BoxType;

axiom (forall a0#37: BoxType, a1#38: DatatypeType :: _module.Statement.id(#_module.Statement.stmtVariable(a0#37, a1#38)) == a0#37);

axiom (forall a0#39: BoxType, a1#40: DatatypeType :: DtRank($Unbox(a0#39): DatatypeType) < DtRank(#_module.Statement.stmtVariable(a0#39, a1#40)));

function _module.Statement.expr(this: DatatypeType) : DatatypeType;

axiom (forall a0#41: BoxType, a1#42: DatatypeType :: _module.Statement.expr(#_module.Statement.stmtVariable(a0#41, a1#42)) == a1#42);

axiom (forall a0#43: BoxType, a1#44: DatatypeType :: DtRank(a1#44) < DtRank(#_module.Statement.stmtVariable(a0#43, a1#44)));

function #_module.Statement.stmtReturn(DatatypeType) : DatatypeType;

axiom (forall a0#45: DatatypeType :: DtType(#_module.Statement.stmtReturn(a0#45)) == class._module.Statement);

const unique ##_module.Statement.stmtReturn: DtCtorId;

axiom (forall a0#46: DatatypeType :: DatatypeCtorId(#_module.Statement.stmtReturn(a0#46)) == ##_module.Statement.stmtReturn);

axiom (forall d: DatatypeType :: _module.Statement.stmtReturn_q(d) ==> (exists a0#47: DatatypeType :: d == #_module.Statement.stmtReturn(a0#47)));

function _module.Statement.stmtReturn_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Statement.stmtReturn_q(this) } _module.Statement.stmtReturn_q(this) <==> DatatypeCtorId(this) == ##_module.Statement.stmtReturn);

axiom (forall a0#48: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Statement.stmtReturn(a0#48), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Statement.stmtReturn(a0#48), $h) <==> DtAlloc(a0#48, $h) && DtType(a0#48) == class._module.Expression));

axiom (forall a0#49: DatatypeType :: { #_module.Statement.stmtReturn(Lit(a0#49)) } #_module.Statement.stmtReturn(Lit(a0#49)) == Lit(#_module.Statement.stmtReturn(a0#49)));

function _module.Statement.ret(this: DatatypeType) : DatatypeType;

axiom (forall a0#50: DatatypeType :: _module.Statement.ret(#_module.Statement.stmtReturn(a0#50)) == a0#50);

axiom (forall a0#51: DatatypeType :: DtRank(a0#51) < DtRank(#_module.Statement.stmtReturn(a0#51)));

function $IsA#_module.Statement(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Statement(d) } $IsA#_module.Statement(d) <==> _module.Statement.stmtVariable_q(d) || _module.Statement.stmtReturn_q(d));

axiom (forall d: DatatypeType :: { _module.Statement.stmtReturn_q(d) } { _module.Statement.stmtVariable_q(d) } DtType(d) == class._module.Statement ==> _module.Statement.stmtVariable_q(d) || _module.Statement.stmtReturn_q(d));

const unique class._module.Expression: ClassName;

function #_module.Expression.exprLiteral(DatatypeType) : DatatypeType;

axiom (forall a0#52: DatatypeType :: DtType(#_module.Expression.exprLiteral(a0#52)) == class._module.Expression);

const unique ##_module.Expression.exprLiteral: DtCtorId;

axiom (forall a0#53: DatatypeType :: DatatypeCtorId(#_module.Expression.exprLiteral(a0#53)) == ##_module.Expression.exprLiteral);

axiom (forall d: DatatypeType :: _module.Expression.exprLiteral_q(d) ==> (exists a0#54: DatatypeType :: d == #_module.Expression.exprLiteral(a0#54)));

function _module.Expression.exprLiteral_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprLiteral_q(this) } _module.Expression.exprLiteral_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprLiteral);

axiom (forall a0#55: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Expression.exprLiteral(a0#55), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprLiteral(a0#55), $h) <==> DtAlloc(a0#55, $h) && DtType(a0#55) == class._module.Literal));

axiom (forall a0#56: DatatypeType :: { #_module.Expression.exprLiteral(Lit(a0#56)) } #_module.Expression.exprLiteral(Lit(a0#56)) == Lit(#_module.Expression.exprLiteral(a0#56)));

function _module.Expression.lit(this: DatatypeType) : DatatypeType;

axiom (forall a0#57: DatatypeType :: _module.Expression.lit(#_module.Expression.exprLiteral(a0#57)) == a0#57);

axiom (forall a0#58: DatatypeType :: DtRank(a0#58) < DtRank(#_module.Expression.exprLiteral(a0#58)));

function #_module.Expression.exprIdentifier(BoxType) : DatatypeType;

axiom (forall a0#59: BoxType :: DtType(#_module.Expression.exprIdentifier(a0#59)) == class._module.Expression);

const unique ##_module.Expression.exprIdentifier: DtCtorId;

axiom (forall a0#60: BoxType :: DatatypeCtorId(#_module.Expression.exprIdentifier(a0#60)) == ##_module.Expression.exprIdentifier);

axiom (forall d: DatatypeType :: _module.Expression.exprIdentifier_q(d) ==> (exists a0#61: BoxType :: d == #_module.Expression.exprIdentifier(a0#61)));

function _module.Expression.exprIdentifier_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprIdentifier_q(this) } _module.Expression.exprIdentifier_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprIdentifier);

axiom (forall a0#62: BoxType, $h: HeapType :: { DtAlloc(#_module.Expression.exprIdentifier(a0#62), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprIdentifier(a0#62), $h) <==> GenericAlloc(a0#62, $h)));

axiom (forall a0#63: BoxType :: { #_module.Expression.exprIdentifier(Lit(a0#63)) } #_module.Expression.exprIdentifier(Lit(a0#63)) == Lit(#_module.Expression.exprIdentifier(a0#63)));

function _module.Expression.id(this: DatatypeType) : BoxType;

axiom (forall a0#64: BoxType :: _module.Expression.id(#_module.Expression.exprIdentifier(a0#64)) == a0#64);

axiom (forall a0#65: BoxType :: DtRank($Unbox(a0#65): DatatypeType) < DtRank(#_module.Expression.exprIdentifier(a0#65)));

function #_module.Expression.exprIf(DatatypeType, DatatypeType, DatatypeType) : DatatypeType;

axiom (forall a0#66: DatatypeType, a1#67: DatatypeType, a2#68: DatatypeType :: DtType(#_module.Expression.exprIf(a0#66, a1#67, a2#68)) == class._module.Expression);

const unique ##_module.Expression.exprIf: DtCtorId;

axiom (forall a0#69: DatatypeType, a1#70: DatatypeType, a2#71: DatatypeType :: DatatypeCtorId(#_module.Expression.exprIf(a0#69, a1#70, a2#71)) == ##_module.Expression.exprIf);

axiom (forall d: DatatypeType :: _module.Expression.exprIf_q(d) ==> (exists a0#72: DatatypeType, a1#73: DatatypeType, a2#74: DatatypeType :: d == #_module.Expression.exprIf(a0#72, a1#73, a2#74)));

function _module.Expression.exprIf_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprIf_q(this) } _module.Expression.exprIf_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprIf);

axiom (forall a0#75: DatatypeType, a1#76: DatatypeType, a2#77: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Expression.exprIf(a0#75, a1#76, a2#77), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprIf(a0#75, a1#76, a2#77), $h) <==> DtAlloc(a0#75, $h) && DtType(a0#75) == class._module.Expression && DtAlloc(a1#76, $h) && DtType(a1#76) == class._module.Expression && DtAlloc(a2#77, $h) && DtType(a2#77) == class._module.Expression));

axiom (forall a0#78: DatatypeType, a1#79: DatatypeType, a2#80: DatatypeType :: { #_module.Expression.exprIf(Lit(a0#78), Lit(a1#79), Lit(a2#80)) } #_module.Expression.exprIf(Lit(a0#78), Lit(a1#79), Lit(a2#80)) == Lit(#_module.Expression.exprIf(a0#78, a1#79, a2#80)));

function _module.Expression.cond(this: DatatypeType) : DatatypeType;

axiom (forall a0#81: DatatypeType, a1#82: DatatypeType, a2#83: DatatypeType :: _module.Expression.cond(#_module.Expression.exprIf(a0#81, a1#82, a2#83)) == a0#81);

axiom (forall a0#84: DatatypeType, a1#85: DatatypeType, a2#86: DatatypeType :: DtRank(a0#84) < DtRank(#_module.Expression.exprIf(a0#84, a1#85, a2#86)));

function _module.Expression.ifTrue(this: DatatypeType) : DatatypeType;

axiom (forall a0#87: DatatypeType, a1#88: DatatypeType, a2#89: DatatypeType :: _module.Expression.ifTrue(#_module.Expression.exprIf(a0#87, a1#88, a2#89)) == a1#88);

axiom (forall a0#90: DatatypeType, a1#91: DatatypeType, a2#92: DatatypeType :: DtRank(a1#91) < DtRank(#_module.Expression.exprIf(a0#90, a1#91, a2#92)));

function _module.Expression.ifFalse(this: DatatypeType) : DatatypeType;

axiom (forall a0#93: DatatypeType, a1#94: DatatypeType, a2#95: DatatypeType :: _module.Expression.ifFalse(#_module.Expression.exprIf(a0#93, a1#94, a2#95)) == a2#95);

axiom (forall a0#96: DatatypeType, a1#97: DatatypeType, a2#98: DatatypeType :: DtRank(a2#98) < DtRank(#_module.Expression.exprIf(a0#96, a1#97, a2#98)));

function #_module.Expression.exprAnd(DatatypeType, DatatypeType) : DatatypeType;

axiom (forall a0#99: DatatypeType, a1#100: DatatypeType :: DtType(#_module.Expression.exprAnd(a0#99, a1#100)) == class._module.Expression);

const unique ##_module.Expression.exprAnd: DtCtorId;

axiom (forall a0#101: DatatypeType, a1#102: DatatypeType :: DatatypeCtorId(#_module.Expression.exprAnd(a0#101, a1#102)) == ##_module.Expression.exprAnd);

axiom (forall d: DatatypeType :: _module.Expression.exprAnd_q(d) ==> (exists a0#103: DatatypeType, a1#104: DatatypeType :: d == #_module.Expression.exprAnd(a0#103, a1#104)));

function _module.Expression.exprAnd_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprAnd_q(this) } _module.Expression.exprAnd_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprAnd);

axiom (forall a0#105: DatatypeType, a1#106: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Expression.exprAnd(a0#105, a1#106), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprAnd(a0#105, a1#106), $h) <==> DtAlloc(a0#105, $h) && DtType(a0#105) == class._module.Expression && DtAlloc(a1#106, $h) && DtType(a1#106) == class._module.Expression));

axiom (forall a0#107: DatatypeType, a1#108: DatatypeType :: { #_module.Expression.exprAnd(Lit(a0#107), Lit(a1#108)) } #_module.Expression.exprAnd(Lit(a0#107), Lit(a1#108)) == Lit(#_module.Expression.exprAnd(a0#107, a1#108)));

function _module.Expression.conj0(this: DatatypeType) : DatatypeType;

axiom (forall a0#109: DatatypeType, a1#110: DatatypeType :: _module.Expression.conj0(#_module.Expression.exprAnd(a0#109, a1#110)) == a0#109);

axiom (forall a0#111: DatatypeType, a1#112: DatatypeType :: DtRank(a0#111) < DtRank(#_module.Expression.exprAnd(a0#111, a1#112)));

function _module.Expression.conj1(this: DatatypeType) : DatatypeType;

axiom (forall a0#113: DatatypeType, a1#114: DatatypeType :: _module.Expression.conj1(#_module.Expression.exprAnd(a0#113, a1#114)) == a1#114);

axiom (forall a0#115: DatatypeType, a1#116: DatatypeType :: DtRank(a1#116) < DtRank(#_module.Expression.exprAnd(a0#115, a1#116)));

function #_module.Expression.exprOr(DatatypeType, DatatypeType) : DatatypeType;

axiom (forall a0#117: DatatypeType, a1#118: DatatypeType :: DtType(#_module.Expression.exprOr(a0#117, a1#118)) == class._module.Expression);

const unique ##_module.Expression.exprOr: DtCtorId;

axiom (forall a0#119: DatatypeType, a1#120: DatatypeType :: DatatypeCtorId(#_module.Expression.exprOr(a0#119, a1#120)) == ##_module.Expression.exprOr);

axiom (forall d: DatatypeType :: _module.Expression.exprOr_q(d) ==> (exists a0#121: DatatypeType, a1#122: DatatypeType :: d == #_module.Expression.exprOr(a0#121, a1#122)));

function _module.Expression.exprOr_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprOr_q(this) } _module.Expression.exprOr_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprOr);

axiom (forall a0#123: DatatypeType, a1#124: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Expression.exprOr(a0#123, a1#124), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprOr(a0#123, a1#124), $h) <==> DtAlloc(a0#123, $h) && DtType(a0#123) == class._module.Expression && DtAlloc(a1#124, $h) && DtType(a1#124) == class._module.Expression));

axiom (forall a0#125: DatatypeType, a1#126: DatatypeType :: { #_module.Expression.exprOr(Lit(a0#125), Lit(a1#126)) } #_module.Expression.exprOr(Lit(a0#125), Lit(a1#126)) == Lit(#_module.Expression.exprOr(a0#125, a1#126)));

function _module.Expression.disj0(this: DatatypeType) : DatatypeType;

axiom (forall a0#127: DatatypeType, a1#128: DatatypeType :: _module.Expression.disj0(#_module.Expression.exprOr(a0#127, a1#128)) == a0#127);

axiom (forall a0#129: DatatypeType, a1#130: DatatypeType :: DtRank(a0#129) < DtRank(#_module.Expression.exprOr(a0#129, a1#130)));

function _module.Expression.disj1(this: DatatypeType) : DatatypeType;

axiom (forall a0#131: DatatypeType, a1#132: DatatypeType :: _module.Expression.disj1(#_module.Expression.exprOr(a0#131, a1#132)) == a1#132);

axiom (forall a0#133: DatatypeType, a1#134: DatatypeType :: DtRank(a1#134) < DtRank(#_module.Expression.exprOr(a0#133, a1#134)));

function #_module.Expression.exprInvocation(DatatypeType, Seq BoxType) : DatatypeType;

axiom (forall a0#135: DatatypeType, a1#136: Seq BoxType :: DtType(#_module.Expression.exprInvocation(a0#135, a1#136)) == class._module.Expression);

const unique ##_module.Expression.exprInvocation: DtCtorId;

axiom (forall a0#137: DatatypeType, a1#138: Seq BoxType :: DatatypeCtorId(#_module.Expression.exprInvocation(a0#137, a1#138)) == ##_module.Expression.exprInvocation);

axiom (forall d: DatatypeType :: _module.Expression.exprInvocation_q(d) ==> (exists a0#139: DatatypeType, a1#140: Seq BoxType :: d == #_module.Expression.exprInvocation(a0#139, a1#140)));

function _module.Expression.exprInvocation_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprInvocation_q(this) } _module.Expression.exprInvocation_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprInvocation);

axiom (forall a0#141: DatatypeType, a1#142: Seq BoxType, $h: HeapType :: { DtAlloc(#_module.Expression.exprInvocation(a0#141, a1#142), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprInvocation(a0#141, a1#142), $h) <==> DtAlloc(a0#141, $h) && DtType(a0#141) == class._module.Expression && (forall $i#143: int :: { Seq#Index(a1#142, $i#143) } 0 <= $i#143 && $i#143 < Seq#Length(a1#142) ==> DtAlloc($Unbox(Seq#Index(a1#142, $i#143)): DatatypeType, $h) && DtType($Unbox(Seq#Index(a1#142, $i#143)): DatatypeType) == class._module.Expression)));

axiom (forall a0#144: DatatypeType, a1#145: Seq BoxType :: { #_module.Expression.exprInvocation(Lit(a0#144), Lit(a1#145)) } #_module.Expression.exprInvocation(Lit(a0#144), Lit(a1#145)) == Lit(#_module.Expression.exprInvocation(a0#144, a1#145)));

function _module.Expression.fun(this: DatatypeType) : DatatypeType;

axiom (forall a0#146: DatatypeType, a1#147: Seq BoxType :: _module.Expression.fun(#_module.Expression.exprInvocation(a0#146, a1#147)) == a0#146);

axiom (forall a0#148: DatatypeType, a1#149: Seq BoxType :: DtRank(a0#148) < DtRank(#_module.Expression.exprInvocation(a0#148, a1#149)));

function _module.Expression.args(this: DatatypeType) : Seq BoxType;

axiom (forall a0#150: DatatypeType, a1#151: Seq BoxType :: _module.Expression.args(#_module.Expression.exprInvocation(a0#150, a1#151)) == a1#151);

axiom (forall a0#152: DatatypeType, a1#153: Seq BoxType, i: int :: 0 <= i && i < Seq#Length(a1#153) ==> DtRank($Unbox(Seq#Index(a1#153, i)): DatatypeType) < DtRank(#_module.Expression.exprInvocation(a0#152, a1#153)));

axiom (forall a0#154: DatatypeType, a1#155: Seq BoxType :: Seq#Rank(a1#155) < DtRank(#_module.Expression.exprInvocation(a0#154, a1#155)));

function #_module.Expression.exprError(DatatypeType) : DatatypeType;

axiom (forall a0#156: DatatypeType :: DtType(#_module.Expression.exprError(a0#156)) == class._module.Expression);

const unique ##_module.Expression.exprError: DtCtorId;

axiom (forall a0#157: DatatypeType :: DatatypeCtorId(#_module.Expression.exprError(a0#157)) == ##_module.Expression.exprError);

axiom (forall d: DatatypeType :: _module.Expression.exprError_q(d) ==> (exists a0#158: DatatypeType :: d == #_module.Expression.exprError(a0#158)));

function _module.Expression.exprError_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Expression.exprError_q(this) } _module.Expression.exprError_q(this) <==> DatatypeCtorId(this) == ##_module.Expression.exprError);

axiom (forall a0#159: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Expression.exprError(a0#159), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Expression.exprError(a0#159), $h) <==> DtAlloc(a0#159, $h) && DtType(a0#159) == class._module.Reason));

axiom (forall a0#160: DatatypeType :: { #_module.Expression.exprError(Lit(a0#160)) } #_module.Expression.exprError(Lit(a0#160)) == Lit(#_module.Expression.exprError(a0#160)));

function _module.Expression.r(this: DatatypeType) : DatatypeType;

axiom (forall a0#161: DatatypeType :: _module.Expression.r(#_module.Expression.exprError(a0#161)) == a0#161);

axiom (forall a0#162: DatatypeType :: DtRank(a0#162) < DtRank(#_module.Expression.exprError(a0#162)));

function $IsA#_module.Expression(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Expression(d) } $IsA#_module.Expression(d) <==> _module.Expression.exprLiteral_q(d) || _module.Expression.exprIdentifier_q(d) || _module.Expression.exprIf_q(d) || _module.Expression.exprAnd_q(d) || _module.Expression.exprOr_q(d) || _module.Expression.exprInvocation_q(d) || _module.Expression.exprError_q(d));

axiom (forall d: DatatypeType :: { _module.Expression.exprError_q(d) } { _module.Expression.exprInvocation_q(d) } { _module.Expression.exprOr_q(d) } { _module.Expression.exprAnd_q(d) } { _module.Expression.exprIf_q(d) } { _module.Expression.exprIdentifier_q(d) } { _module.Expression.exprLiteral_q(d) } DtType(d) == class._module.Expression ==> _module.Expression.exprLiteral_q(d) || _module.Expression.exprIdentifier_q(d) || _module.Expression.exprIf_q(d) || _module.Expression.exprAnd_q(d) || _module.Expression.exprOr_q(d) || _module.Expression.exprInvocation_q(d) || _module.Expression.exprError_q(d));

const unique class._module.Literal: ClassName;

function #_module.Literal.litTrue() : DatatypeType;

axiom DtType(#_module.Literal.litTrue()) == class._module.Literal;

const unique ##_module.Literal.litTrue: DtCtorId;

axiom DatatypeCtorId(#_module.Literal.litTrue()) == ##_module.Literal.litTrue;

axiom (forall d: DatatypeType :: _module.Literal.litTrue_q(d) ==> d == #_module.Literal.litTrue());

function _module.Literal.litTrue_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litTrue_q(this) } _module.Literal.litTrue_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litTrue);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Literal.litTrue(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litTrue(), $h) <==> true));

axiom #_module.Literal.litTrue() == Lit(#_module.Literal.litTrue());

function #_module.Literal.litFalse() : DatatypeType;

axiom DtType(#_module.Literal.litFalse()) == class._module.Literal;

const unique ##_module.Literal.litFalse: DtCtorId;

axiom DatatypeCtorId(#_module.Literal.litFalse()) == ##_module.Literal.litFalse;

axiom (forall d: DatatypeType :: _module.Literal.litFalse_q(d) ==> d == #_module.Literal.litFalse());

function _module.Literal.litFalse_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litFalse_q(this) } _module.Literal.litFalse_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litFalse);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Literal.litFalse(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litFalse(), $h) <==> true));

axiom #_module.Literal.litFalse() == Lit(#_module.Literal.litFalse());

function #_module.Literal.litUndefined() : DatatypeType;

axiom DtType(#_module.Literal.litUndefined()) == class._module.Literal;

const unique ##_module.Literal.litUndefined: DtCtorId;

axiom DatatypeCtorId(#_module.Literal.litUndefined()) == ##_module.Literal.litUndefined;

axiom (forall d: DatatypeType :: _module.Literal.litUndefined_q(d) ==> d == #_module.Literal.litUndefined());

function _module.Literal.litUndefined_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litUndefined_q(this) } _module.Literal.litUndefined_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litUndefined);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Literal.litUndefined(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litUndefined(), $h) <==> true));

axiom #_module.Literal.litUndefined() == Lit(#_module.Literal.litUndefined());

function #_module.Literal.litNull() : DatatypeType;

axiom DtType(#_module.Literal.litNull()) == class._module.Literal;

const unique ##_module.Literal.litNull: DtCtorId;

axiom DatatypeCtorId(#_module.Literal.litNull()) == ##_module.Literal.litNull;

axiom (forall d: DatatypeType :: _module.Literal.litNull_q(d) ==> d == #_module.Literal.litNull());

function _module.Literal.litNull_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litNull_q(this) } _module.Literal.litNull_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litNull);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Literal.litNull(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litNull(), $h) <==> true));

axiom #_module.Literal.litNull() == Lit(#_module.Literal.litNull());

function #_module.Literal.litNumber(int) : DatatypeType;

axiom (forall a0#163: int :: DtType(#_module.Literal.litNumber(a0#163)) == class._module.Literal);

const unique ##_module.Literal.litNumber: DtCtorId;

axiom (forall a0#164: int :: DatatypeCtorId(#_module.Literal.litNumber(a0#164)) == ##_module.Literal.litNumber);

axiom (forall d: DatatypeType :: _module.Literal.litNumber_q(d) ==> (exists a0#165: int :: d == #_module.Literal.litNumber(a0#165)));

function _module.Literal.litNumber_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litNumber_q(this) } _module.Literal.litNumber_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litNumber);

axiom (forall a0#166: int, $h: HeapType :: { DtAlloc(#_module.Literal.litNumber(a0#166), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litNumber(a0#166), $h) <==> true));

axiom (forall a0#167: int :: { #_module.Literal.litNumber(Lit(a0#167)) } #_module.Literal.litNumber(Lit(a0#167)) == Lit(#_module.Literal.litNumber(a0#167)));

function _module.Literal.num(this: DatatypeType) : int;

axiom (forall a0#168: int :: _module.Literal.num(#_module.Literal.litNumber(a0#168)) == a0#168);

function #_module.Literal.litString(BoxType) : DatatypeType;

axiom (forall a0#169: BoxType :: DtType(#_module.Literal.litString(a0#169)) == class._module.Literal);

const unique ##_module.Literal.litString: DtCtorId;

axiom (forall a0#170: BoxType :: DatatypeCtorId(#_module.Literal.litString(a0#170)) == ##_module.Literal.litString);

axiom (forall d: DatatypeType :: _module.Literal.litString_q(d) ==> (exists a0#171: BoxType :: d == #_module.Literal.litString(a0#171)));

function _module.Literal.litString_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litString_q(this) } _module.Literal.litString_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litString);

axiom (forall a0#172: BoxType, $h: HeapType :: { DtAlloc(#_module.Literal.litString(a0#172), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litString(a0#172), $h) <==> GenericAlloc(a0#172, $h)));

axiom (forall a0#173: BoxType :: { #_module.Literal.litString(Lit(a0#173)) } #_module.Literal.litString(Lit(a0#173)) == Lit(#_module.Literal.litString(a0#173)));

function _module.Literal.str(this: DatatypeType) : BoxType;

axiom (forall a0#174: BoxType :: _module.Literal.str(#_module.Literal.litString(a0#174)) == a0#174);

axiom (forall a0#175: BoxType :: DtRank($Unbox(a0#175): DatatypeType) < DtRank(#_module.Literal.litString(a0#175)));

function #_module.Literal.litPrimitive(DatatypeType) : DatatypeType;

axiom (forall a0#176: DatatypeType :: DtType(#_module.Literal.litPrimitive(a0#176)) == class._module.Literal);

const unique ##_module.Literal.litPrimitive: DtCtorId;

axiom (forall a0#177: DatatypeType :: DatatypeCtorId(#_module.Literal.litPrimitive(a0#177)) == ##_module.Literal.litPrimitive);

axiom (forall d: DatatypeType :: _module.Literal.litPrimitive_q(d) ==> (exists a0#178: DatatypeType :: d == #_module.Literal.litPrimitive(a0#178)));

function _module.Literal.litPrimitive_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litPrimitive_q(this) } _module.Literal.litPrimitive_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litPrimitive);

axiom (forall a0#179: DatatypeType, $h: HeapType :: { DtAlloc(#_module.Literal.litPrimitive(a0#179), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litPrimitive(a0#179), $h) <==> DtAlloc(a0#179, $h) && DtType(a0#179) == class._module.Primitive));

axiom (forall a0#180: DatatypeType :: { #_module.Literal.litPrimitive(Lit(a0#180)) } #_module.Literal.litPrimitive(Lit(a0#180)) == Lit(#_module.Literal.litPrimitive(a0#180)));

function _module.Literal.prim(this: DatatypeType) : DatatypeType;

axiom (forall a0#181: DatatypeType :: _module.Literal.prim(#_module.Literal.litPrimitive(a0#181)) == a0#181);

axiom (forall a0#182: DatatypeType :: DtRank(a0#182) < DtRank(#_module.Literal.litPrimitive(a0#182)));

function #_module.Literal.litArrOfPaths(Set BoxType) : DatatypeType;

axiom (forall a0#183: Set BoxType :: DtType(#_module.Literal.litArrOfPaths(a0#183)) == class._module.Literal);

const unique ##_module.Literal.litArrOfPaths: DtCtorId;

axiom (forall a0#184: Set BoxType :: DatatypeCtorId(#_module.Literal.litArrOfPaths(a0#184)) == ##_module.Literal.litArrOfPaths);

axiom (forall d: DatatypeType :: _module.Literal.litArrOfPaths_q(d) ==> (exists a0#185: Set BoxType :: d == #_module.Literal.litArrOfPaths(a0#185)));

function _module.Literal.litArrOfPaths_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litArrOfPaths_q(this) } _module.Literal.litArrOfPaths_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litArrOfPaths);

axiom (forall a0#186: Set BoxType, $h: HeapType :: { DtAlloc(#_module.Literal.litArrOfPaths(a0#186), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litArrOfPaths(a0#186), $h) <==> (forall $t#187: BoxType :: { a0#186[$t#187] } a0#186[$t#187] ==> DtAlloc($Unbox($t#187): DatatypeType, $h) && DtType($Unbox($t#187): DatatypeType) == class._module.Path)));

axiom (forall a0#188: Set BoxType :: { #_module.Literal.litArrOfPaths(Lit(a0#188)) } #_module.Literal.litArrOfPaths(Lit(a0#188)) == Lit(#_module.Literal.litArrOfPaths(a0#188)));

function _module.Literal.paths(this: DatatypeType) : Set BoxType;

axiom (forall a0#189: Set BoxType :: _module.Literal.paths(#_module.Literal.litArrOfPaths(a0#189)) == a0#189);

axiom (forall a0#190: Set BoxType, d: DatatypeType :: a0#190[$Box(d)] ==> DtRank(d) < DtRank(#_module.Literal.litArrOfPaths(a0#190)));

function #_module.Literal.litArrOfStrings(Set BoxType) : DatatypeType;

axiom (forall a0#191: Set BoxType :: DtType(#_module.Literal.litArrOfStrings(a0#191)) == class._module.Literal);

const unique ##_module.Literal.litArrOfStrings: DtCtorId;

axiom (forall a0#192: Set BoxType :: DatatypeCtorId(#_module.Literal.litArrOfStrings(a0#192)) == ##_module.Literal.litArrOfStrings);

axiom (forall d: DatatypeType :: _module.Literal.litArrOfStrings_q(d) ==> (exists a0#193: Set BoxType :: d == #_module.Literal.litArrOfStrings(a0#193)));

function _module.Literal.litArrOfStrings_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litArrOfStrings_q(this) } _module.Literal.litArrOfStrings_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litArrOfStrings);

axiom (forall a0#194: Set BoxType, $h: HeapType :: { DtAlloc(#_module.Literal.litArrOfStrings(a0#194), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litArrOfStrings(a0#194), $h) <==> (forall $t#195: BoxType :: { a0#194[$t#195] } a0#194[$t#195] ==> GenericAlloc($t#195, $h))));

axiom (forall a0#196: Set BoxType :: { #_module.Literal.litArrOfStrings(Lit(a0#196)) } #_module.Literal.litArrOfStrings(Lit(a0#196)) == Lit(#_module.Literal.litArrOfStrings(a0#196)));

function _module.Literal.strs(this: DatatypeType) : Set BoxType;

axiom (forall a0#197: Set BoxType :: _module.Literal.strs(#_module.Literal.litArrOfStrings(a0#197)) == a0#197);

axiom (forall a0#198: Set BoxType, d: DatatypeType :: a0#198[$Box(d)] ==> DtRank(d) < DtRank(#_module.Literal.litArrOfStrings(a0#198)));

function #_module.Literal.litArray(Seq BoxType) : DatatypeType;

axiom (forall a0#199: Seq BoxType :: DtType(#_module.Literal.litArray(a0#199)) == class._module.Literal);

const unique ##_module.Literal.litArray: DtCtorId;

axiom (forall a0#200: Seq BoxType :: DatatypeCtorId(#_module.Literal.litArray(a0#200)) == ##_module.Literal.litArray);

axiom (forall d: DatatypeType :: _module.Literal.litArray_q(d) ==> (exists a0#201: Seq BoxType :: d == #_module.Literal.litArray(a0#201)));

function _module.Literal.litArray_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Literal.litArray_q(this) } _module.Literal.litArray_q(this) <==> DatatypeCtorId(this) == ##_module.Literal.litArray);

axiom (forall a0#202: Seq BoxType, $h: HeapType :: { DtAlloc(#_module.Literal.litArray(a0#202), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Literal.litArray(a0#202), $h) <==> (forall $i#203: int :: { Seq#Index(a0#202, $i#203) } 0 <= $i#203 && $i#203 < Seq#Length(a0#202) ==> DtAlloc($Unbox(Seq#Index(a0#202, $i#203)): DatatypeType, $h) && DtType($Unbox(Seq#Index(a0#202, $i#203)): DatatypeType) == class._module.Expression)));

axiom (forall a0#204: Seq BoxType :: { #_module.Literal.litArray(Lit(a0#204)) } #_module.Literal.litArray(Lit(a0#204)) == Lit(#_module.Literal.litArray(a0#204)));

function _module.Literal.arr(this: DatatypeType) : Seq BoxType;

axiom (forall a0#205: Seq BoxType :: _module.Literal.arr(#_module.Literal.litArray(a0#205)) == a0#205);

axiom (forall a0#206: Seq BoxType, i: int :: 0 <= i && i < Seq#Length(a0#206) ==> DtRank($Unbox(Seq#Index(a0#206, i)): DatatypeType) < DtRank(#_module.Literal.litArray(a0#206)));

axiom (forall a0#207: Seq BoxType :: Seq#Rank(a0#207) < DtRank(#_module.Literal.litArray(a0#207)));

function $IsA#_module.Literal(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Literal(d) } $IsA#_module.Literal(d) <==> _module.Literal.litTrue_q(d) || _module.Literal.litFalse_q(d) || _module.Literal.litUndefined_q(d) || _module.Literal.litNull_q(d) || _module.Literal.litNumber_q(d) || _module.Literal.litString_q(d) || _module.Literal.litPrimitive_q(d) || _module.Literal.litArrOfPaths_q(d) || _module.Literal.litArrOfStrings_q(d) || _module.Literal.litArray_q(d));

axiom (forall d: DatatypeType :: { _module.Literal.litArray_q(d) } { _module.Literal.litArrOfStrings_q(d) } { _module.Literal.litArrOfPaths_q(d) } { _module.Literal.litPrimitive_q(d) } { _module.Literal.litString_q(d) } { _module.Literal.litNumber_q(d) } { _module.Literal.litNull_q(d) } { _module.Literal.litUndefined_q(d) } { _module.Literal.litFalse_q(d) } { _module.Literal.litTrue_q(d) } DtType(d) == class._module.Literal ==> _module.Literal.litTrue_q(d) || _module.Literal.litFalse_q(d) || _module.Literal.litUndefined_q(d) || _module.Literal.litNull_q(d) || _module.Literal.litNumber_q(d) || _module.Literal.litString_q(d) || _module.Literal.litPrimitive_q(d) || _module.Literal.litArrOfPaths_q(d) || _module.Literal.litArrOfStrings_q(d) || _module.Literal.litArray_q(d));

const unique class._module.Primitive: ClassName;

function #_module.Primitive.primCreatePath() : DatatypeType;

axiom DtType(#_module.Primitive.primCreatePath()) == class._module.Primitive;

const unique ##_module.Primitive.primCreatePath: DtCtorId;

axiom DatatypeCtorId(#_module.Primitive.primCreatePath()) == ##_module.Primitive.primCreatePath;

axiom (forall d: DatatypeType :: _module.Primitive.primCreatePath_q(d) ==> d == #_module.Primitive.primCreatePath());

function _module.Primitive.primCreatePath_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Primitive.primCreatePath_q(this) } _module.Primitive.primCreatePath_q(this) <==> DatatypeCtorId(this) == ##_module.Primitive.primCreatePath);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Primitive.primCreatePath(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Primitive.primCreatePath(), $h) <==> true));

axiom #_module.Primitive.primCreatePath() == Lit(#_module.Primitive.primCreatePath());

function #_module.Primitive.primExec() : DatatypeType;

axiom DtType(#_module.Primitive.primExec()) == class._module.Primitive;

const unique ##_module.Primitive.primExec: DtCtorId;

axiom DatatypeCtorId(#_module.Primitive.primExec()) == ##_module.Primitive.primExec;

axiom (forall d: DatatypeType :: _module.Primitive.primExec_q(d) ==> d == #_module.Primitive.primExec());

function _module.Primitive.primExec_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Primitive.primExec_q(this) } _module.Primitive.primExec_q(this) <==> DatatypeCtorId(this) == ##_module.Primitive.primExec);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Primitive.primExec(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Primitive.primExec(), $h) <==> true));

axiom #_module.Primitive.primExec() == Lit(#_module.Primitive.primExec());

function $IsA#_module.Primitive(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Primitive(d) } $IsA#_module.Primitive(d) <==> _module.Primitive.primCreatePath_q(d) || _module.Primitive.primExec_q(d));

axiom (forall d: DatatypeType :: { _module.Primitive.primExec_q(d) } { _module.Primitive.primCreatePath_q(d) } DtType(d) == class._module.Primitive ==> _module.Primitive.primCreatePath_q(d) || _module.Primitive.primExec_q(d));

const unique class._module.Reason: ClassName;

function #_module.Reason.rCompatibility() : DatatypeType;

axiom DtType(#_module.Reason.rCompatibility()) == class._module.Reason;

const unique ##_module.Reason.rCompatibility: DtCtorId;

axiom DatatypeCtorId(#_module.Reason.rCompatibility()) == ##_module.Reason.rCompatibility;

axiom (forall d: DatatypeType :: _module.Reason.rCompatibility_q(d) ==> d == #_module.Reason.rCompatibility());

function _module.Reason.rCompatibility_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Reason.rCompatibility_q(this) } _module.Reason.rCompatibility_q(this) <==> DatatypeCtorId(this) == ##_module.Reason.rCompatibility);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Reason.rCompatibility(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Reason.rCompatibility(), $h) <==> true));

axiom #_module.Reason.rCompatibility() == Lit(#_module.Reason.rCompatibility());

function #_module.Reason.rValidity() : DatatypeType;

axiom DtType(#_module.Reason.rValidity()) == class._module.Reason;

const unique ##_module.Reason.rValidity: DtCtorId;

axiom DatatypeCtorId(#_module.Reason.rValidity()) == ##_module.Reason.rValidity;

axiom (forall d: DatatypeType :: _module.Reason.rValidity_q(d) ==> d == #_module.Reason.rValidity());

function _module.Reason.rValidity_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Reason.rValidity_q(this) } _module.Reason.rValidity_q(this) <==> DatatypeCtorId(this) == ##_module.Reason.rValidity);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Reason.rValidity(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Reason.rValidity(), $h) <==> true));

axiom #_module.Reason.rValidity() == Lit(#_module.Reason.rValidity());

function #_module.Reason.rInconsistentCache() : DatatypeType;

axiom DtType(#_module.Reason.rInconsistentCache()) == class._module.Reason;

const unique ##_module.Reason.rInconsistentCache: DtCtorId;

axiom DatatypeCtorId(#_module.Reason.rInconsistentCache()) == ##_module.Reason.rInconsistentCache;

axiom (forall d: DatatypeType :: _module.Reason.rInconsistentCache_q(d) ==> d == #_module.Reason.rInconsistentCache());

function _module.Reason.rInconsistentCache_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Reason.rInconsistentCache_q(this) } _module.Reason.rInconsistentCache_q(this) <==> DatatypeCtorId(this) == ##_module.Reason.rInconsistentCache);

axiom (forall $h: HeapType :: { DtAlloc(#_module.Reason.rInconsistentCache(), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Reason.rInconsistentCache(), $h) <==> true));

axiom #_module.Reason.rInconsistentCache() == Lit(#_module.Reason.rInconsistentCache());

function $IsA#_module.Reason(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Reason(d) } $IsA#_module.Reason(d) <==> _module.Reason.rCompatibility_q(d) || _module.Reason.rValidity_q(d) || _module.Reason.rInconsistentCache_q(d));

axiom (forall d: DatatypeType :: { _module.Reason.rInconsistentCache_q(d) } { _module.Reason.rValidity_q(d) } { _module.Reason.rCompatibility_q(d) } DtType(d) == class._module.Reason ==> _module.Reason.rCompatibility_q(d) || _module.Reason.rValidity_q(d) || _module.Reason.rInconsistentCache_q(d));

const unique class._module.Path: ClassName;

function #_module.Path.OpaquePath(int) : DatatypeType;

axiom (forall a0#208: int :: DtType(#_module.Path.OpaquePath(a0#208)) == class._module.Path);

const unique ##_module.Path.OpaquePath: DtCtorId;

axiom (forall a0#209: int :: DatatypeCtorId(#_module.Path.OpaquePath(a0#209)) == ##_module.Path.OpaquePath);

axiom (forall d: DatatypeType :: _module.Path.OpaquePath_q(d) ==> (exists a0#210: int :: d == #_module.Path.OpaquePath(a0#210)));

function _module.Path.OpaquePath_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Path.OpaquePath_q(this) } _module.Path.OpaquePath_q(this) <==> DatatypeCtorId(this) == ##_module.Path.OpaquePath);

axiom (forall a0#211: int, $h: HeapType :: { DtAlloc(#_module.Path.OpaquePath(a0#211), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Path.OpaquePath(a0#211), $h) <==> true));

axiom (forall a0#212: int :: { #_module.Path.OpaquePath(Lit(a0#212)) } #_module.Path.OpaquePath(Lit(a0#212)) == Lit(#_module.Path.OpaquePath(a0#212)));

function _module.Path.#0(this: DatatypeType) : int;

axiom (forall a0#213: int :: _module.Path.#0(#_module.Path.OpaquePath(a0#213)) == a0#213);

function #_module.Path.TransparentPath(int) : DatatypeType;

axiom (forall a0#214: int :: DtType(#_module.Path.TransparentPath(a0#214)) == class._module.Path);

const unique ##_module.Path.TransparentPath: DtCtorId;

axiom (forall a0#215: int :: DatatypeCtorId(#_module.Path.TransparentPath(a0#215)) == ##_module.Path.TransparentPath);

axiom (forall d: DatatypeType :: _module.Path.TransparentPath_q(d) ==> (exists a0#216: int :: d == #_module.Path.TransparentPath(a0#216)));

function _module.Path.TransparentPath_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Path.TransparentPath_q(this) } _module.Path.TransparentPath_q(this) <==> DatatypeCtorId(this) == ##_module.Path.TransparentPath);

axiom (forall a0#217: int, $h: HeapType :: { DtAlloc(#_module.Path.TransparentPath(a0#217), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Path.TransparentPath(a0#217), $h) <==> true));

axiom (forall a0#218: int :: { #_module.Path.TransparentPath(Lit(a0#218)) } #_module.Path.TransparentPath(Lit(a0#218)) == Lit(#_module.Path.TransparentPath(a0#218)));

function _module.Path.#1(this: DatatypeType) : int;

axiom (forall a0#219: int :: _module.Path.#1(#_module.Path.TransparentPath(a0#219)) == a0#219);

function $IsA#_module.Path(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Path(d) } $IsA#_module.Path(d) <==> _module.Path.OpaquePath_q(d) || _module.Path.TransparentPath_q(d));

axiom (forall d: DatatypeType :: { _module.Path.TransparentPath_q(d) } { _module.Path.OpaquePath_q(d) } DtType(d) == class._module.Path ==> _module.Path.OpaquePath_q(d) || _module.Path.TransparentPath_q(d));

const unique class._module.Tuple: ClassName;

function #_module.Tuple.Pair(BoxType, BoxType) : DatatypeType;

axiom (forall a0#220: BoxType, a1#221: BoxType :: DtType(#_module.Tuple.Pair(a0#220, a1#221)) == class._module.Tuple);

const unique ##_module.Tuple.Pair: DtCtorId;

axiom (forall a0#222: BoxType, a1#223: BoxType :: DatatypeCtorId(#_module.Tuple.Pair(a0#222, a1#223)) == ##_module.Tuple.Pair);

axiom (forall d: DatatypeType :: _module.Tuple.Pair_q(d) ==> (exists a0#224: BoxType, a1#225: BoxType :: d == #_module.Tuple.Pair(a0#224, a1#225)));

function _module.Tuple.Pair_q(this: DatatypeType) : bool;

axiom (forall this: DatatypeType :: { _module.Tuple.Pair_q(this) } _module.Tuple.Pair_q(this) <==> DatatypeCtorId(this) == ##_module.Tuple.Pair);

axiom (forall a0#226: BoxType, a1#227: BoxType, $h: HeapType :: { DtAlloc(#_module.Tuple.Pair(a0#226, a1#227), $h) } $IsGoodHeap($h) ==> (DtAlloc(#_module.Tuple.Pair(a0#226, a1#227), $h) <==> GenericAlloc(a0#226, $h) && GenericAlloc(a1#227, $h)));

axiom (forall a0#228: BoxType, a1#229: BoxType :: { #_module.Tuple.Pair(Lit(a0#228), Lit(a1#229)) } #_module.Tuple.Pair(Lit(a0#228), Lit(a1#229)) == Lit(#_module.Tuple.Pair(a0#228, a1#229)));

function _module.Tuple.fst(this: DatatypeType) : BoxType;

axiom (forall a0#230: BoxType, a1#231: BoxType :: _module.Tuple.fst(#_module.Tuple.Pair(a0#230, a1#231)) == a0#230);

axiom (forall a0#232: BoxType, a1#233: BoxType :: DtRank($Unbox(a0#232): DatatypeType) < DtRank(#_module.Tuple.Pair(a0#232, a1#233)));

function _module.Tuple.snd(this: DatatypeType) : BoxType;

axiom (forall a0#234: BoxType, a1#235: BoxType :: _module.Tuple.snd(#_module.Tuple.Pair(a0#234, a1#235)) == a1#235);

axiom (forall a0#236: BoxType, a1#237: BoxType :: DtRank($Unbox(a1#237): DatatypeType) < DtRank(#_module.Tuple.Pair(a0#236, a1#237)));

function $IsA#_module.Tuple(d: DatatypeType) : bool;

axiom (forall d: DatatypeType :: { $IsA#_module.Tuple(d) } $IsA#_module.Tuple(d) <==> _module.Tuple.Pair_q(d));

axiom (forall d: DatatypeType :: { _module.Tuple.Pair_q(d) } DtType(d) == class._module.Tuple ==> _module.Tuple.Pair_q(d));

const unique class._module.__default: ClassName;

// function declaration for _module._default.GetSt
function _module.__default.GetSt($heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType) : BoxType;

function _module.__default.GetSt#canCall($heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType) : bool;

// frame axiom for _module.__default.GetSt
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.GetSt($h1, this, p#0, st#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.GetSt#canCall($h0, this, p#0, st#1) || (DtAlloc(p#0, $h0) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $h0))) && (_module.__default.GetSt#canCall($h1, this, p#0, st#1) || (DtAlloc(p#0, $h1) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.GetSt($h0, this, p#0, st#1) == _module.__default.GetSt($h1, this, p#0, st#1));

// consequence axiom for _module.__default.GetSt
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 1 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType :: { _module.__default.GetSt($Heap, this, p#0, st#1) } _module.__default.GetSt#canCall($Heap, this, p#0, st#1) || ((0 != $ModuleContextHeight || 1 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $Heap)) ==> GenericAlloc(_module.__default.GetSt($Heap, this, p#0, st#1), $Heap));

procedure CheckWellformed$$_module.__default.GetSt(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, p#0: DatatypeType where DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path, st#1: BoxType where GenericAlloc(st#1, $Heap));
  free requires 0 == $ModuleContextHeight && 1 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.GetSt(this: ref, p#0: DatatypeType, st#1: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(4,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.GetSt($Heap, this, p#0, st#1), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.SetSt
function _module.__default.SetSt($heap: HeapType, this: ref, p#0: DatatypeType, a#1: BoxType, st#2: BoxType) : BoxType;

function _module.__default.SetSt#canCall($heap: HeapType, this: ref, p#0: DatatypeType, a#1: BoxType, st#2: BoxType) : bool;

// frame axiom for _module.__default.SetSt
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, p#0: DatatypeType, a#1: BoxType, st#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.SetSt($h1, this, p#0, a#1, st#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.SetSt#canCall($h0, this, p#0, a#1, st#2) || (DtAlloc(p#0, $h0) && DtType(p#0) == class._module.Path && GenericAlloc(a#1, $h0) && GenericAlloc(st#2, $h0))) && (_module.__default.SetSt#canCall($h1, this, p#0, a#1, st#2) || (DtAlloc(p#0, $h1) && DtType(p#0) == class._module.Path && GenericAlloc(a#1, $h1) && GenericAlloc(st#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.SetSt($h0, this, p#0, a#1, st#2) == _module.__default.SetSt($h1, this, p#0, a#1, st#2));

// consequence axiom for _module.__default.SetSt
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 48 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, p#0: DatatypeType, a#1: BoxType, st#2: BoxType :: { _module.__default.SetSt($Heap, this, p#0, a#1, st#2) } _module.__default.SetSt#canCall($Heap, this, p#0, a#1, st#2) || ((0 != $ModuleContextHeight || 48 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path && GenericAlloc(a#1, $Heap) && GenericAlloc(st#2, $Heap)) ==> GenericAlloc(_module.__default.SetSt($Heap, this, p#0, a#1, st#2), $Heap));

procedure CheckWellformed$$_module.__default.SetSt(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, p#0: DatatypeType where DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path, a#1: BoxType where GenericAlloc(a#1, $Heap), st#2: BoxType where GenericAlloc(st#2, $Heap));
  free requires 0 == $ModuleContextHeight && 48 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.SetSt(this: ref, p#0: DatatypeType, a#1: BoxType, st#2: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(5,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.SetSt($Heap, this, p#0, a#1, st#2), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.DomSt
function _module.__default.DomSt($heap: HeapType, this: ref, st#0: BoxType) : Set BoxType;

function _module.__default.DomSt#canCall($heap: HeapType, this: ref, st#0: BoxType) : bool;

// frame axiom for _module.__default.DomSt
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, st#0: BoxType :: { $HeapSucc($h0, $h1), _module.__default.DomSt($h1, this, st#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.DomSt#canCall($h0, this, st#0) || GenericAlloc(st#0, $h0)) && (_module.__default.DomSt#canCall($h1, this, st#0) || GenericAlloc(st#0, $h1)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.DomSt($h0, this, st#0) == _module.__default.DomSt($h1, this, st#0));

// consequence axiom for _module.__default.DomSt
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 0 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, st#0: BoxType :: { _module.__default.DomSt($Heap, this, st#0) } _module.__default.DomSt#canCall($Heap, this, st#0) || ((0 != $ModuleContextHeight || 0 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(st#0, $Heap)) ==> (forall $t#238: BoxType :: { _module.__default.DomSt($Heap, this, st#0)[$t#238] } _module.__default.DomSt($Heap, this, st#0)[$t#238] ==> DtAlloc($Unbox($t#238): DatatypeType, $Heap) && DtType($Unbox($t#238): DatatypeType) == class._module.Path));

procedure CheckWellformed$$_module.__default.DomSt(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, st#0: BoxType where GenericAlloc(st#0, $Heap));
  free requires 0 == $ModuleContextHeight && 0 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.DomSt(this: ref, st#0: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(7,10): initial state"} true;
    if (*)
    {
        assume (forall $t#239: BoxType :: { _module.__default.DomSt($Heap, this, st#0)[$t#239] } _module.__default.DomSt($Heap, this, st#0)[$t#239] ==> DtAlloc($Unbox($t#239): DatatypeType, $Heap) && DtType($Unbox($t#239): DatatypeType) == class._module.Path);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.Restrict
function _module.__default.Restrict($ly: LayerType, $heap: HeapType, this: ref, paths#0: Set BoxType, st#1: BoxType) : BoxType;

function _module.__default.Restrict#canCall($heap: HeapType, this: ref, paths#0: Set BoxType, st#1: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, paths#0: Set BoxType, st#1: BoxType :: { _module.__default.Restrict($LS($ly), $Heap, this, paths#0, st#1) } _module.__default.Restrict($LS($ly), $Heap, this, paths#0, st#1) == _module.__default.Restrict($ly, $Heap, this, paths#0, st#1));

// frame axiom for _module.__default.Restrict
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, paths#0: Set BoxType, st#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Restrict($ly, $h1, this, paths#0, st#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Restrict#canCall($h0, this, paths#0, st#1) || ((forall $t#240: BoxType :: { paths#0[$t#240] } paths#0[$t#240] ==> DtAlloc($Unbox($t#240): DatatypeType, $h0) && DtType($Unbox($t#240): DatatypeType) == class._module.Path) && GenericAlloc(st#1, $h0))) && (_module.__default.Restrict#canCall($h1, this, paths#0, st#1) || ((forall $t#241: BoxType :: { paths#0[$t#241] } paths#0[$t#241] ==> DtAlloc($Unbox($t#241): DatatypeType, $h1) && DtType($Unbox($t#241): DatatypeType) == class._module.Path) && GenericAlloc(st#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Restrict($ly, $h0, this, paths#0, st#1) == _module.__default.Restrict($ly, $h1, this, paths#0, st#1));

// consequence axiom for _module.__default.Restrict
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 2 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, paths#0: Set BoxType, st#1: BoxType :: { _module.__default.Restrict($LS($ly), $Heap, this, paths#0, st#1) } _module.__default.Restrict#canCall($Heap, this, paths#0, st#1) || ((0 != $ModuleContextHeight || 2 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#242: BoxType :: { paths#0[$t#242] } paths#0[$t#242] ==> DtAlloc($Unbox($t#242): DatatypeType, $Heap) && DtType($Unbox($t#242): DatatypeType) == class._module.Path) && GenericAlloc(st#1, $Heap) && Set#Subset(paths#0, _module.__default.DomSt($Heap, this, st#1))) ==> Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1)), paths#0) && (forall p#2: DatatypeType :: DtAlloc(p#2, $Heap) && DtType(p#2) == class._module.Path ==> paths#0[$Box(p#2)] ==> _module.__default.GetSt($Heap, this, p#2, st#1) == _module.__default.GetSt($Heap, this, p#2, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1))) && GenericAlloc(_module.__default.Restrict($LS($ly), $Heap, this, paths#0, st#1), $Heap));

procedure CheckWellformed$$_module.__default.Restrict(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, paths#0: Set BoxType where (forall $t#243: BoxType :: { paths#0[$t#243] } paths#0[$t#243] ==> DtAlloc($Unbox($t#243): DatatypeType, $Heap) && DtType($Unbox($t#243): DatatypeType) == class._module.Path), st#1: BoxType where GenericAlloc(st#1, $Heap));
  free requires 0 == $ModuleContextHeight && 2 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1)), paths#0);
  ensures (forall p#3: DatatypeType :: DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> paths#0[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, st#1) == _module.__default.GetSt($Heap, this, p#3, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1)));



implementation CheckWellformed$$_module.__default.Restrict(this: ref, paths#0: Set BoxType, st#1: BoxType)
{
  var st#4: BoxType;
  var st'#5: BoxType;
  var paths#6: Set BoxType;
  var st#7: BoxType;
  var st#8: BoxType;
  var p#9: DatatypeType;
  var p#10: DatatypeType;
  var st#11: BoxType;
  var p#12: DatatypeType;
  var st#13: BoxType;

    assume {:captureState "CachedBuilds0.dfy(9,10): initial state"} true;
    st#4 := st#1;
    assume _module.__default.DomSt#canCall($Heap, this, st#1);
    assume Set#Subset(paths#0, _module.__default.DomSt($Heap, this, st#1));
    if (*)
    {
        assume GenericAlloc(_module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1), $Heap);
        paths#6 := paths#0;
        st#7 := st#1;
        assert Set#Subset(paths#6, _module.__default.DomSt($Heap, this, st#7));
        assert (this == this && paths#0 == paths#0 && st#1 == st#1) || (Set#Subset(paths#6, paths#0) && !Set#Subset(paths#0, paths#6));
        assume (this == this && paths#0 == paths#0 && st#1 == st#1) || _module.__default.Restrict#canCall($Heap, this, paths#0, st#1);
        assume st'#5 == _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1);
        assume _module.__default.Restrict#canCall($Heap, this, paths#0, st#1);
        st#8 := st'#5;
        assume _module.__default.DomSt#canCall($Heap, this, st'#5);
        if (Set#Equal(_module.__default.DomSt($Heap, this, st'#5), paths#0))
        {
            havoc p#9;
            assume DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path;
            if (paths#0[$Box(p#9)])
            {
                p#10 := p#9;
                st#11 := st#1;
                assume _module.__default.GetSt#canCall($Heap, this, p#9, st#1);
                p#12 := p#9;
                st#13 := st'#5;
                assume _module.__default.GetSt#canCall($Heap, this, p#9, st'#5);
            }
        }

        assume Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1)), paths#0) && (forall p#14: DatatypeType :: DtAlloc(p#14, $Heap) && DtType(p#14) == class._module.Path ==> paths#0[$Box(p#14)] ==> _module.__default.GetSt($Heap, this, p#14, st#1) == _module.__default.GetSt($Heap, this, p#14, _module.__default.Restrict($LS($LZ), $Heap, this, paths#0, st#1)));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.Union
function _module.__default.Union($ly: LayerType, $heap: HeapType, this: ref, st#0: BoxType, st'#1: BoxType) : BoxType;

function _module.__default.Union#canCall($heap: HeapType, this: ref, st#0: BoxType, st'#1: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, st#0: BoxType, st'#1: BoxType :: { _module.__default.Union($LS($ly), $Heap, this, st#0, st'#1) } _module.__default.Union($LS($ly), $Heap, this, st#0, st'#1) == _module.__default.Union($ly, $Heap, this, st#0, st'#1));

// frame axiom for _module.__default.Union
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, st#0: BoxType, st'#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Union($ly, $h1, this, st#0, st'#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Union#canCall($h0, this, st#0, st'#1) || (GenericAlloc(st#0, $h0) && GenericAlloc(st'#1, $h0))) && (_module.__default.Union#canCall($h1, this, st#0, st'#1) || (GenericAlloc(st#0, $h1) && GenericAlloc(st'#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Union($ly, $h0, this, st#0, st'#1) == _module.__default.Union($ly, $h1, this, st#0, st'#1));

// consequence axiom for _module.__default.Union
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 3 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, st#0: BoxType, st'#1: BoxType :: { _module.__default.Union($LS($ly), $Heap, this, st#0, st'#1) } _module.__default.Union#canCall($Heap, this, st#0, st'#1) || ((0 != $ModuleContextHeight || 3 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(st#0, $Heap) && GenericAlloc(st'#1, $Heap)) ==> Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)), Set#Union(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1))) && (forall p#2: DatatypeType :: DtAlloc(p#2, $Heap) && DtType(p#2) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1))[$Box(p#2)] ==> (_module.__default.DomSt($Heap, this, st#0)[$Box(p#2)] ==> _module.__default.GetSt($Heap, this, p#2, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#2, st#0)) && (_module.__default.DomSt($Heap, this, st'#1)[$Box(p#2)] ==> _module.__default.GetSt($Heap, this, p#2, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#2, st'#1))) && GenericAlloc(_module.__default.Union($LS($ly), $Heap, this, st#0, st'#1), $Heap));

procedure CheckWellformed$$_module.__default.Union(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, st#0: BoxType where GenericAlloc(st#0, $Heap), st'#1: BoxType where GenericAlloc(st'#1, $Heap));
  free requires 0 == $ModuleContextHeight && 3 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)), Set#Union(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1)));
  ensures (forall p#3: DatatypeType :: DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1))[$Box(p#3)] ==> (_module.__default.DomSt($Heap, this, st#0)[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#3, st#0)) && (_module.__default.DomSt($Heap, this, st'#1)[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#3, st'#1)));



implementation CheckWellformed$$_module.__default.Union(this: ref, st#0: BoxType, st'#1: BoxType)
{
  var result#4: BoxType;
  var st#5: BoxType;
  var st'#6: BoxType;
  var st#7: BoxType;
  var st#8: BoxType;
  var st#9: BoxType;
  var p#10: DatatypeType;
  var st#11: BoxType;
  var st#12: BoxType;
  var p#13: DatatypeType;
  var st#14: BoxType;
  var p#15: DatatypeType;
  var st#16: BoxType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var p#20: DatatypeType;
  var st#21: BoxType;

    assume {:captureState "CachedBuilds0.dfy(15,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1), $Heap);
        st#5 := st#0;
        st'#6 := st'#1;
        assert this == this && st#0 == st#0 && st'#1 == st'#1;
        assume (this == this && st#0 == st#0 && st'#1 == st'#1) || _module.__default.Union#canCall($Heap, this, st#0, st'#1);
        assume result#4 == _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1);
        assume _module.__default.Union#canCall($Heap, this, st#0, st'#1);
        st#7 := result#4;
        assume _module.__default.DomSt#canCall($Heap, this, result#4);
        st#8 := st#0;
        assume _module.__default.DomSt#canCall($Heap, this, st#0);
        st#9 := st'#1;
        assume _module.__default.DomSt#canCall($Heap, this, st'#1);
        if (Set#Equal(_module.__default.DomSt($Heap, this, result#4), Set#Union(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1))))
        {
            havoc p#10;
            assume DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path;
            st#11 := result#4;
            assume _module.__default.DomSt#canCall($Heap, this, result#4);
            if (_module.__default.DomSt($Heap, this, result#4)[$Box(p#10)])
            {
                st#12 := st#0;
                assume _module.__default.DomSt#canCall($Heap, this, st#0);
                if (_module.__default.DomSt($Heap, this, st#0)[$Box(p#10)])
                {
                    p#13 := p#10;
                    st#14 := result#4;
                    assume _module.__default.GetSt#canCall($Heap, this, p#10, result#4);
                    p#15 := p#10;
                    st#16 := st#0;
                    assume _module.__default.GetSt#canCall($Heap, this, p#10, st#0);
                }

                if (_module.__default.DomSt($Heap, this, st#0)[$Box(p#10)] ==> _module.__default.GetSt($Heap, this, p#10, result#4) == _module.__default.GetSt($Heap, this, p#10, st#0))
                {
                    st#17 := st'#1;
                    assume _module.__default.DomSt#canCall($Heap, this, st'#1);
                    if (_module.__default.DomSt($Heap, this, st'#1)[$Box(p#10)])
                    {
                        p#18 := p#10;
                        st#19 := result#4;
                        assume _module.__default.GetSt#canCall($Heap, this, p#10, result#4);
                        p#20 := p#10;
                        st#21 := st'#1;
                        assume _module.__default.GetSt#canCall($Heap, this, p#10, st'#1);
                    }
                }
            }
        }

        assume Set#Equal(_module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)), Set#Union(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1))) && (forall p#22: DatatypeType :: DtAlloc(p#22, $Heap) && DtType(p#22) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1))[$Box(p#22)] ==> (_module.__default.DomSt($Heap, this, st#0)[$Box(p#22)] ==> _module.__default.GetSt($Heap, this, p#22, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#22, st#0)) && (_module.__default.DomSt($Heap, this, st'#1)[$Box(p#22)] ==> _module.__default.GetSt($Heap, this, p#22, _module.__default.Union($LS($LZ), $Heap, this, st#0, st'#1)) == _module.__default.GetSt($Heap, this, p#22, st'#1)));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.Compatible
function _module.__default.Compatible($heap: HeapType, this: ref, sts#0: Set BoxType) : bool;

function _module.__default.Compatible#canCall($heap: HeapType, this: ref, sts#0: Set BoxType) : bool;

// frame axiom for _module.__default.Compatible
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, sts#0: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.Compatible($h1, this, sts#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Compatible#canCall($h0, this, sts#0) || (forall $t#244: BoxType :: { sts#0[$t#244] } sts#0[$t#244] ==> GenericAlloc($t#244, $h0))) && (_module.__default.Compatible#canCall($h1, this, sts#0) || (forall $t#245: BoxType :: { sts#0[$t#245] } sts#0[$t#245] ==> GenericAlloc($t#245, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Compatible($h0, this, sts#0) == _module.__default.Compatible($h1, this, sts#0));

// consequence axiom for _module.__default.Compatible
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 4 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Compatible($Heap, this, sts#0) } _module.__default.Compatible#canCall($Heap, this, sts#0) || ((0 != $ModuleContextHeight || 4 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#246: BoxType :: { sts#0[$t#246] } sts#0[$t#246] ==> GenericAlloc($t#246, $Heap))) ==> true);

// definition axiom for _module.__default.Compatible (intra-module)
axiom 0 == $ModuleContextHeight && 4 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Compatible($Heap, this, sts#0) } _module.__default.Compatible#canCall($Heap, this, sts#0) || (4 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#247: BoxType :: { sts#0[$t#247] } sts#0[$t#247] ==> GenericAlloc($t#247, $Heap))) ==> (forall st#1: BoxType, st'#2: BoxType, p#3: DatatypeType :: GenericAlloc(st#1, $Heap) && GenericAlloc(st'#2, $Heap) && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> (sts#0[st#1] ==> true) && (sts#0[st#1] && sts#0[st'#2] ==> _module.__default.DomSt#canCall($Heap, this, st#1)) && (sts#0[st#1] && sts#0[st'#2] && _module.__default.DomSt($Heap, this, st#1)[$Box(p#3)] ==> _module.__default.DomSt#canCall($Heap, this, st'#2)) && (sts#0[st#1] && sts#0[st'#2] && _module.__default.DomSt($Heap, this, st#1)[$Box(p#3)] && _module.__default.DomSt($Heap, this, st'#2)[$Box(p#3)] ==> _module.__default.GetSt#canCall($Heap, this, p#3, st#1) && _module.__default.GetSt#canCall($Heap, this, p#3, st'#2))) && _module.__default.Compatible($Heap, this, sts#0) == (forall st#1: BoxType, st'#2: BoxType, p#3: DatatypeType :: GenericAlloc(st#1, $Heap) && GenericAlloc(st'#2, $Heap) && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> sts#0[st#1] && sts#0[st'#2] && _module.__default.DomSt($Heap, this, st#1)[$Box(p#3)] && _module.__default.DomSt($Heap, this, st'#2)[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, st#1) == _module.__default.GetSt($Heap, this, p#3, st'#2)));

// definition axiom for _module.__default.Compatible for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 4 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, sts#0: Set BoxType :: {:weight 10} { _module.__default.Compatible($Heap, this, Lit(sts#0)) } _module.__default.Compatible#canCall($Heap, this, Lit(sts#0)) || (4 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> (forall st#4: BoxType, st'#5: BoxType, p#6: DatatypeType :: GenericAlloc(st#4, $Heap) && GenericAlloc(st'#5, $Heap) && DtAlloc(p#6, $Heap) && DtType(p#6) == class._module.Path ==> (Lit(sts#0)[st#4] ==> true) && (Lit(sts#0)[st#4] && Lit(sts#0)[st'#5] ==> _module.__default.DomSt#canCall($Heap, this, st#4)) && (Lit(sts#0)[st#4] && Lit(sts#0)[st'#5] && _module.__default.DomSt($Heap, this, st#4)[$Box(p#6)] ==> _module.__default.DomSt#canCall($Heap, this, st'#5)) && (Lit(sts#0)[st#4] && Lit(sts#0)[st'#5] && _module.__default.DomSt($Heap, this, st#4)[$Box(p#6)] && _module.__default.DomSt($Heap, this, st'#5)[$Box(p#6)] ==> _module.__default.GetSt#canCall($Heap, this, p#6, st#4) && _module.__default.GetSt#canCall($Heap, this, p#6, st'#5))) && _module.__default.Compatible($Heap, this, Lit(sts#0)) == (forall st#4: BoxType, st'#5: BoxType, p#6: DatatypeType :: GenericAlloc(st#4, $Heap) && GenericAlloc(st'#5, $Heap) && DtAlloc(p#6, $Heap) && DtType(p#6) == class._module.Path ==> Lit(sts#0)[st#4] && Lit(sts#0)[st'#5] && _module.__default.DomSt($Heap, this, st#4)[$Box(p#6)] && _module.__default.DomSt($Heap, this, st'#5)[$Box(p#6)] ==> _module.__default.GetSt($Heap, this, p#6, st#4) == _module.__default.GetSt($Heap, this, p#6, st'#5)));

// definition axiom for _module.__default.Compatible (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Compatible($Heap, this, sts#0) } _module.__default.Compatible#canCall($Heap, this, sts#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#248: BoxType :: { sts#0[$t#248] } sts#0[$t#248] ==> GenericAlloc($t#248, $Heap))) ==> true);

// definition axiom for _module.__default.Compatible for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, sts#0: Set BoxType :: {:weight 10} { _module.__default.Compatible($Heap, this, Lit(sts#0)) } _module.__default.Compatible#canCall($Heap, this, Lit(sts#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.Compatible(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, sts#0: Set BoxType where (forall $t#249: BoxType :: { sts#0[$t#249] } sts#0[$t#249] ==> GenericAlloc($t#249, $Heap)));
  free requires 0 == $ModuleContextHeight && 4 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Compatible(this: ref, sts#0: Set BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var st#7: BoxType;
  var st'#8: BoxType;
  var p#9: DatatypeType;
  var st#10: BoxType;
  var st#11: BoxType;
  var p#12: DatatypeType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;

    assume {:captureState "CachedBuilds0.dfy(23,11): initial state"} true;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc st#7;
        assume GenericAlloc(st#7, $Heap);
        havoc st'#8;
        assume GenericAlloc(st'#8, $Heap);
        havoc p#9;
        assume DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path;
        if (sts#0[st#7])
        {
        }

        if (sts#0[st#7] && sts#0[st'#8])
        {
            st#10 := st#7;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, st#7);
        }

        if (sts#0[st#7] && sts#0[st'#8] && _module.__default.DomSt($Heap, this, st#7)[$Box(p#9)])
        {
            st#11 := st'#8;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (sts#0[st#7] && sts#0[st'#8] && _module.__default.DomSt($Heap, this, st#7)[$Box(p#9)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#9)])
        {
            p#12 := p#9;
            st#13 := st#7;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.GetSt#canCall($Heap, this, p#9, st#7);
            p#14 := p#9;
            st#15 := st'#8;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.GetSt#canCall($Heap, this, p#9, st'#8);
        }

        assume _module.__default.Compatible($Heap, this, sts#0) == (forall st#16: BoxType, st'#17: BoxType, p#18: DatatypeType :: GenericAlloc(st#16, $Heap) && GenericAlloc(st'#17, $Heap) && DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path ==> sts#0[st#16] && sts#0[st'#17] && _module.__default.DomSt($Heap, this, st#16)[$Box(p#18)] && _module.__default.DomSt($Heap, this, st'#17)[$Box(p#18)] ==> _module.__default.GetSt($Heap, this, p#18, st#16) == _module.__default.GetSt($Heap, this, p#18, st'#17));
        assume (forall st#16: BoxType, st'#17: BoxType, p#18: DatatypeType :: GenericAlloc(st#16, $Heap) && GenericAlloc(st'#17, $Heap) && DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path ==> (sts#0[st#16] ==> true) && (sts#0[st#16] && sts#0[st'#17] ==> _module.__default.DomSt#canCall($Heap, this, st#16)) && (sts#0[st#16] && sts#0[st'#17] && _module.__default.DomSt($Heap, this, st#16)[$Box(p#18)] ==> _module.__default.DomSt#canCall($Heap, this, st'#17)) && (sts#0[st#16] && sts#0[st'#17] && _module.__default.DomSt($Heap, this, st#16)[$Box(p#18)] && _module.__default.DomSt($Heap, this, st'#17)[$Box(p#18)] ==> _module.__default.GetSt#canCall($Heap, this, p#18, st#16) && _module.__default.GetSt#canCall($Heap, this, p#18, st'#17)));
    }
}



// function declaration for _module._default.Combine
function _module.__default.Combine($ly: LayerType, $heap: HeapType, this: ref, sts#0: Set BoxType) : BoxType;

function _module.__default.Combine#canCall($heap: HeapType, this: ref, sts#0: Set BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Combine($LS($ly), $Heap, this, sts#0) } _module.__default.Combine($LS($ly), $Heap, this, sts#0) == _module.__default.Combine($ly, $Heap, this, sts#0));

// frame axiom for _module.__default.Combine
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, sts#0: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.Combine($ly, $h1, this, sts#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Combine#canCall($h0, this, sts#0) || (forall $t#250: BoxType :: { sts#0[$t#250] } sts#0[$t#250] ==> GenericAlloc($t#250, $h0))) && (_module.__default.Combine#canCall($h1, this, sts#0) || (forall $t#251: BoxType :: { sts#0[$t#251] } sts#0[$t#251] ==> GenericAlloc($t#251, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Combine($ly, $h0, this, sts#0) == _module.__default.Combine($ly, $h1, this, sts#0));

// consequence axiom for _module.__default.Combine
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 5 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Combine($LS($ly), $Heap, this, sts#0) } _module.__default.Combine#canCall($Heap, this, sts#0) || ((0 != $ModuleContextHeight || 5 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#252: BoxType :: { sts#0[$t#252] } sts#0[$t#252] ==> GenericAlloc($t#252, $Heap)) && !Set#Equal(sts#0, Set#Empty(): Set BoxType)) ==> (forall st#1: BoxType :: GenericAlloc(st#1, $Heap) ==> sts#0[st#1] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0)))) && (forall st#2: BoxType, p#3: DatatypeType :: GenericAlloc(st#2, $Heap) && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> sts#0[st#2] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, st#2) == _module.__default.GetSt($Heap, this, p#3, _module.__default.Combine($LS($LZ), $Heap, this, sts#0))) && (forall p#4: DatatypeType :: DtAlloc(p#4, $Heap) && DtType(p#4) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0))[$Box(p#4)] ==> (exists st#5: BoxType :: GenericAlloc(st#5, $Heap) && sts#0[st#5] && _module.__default.DomSt($Heap, this, st#5)[$Box(p#4)])) && GenericAlloc(_module.__default.Combine($LS($ly), $Heap, this, sts#0), $Heap));

function $let#0_st($heap: HeapType, sts: Set BoxType) : BoxType;

function $let#0$canCall($heap: HeapType, sts: Set BoxType) : bool;

axiom (forall $heap: HeapType, sts: Set BoxType :: { $let#0_st($heap, sts) } $let#0$canCall($heap, sts) ==> sts[$let#0_st($heap, sts)]);

// definition axiom for _module.__default.Combine (intra-module)
axiom 0 == $ModuleContextHeight && 5 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Combine($LS($ly), $Heap, this, sts#0) } _module.__default.Combine#canCall($Heap, this, sts#0) || (5 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#253: BoxType :: { sts#0[$t#253] } sts#0[$t#253] ==> GenericAlloc($t#253, $Heap)) && !Set#Equal(sts#0, Set#Empty(): Set BoxType)) ==> (forall st#6: BoxType :: GenericAlloc(st#6, $Heap) ==> (sts#0[st#6] ==> (Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)) ==> true) && (!Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)) ==> _module.__default.Combine#canCall($Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6))) && _module.__default.Union#canCall($Heap, this, st#6, _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)))))) && $let#0$canCall($Heap, sts#0)) && _module.__default.Combine($LS($ly), $Heap, this, sts#0) == (if Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, $let#0_st($Heap, sts#0))) then $let#0_st($Heap, sts#0) else _module.__default.Union($LS($LZ), $Heap, this, $let#0_st($Heap, sts#0), _module.__default.Combine($ly, $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, $let#0_st($Heap, sts#0)))))));

// definition axiom for _module.__default.Combine for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 5 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: {:weight 10} { _module.__default.Combine($ly, $Heap, this, Lit(sts#0)) } _module.__default.Combine#canCall($Heap, this, Lit(sts#0)) || (5 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && !Set#Equal(sts#0, Set#Empty(): Set BoxType)) ==> (forall st#6: BoxType :: GenericAlloc(st#6, $Heap) ==> (Lit(sts#0)[st#6] ==> (Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)) ==> true) && (!Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)) ==> _module.__default.Combine#canCall($Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6))) && _module.__default.Union#canCall($Heap, this, st#6, _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#6)))))) && $let#0$canCall($Heap, Lit(sts#0))) && _module.__default.Combine($ly, $Heap, this, Lit(sts#0)) == (if Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, $let#0_st($Heap, Lit(sts#0)))) then $let#0_st($Heap, Lit(sts#0)) else _module.__default.Union($LS($LZ), $Heap, this, $let#0_st($Heap, Lit(sts#0)), _module.__default.Combine($ly, $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, $let#0_st($Heap, Lit(sts#0))))))));

// definition axiom for _module.__default.Combine (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: { _module.__default.Combine($LS($ly), $Heap, this, sts#0) } _module.__default.Combine#canCall($Heap, this, sts#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#255: BoxType :: { sts#0[$t#255] } sts#0[$t#255] ==> GenericAlloc($t#255, $Heap)) && !Set#Equal(sts#0, Set#Empty(): Set BoxType)) ==> true);

// definition axiom for _module.__default.Combine for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, sts#0: Set BoxType :: {:weight 10} { _module.__default.Combine($ly, $Heap, this, Lit(sts#0)) } _module.__default.Combine#canCall($Heap, this, Lit(sts#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && !Set#Equal(sts#0, Set#Empty(): Set BoxType)) ==> true);

procedure CheckWellformed$$_module.__default.Combine(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, sts#0: Set BoxType where (forall $t#256: BoxType :: { sts#0[$t#256] } sts#0[$t#256] ==> GenericAlloc($t#256, $Heap)));
  free requires 0 == $ModuleContextHeight && 5 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures (forall st#7: BoxType :: GenericAlloc(st#7, $Heap) ==> sts#0[st#7] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#7), _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LS($LZ)), $Heap, this, sts#0))));
  ensures (forall st#8: BoxType, p#9: DatatypeType :: GenericAlloc(st#8, $Heap) && DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path ==> sts#0[st#8] && _module.__default.DomSt($Heap, this, st#8)[$Box(p#9)] ==> _module.__default.GetSt($Heap, this, p#9, st#8) == _module.__default.GetSt($Heap, this, p#9, _module.__default.Combine($LS($LS($LZ)), $Heap, this, sts#0)));
  ensures (forall p#10: DatatypeType :: DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LS($LZ)), $Heap, this, sts#0))[$Box(p#10)] ==> (exists st#11: BoxType :: GenericAlloc(st#11, $Heap) && sts#0[st#11] && _module.__default.DomSt($Heap, this, st#11)[$Box(p#10)]));



implementation CheckWellformed$$_module.__default.Combine(this: ref, sts#0: Set BoxType)
{
  var st#12: BoxType;
  var st#13: BoxType;
  var sts#14: Set BoxType;
  var st#15: BoxType;
  var st#16: BoxType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var p#19: DatatypeType;
  var st#20: BoxType;
  var sts#21: Set BoxType;
  var p#22: DatatypeType;
  var st#23: BoxType;
  var p#24: DatatypeType;
  var sts#25: Set BoxType;
  var st#26: BoxType;
  var st#27: BoxType;
  var st#28: BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var st#29: BoxType;
  var sts#30: Set BoxType;
  var st#31: BoxType;
  var st'#32: BoxType;

    assume {:captureState "CachedBuilds0.dfy(29,10): initial state"} true;
    assume !Set#Equal(sts#0, Set#Empty(): Set BoxType);
    if (*)
    {
        assume GenericAlloc(_module.__default.Combine($LS($LZ), $Heap, this, sts#0), $Heap);
        havoc st#12;
        assume GenericAlloc(st#12, $Heap);
        if (sts#0[st#12])
        {
            st#13 := st#12;
            assume _module.__default.DomSt#canCall($Heap, this, st#12);
            sts#14 := sts#0;
            assert !Set#Equal(sts#14, Set#Empty(): Set BoxType);
            assert (this == this && sts#0 == sts#0) || (Set#Subset(sts#14, sts#0) && !Set#Subset(sts#0, sts#14));
            assume (this == this && sts#0 == sts#0) || _module.__default.Combine#canCall($Heap, this, sts#0);
            st#15 := _module.__default.Combine($LS($LZ), $Heap, this, sts#0);
            assume _module.__default.DomSt#canCall($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0));
        }

        assume (forall st#7: BoxType :: GenericAlloc(st#7, $Heap) ==> sts#0[st#7] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#7), _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0))));
        havoc st#16;
        assume GenericAlloc(st#16, $Heap);
        havoc p#17;
        assume DtAlloc(p#17, $Heap) && DtType(p#17) == class._module.Path;
        if (sts#0[st#16])
        {
            st#18 := st#16;
            assume _module.__default.DomSt#canCall($Heap, this, st#16);
        }

        if (sts#0[st#16] && _module.__default.DomSt($Heap, this, st#16)[$Box(p#17)])
        {
            p#19 := p#17;
            st#20 := st#16;
            assume _module.__default.GetSt#canCall($Heap, this, p#17, st#16);
            sts#21 := sts#0;
            assert !Set#Equal(sts#21, Set#Empty(): Set BoxType);
            assert (this == this && sts#0 == sts#0) || (Set#Subset(sts#21, sts#0) && !Set#Subset(sts#0, sts#21));
            assume (this == this && sts#0 == sts#0) || _module.__default.Combine#canCall($Heap, this, sts#0);
            p#22 := p#17;
            st#23 := _module.__default.Combine($LS($LZ), $Heap, this, sts#0);
            assume _module.__default.GetSt#canCall($Heap, this, p#17, _module.__default.Combine($LS($LZ), $Heap, this, sts#0));
        }

        assume (forall st#8: BoxType, p#9: DatatypeType :: GenericAlloc(st#8, $Heap) && DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path ==> sts#0[st#8] && _module.__default.DomSt($Heap, this, st#8)[$Box(p#9)] ==> _module.__default.GetSt($Heap, this, p#9, st#8) == _module.__default.GetSt($Heap, this, p#9, _module.__default.Combine($LS($LZ), $Heap, this, sts#0)));
        havoc p#24;
        assume DtAlloc(p#24, $Heap) && DtType(p#24) == class._module.Path;
        sts#25 := sts#0;
        assert !Set#Equal(sts#25, Set#Empty(): Set BoxType);
        assert (this == this && sts#0 == sts#0) || (Set#Subset(sts#25, sts#0) && !Set#Subset(sts#0, sts#25));
        assume (this == this && sts#0 == sts#0) || _module.__default.Combine#canCall($Heap, this, sts#0);
        st#26 := _module.__default.Combine($LS($LZ), $Heap, this, sts#0);
        assume _module.__default.DomSt#canCall($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0));
        if (_module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0))[$Box(p#24)])
        {
            havoc st#27;
            assume GenericAlloc(st#27, $Heap);
            if (sts#0[st#27])
            {
                st#28 := st#27;
                assume _module.__default.DomSt#canCall($Heap, this, st#27);
            }
        }

        assume (forall p#10: DatatypeType :: DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.__default.Combine($LS($LZ), $Heap, this, sts#0))[$Box(p#10)] ==> (exists st#11: BoxType :: GenericAlloc(st#11, $Heap) && sts#0[st#11] && _module.__default.DomSt($Heap, this, st#11)[$Box(p#10)]));
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc st#29;
        assume GenericAlloc(st#29, $Heap);
        assert (exists st#6: BoxType :: GenericAlloc(st#6, $Heap) && sts#0[st#6]);
        assume sts#0[st#29];
        if (Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)))
        {
        }
        else
        {
            sts#30 := Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29));
            assert !Set#Equal(sts#30, Set#Empty(): Set BoxType);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert Set#Subset(sts#30, sts#0) && !Set#Subset(sts#0, sts#30);
            assume _module.__default.Combine#canCall($Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)));
            st#31 := st#29;
            st'#32 := _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)));
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Union#canCall($Heap, this, st#29, _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29))));
        }

        assume _module.__default.Combine($LS($LZ), $Heap, this, sts#0) == (if Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)) then st#29 else _module.__default.Union($LS($LZ), $Heap, this, st#29, _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)))));
        assume (Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)) ==> true) && (!Set#Equal(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)) ==> _module.__default.Combine#canCall($Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29))) && _module.__default.Union#canCall($Heap, this, st#29, _module.__default.Combine($LS($LZ), $Heap, this, Set#Difference(sts#0, Set#UnionOne(Set#Empty(): Set BoxType, st#29)))));
    }
}



procedure CheckWellformed$$_module.__default.StateEqualityProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, st#0: BoxType where GenericAlloc(st#0, $Heap), st'#1: BoxType where GenericAlloc(st'#1, $Heap));
  free requires 0 == $ModuleContextHeight && 6 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.StateEqualityProperty(this: ref, st#0: BoxType, st'#1: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var st#2: BoxType;
  var st#3: BoxType;
  var p#4: DatatypeType;
  var st#5: BoxType;
  var p#6: DatatypeType;
  var st#7: BoxType;
  var p#8: DatatypeType;
  var st#9: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(42,14): initial state"} true;
    st#2 := st#0;
    assume _module.__default.DomSt#canCall($Heap, this, st#0);
    st#3 := st'#1;
    assume _module.__default.DomSt#canCall($Heap, this, st'#1);
    assume Set#Equal(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1));
    havoc p#4;
    assume DtAlloc(p#4, $Heap) && DtType(p#4) == class._module.Path;
    st#5 := st#0;
    assume _module.__default.DomSt#canCall($Heap, this, st#0);
    if (_module.__default.DomSt($Heap, this, st#0)[$Box(p#4)])
    {
        p#6 := p#4;
        st#7 := st#0;
        assume _module.__default.GetSt#canCall($Heap, this, p#4, st#0);
        p#8 := p#4;
        st#9 := st'#1;
        assume _module.__default.GetSt#canCall($Heap, this, p#4, st'#1);
    }

    assume (forall p#10: DatatypeType :: DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#0)[$Box(p#10)] ==> _module.__default.GetSt($Heap, this, p#10, st#0) == _module.__default.GetSt($Heap, this, p#10, st'#1));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(45,14): post-state"} true;
    assume st#0 == st'#1;
}



procedure InterModuleCall$$_module.__default.StateEqualityProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, st#0: BoxType where GenericAlloc(st#0, $Heap), st'#1: BoxType where GenericAlloc(st'#1, $Heap));
  // user-defined preconditions
  requires Set#Equal(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1));
  requires (forall p#10: DatatypeType :: DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#0)[$Box(p#10)] ==> _module.__default.GetSt($Heap, this, p#10, st#0) == _module.__default.GetSt($Heap, this, p#10, st'#1));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures st#0 == st'#1;
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.StateEqualityProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, st#0: BoxType where GenericAlloc(st#0, $Heap), st'#1: BoxType where GenericAlloc(st'#1, $Heap));
  // user-defined preconditions
  requires Set#Equal(_module.__default.DomSt($Heap, this, st#0), _module.__default.DomSt($Heap, this, st'#1));
  requires (forall p#10: DatatypeType :: DtAlloc(p#10, $Heap) && DtType(p#10) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#0)[$Box(p#10)] ==> _module.__default.GetSt($Heap, this, p#10, st#0) == _module.__default.GetSt($Heap, this, p#10, st'#1));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures st#0 == st'#1;
  // frame condition
  free ensures old($Heap) == $Heap;



// function declaration for _module._default.GetC
function _module.__default.GetC($heap: HeapType, this: ref, h#0: BoxType, c#1: BoxType) : BoxType;

function _module.__default.GetC#canCall($heap: HeapType, this: ref, h#0: BoxType, c#1: BoxType) : bool;

// frame axiom for _module.__default.GetC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, h#0: BoxType, c#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.GetC($h1, this, h#0, c#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.GetC#canCall($h0, this, h#0, c#1) || (GenericAlloc(h#0, $h0) && GenericAlloc(c#1, $h0))) && (_module.__default.GetC#canCall($h1, this, h#0, c#1) || (GenericAlloc(h#0, $h1) && GenericAlloc(c#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.GetC($h0, this, h#0, c#1) == _module.__default.GetC($h1, this, h#0, c#1));

// consequence axiom for _module.__default.GetC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 11 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, h#0: BoxType, c#1: BoxType :: { _module.__default.GetC($Heap, this, h#0, c#1) } _module.__default.GetC#canCall($Heap, this, h#0, c#1) || ((0 != $ModuleContextHeight || 11 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(h#0, $Heap) && GenericAlloc(c#1, $Heap)) ==> GenericAlloc(_module.__default.GetC($Heap, this, h#0, c#1), $Heap));

procedure CheckWellformed$$_module.__default.GetC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, h#0: BoxType where GenericAlloc(h#0, $Heap), c#1: BoxType where GenericAlloc(c#1, $Heap));
  free requires 0 == $ModuleContextHeight && 11 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.GetC(this: ref, h#0: BoxType, c#1: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(50,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.GetC($Heap, this, h#0, c#1), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.UpdateC
function _module.__default.UpdateC($ly: LayerType, $heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : DatatypeType;

function _module.__default.UpdateC#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.UpdateC($LS($ly), $Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.UpdateC($LS($ly), $Heap, this, cmd#0, deps#1, exts#2, stC#3) == _module.__default.UpdateC($ly, $Heap, this, cmd#0, deps#1, exts#2, stC#3));

// frame axiom for _module.__default.UpdateC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.UpdateC($ly, $h1, this, cmd#0, deps#1, exts#2, stC#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.UpdateC#canCall($h0, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h0) && DtType(stC#3) == class._module.StateC)) && (_module.__default.UpdateC#canCall($h1, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h1) && DtType(stC#3) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.UpdateC($ly, $h0, this, cmd#0, deps#1, exts#2, stC#3) == _module.__default.UpdateC($ly, $h1, this, cmd#0, deps#1, exts#2, stC#3));

// consequence axiom for _module.__default.UpdateC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 10 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.UpdateC($LS($ly), $Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ((0 != $ModuleContextHeight || 10 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> _module.StateC.st(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)) == _module.StateC.st(stC#3) && (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))]) && DtAlloc(_module.__default.UpdateC($LS($ly), $Heap, this, cmd#0, deps#1, exts#2, stC#3), $Heap) && DtType(_module.__default.UpdateC($LS($ly), $Heap, this, cmd#0, deps#1, exts#2, stC#3)) == class._module.StateC);

procedure CheckWellformed$$_module.__default.UpdateC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 10 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures _module.StateC.st(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)) == _module.StateC.st(stC#3);
  ensures (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#5] ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#5))]);



implementation CheckWellformed$$_module.__default.UpdateC(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType)
{
  var stC'#6: DatatypeType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var exts#9: DatatypeType;
  var stC#10: DatatypeType;
  var e#11: BoxType;
  var cmd#12: DatatypeType;
  var deps#13: DatatypeType;
  var ext#14: BoxType;
  var p#15: DatatypeType;
  var c#16: BoxType;

    assume {:captureState "CachedBuilds0.dfy(52,10): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
    if (*)
    {
        assume DtAlloc(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3), $Heap) && DtType(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)) == class._module.StateC;
        cmd#7 := cmd#0;
        deps#8 := deps#1;
        exts#9 := exts#2;
        stC#10 := stC#3;
        assert _module.Expression.exprLiteral_q(cmd#7) && _module.Literal.litString_q(_module.Expression.lit(cmd#7)) && _module.Expression.exprLiteral_q(deps#8) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#8)) && _module.Expression.exprLiteral_q(exts#9) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#9));
        assert (this == this && cmd#0 == cmd#0 && deps#1 == deps#1 && exts#2 == exts#2 && stC#3 == stC#3) || DtRank(cmd#7) < DtRank(cmd#0) || (DtRank(cmd#7) == DtRank(cmd#0) && (DtRank(deps#8) < DtRank(deps#1) || (DtRank(deps#8) == DtRank(deps#1) && (DtRank(exts#9) < DtRank(exts#2) || (DtRank(exts#9) == DtRank(exts#2) && DtRank(stC#10) < DtRank(stC#3))))));
        assume (this == this && cmd#0 == cmd#0 && deps#1 == deps#1 && exts#2 == exts#2 && stC#3 == stC#3) || _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
        assume stC'#6 == _module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3);
        assume _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
        assume _module.StateC.S_q(stC'#6);
        assume _module.StateC.S_q(stC#3);
        if (_module.StateC.st(stC'#6) == _module.StateC.st(stC#3))
        {
            havoc e#11;
            assume GenericAlloc(e#11, $Heap);
            assert _module.Expression.exprLiteral_q(exts#2);
            assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
            if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#11])
            {
                cmd#12 := cmd#0;
                deps#13 := deps#1;
                ext#14 := e#11;
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#11);
                p#15 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#11);
                assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#11));
                assume _module.StateC.S_q(stC'#6);
                c#16 := _module.StateC.c(stC'#6);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#6));
            }
        }

        assume _module.StateC.st(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)) == _module.StateC.st(stC#3) && (forall e#17: BoxType :: GenericAlloc(e#17, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#17] ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#17))]);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.DomC
function _module.__default.DomC($heap: HeapType, this: ref, c#0: BoxType) : Set BoxType;

function _module.__default.DomC#canCall($heap: HeapType, this: ref, c#0: BoxType) : bool;

// frame axiom for _module.__default.DomC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, c#0: BoxType :: { $HeapSucc($h0, $h1), _module.__default.DomC($h1, this, c#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.DomC#canCall($h0, this, c#0) || GenericAlloc(c#0, $h0)) && (_module.__default.DomC#canCall($h1, this, c#0) || GenericAlloc(c#0, $h1)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.DomC($h0, this, c#0) == _module.__default.DomC($h1, this, c#0));

// consequence axiom for _module.__default.DomC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 9 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, c#0: BoxType :: { _module.__default.DomC($Heap, this, c#0) } _module.__default.DomC#canCall($Heap, this, c#0) || ((0 != $ModuleContextHeight || 9 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(c#0, $Heap)) ==> (forall $t#0: BoxType :: { _module.__default.DomC($Heap, this, c#0)[$t#0] } _module.__default.DomC($Heap, this, c#0)[$t#0] ==> GenericAlloc($t#0, $Heap)));

procedure CheckWellformed$$_module.__default.DomC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, c#0: BoxType where GenericAlloc(c#0, $Heap));
  free requires 0 == $ModuleContextHeight && 9 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.DomC(this: ref, c#0: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(62,10): initial state"} true;
    if (*)
    {
        assume (forall $t#1: BoxType :: { _module.__default.DomC($Heap, this, c#0)[$t#1] } _module.__default.DomC($Heap, this, c#0)[$t#1] ==> GenericAlloc($t#1, $Heap));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.UnionC
function _module.__default.UnionC($ly: LayerType, $heap: HeapType, this: ref, stC#0: DatatypeType, stC'#1: DatatypeType) : DatatypeType;

function _module.__default.UnionC#canCall($heap: HeapType, this: ref, stC#0: DatatypeType, stC'#1: DatatypeType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, stC#0: DatatypeType, stC'#1: DatatypeType :: { _module.__default.UnionC($LS($ly), $Heap, this, stC#0, stC'#1) } _module.__default.UnionC($LS($ly), $Heap, this, stC#0, stC'#1) == _module.__default.UnionC($ly, $Heap, this, stC#0, stC'#1));

// frame axiom for _module.__default.UnionC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, stC#0: DatatypeType, stC'#1: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.UnionC($ly, $h1, this, stC#0, stC'#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.UnionC#canCall($h0, this, stC#0, stC'#1) || (DtAlloc(stC#0, $h0) && DtType(stC#0) == class._module.StateC && DtAlloc(stC'#1, $h0) && DtType(stC'#1) == class._module.StateC)) && (_module.__default.UnionC#canCall($h1, this, stC#0, stC'#1) || (DtAlloc(stC#0, $h1) && DtType(stC#0) == class._module.StateC && DtAlloc(stC'#1, $h1) && DtType(stC'#1) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.UnionC($ly, $h0, this, stC#0, stC'#1) == _module.__default.UnionC($ly, $h1, this, stC#0, stC'#1));

// consequence axiom for _module.__default.UnionC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 12 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stC#0: DatatypeType, stC'#1: DatatypeType :: { _module.__default.UnionC($LS($ly), $Heap, this, stC#0, stC'#1) } _module.__default.UnionC#canCall($Heap, this, stC#0, stC'#1) || ((0 != $ModuleContextHeight || 12 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC && DtAlloc(stC'#1, $Heap) && DtType(stC'#1) == class._module.StateC) ==> Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1)))) && (forall p#2: DatatypeType :: DtAlloc(p#2, $Heap) && DtType(p#2) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[$Box(p#2)] ==> (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#2)] ==> _module.__default.GetSt($Heap, this, p#2, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#2, _module.StateC.st(stC#0))) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#2)] ==> _module.__default.GetSt($Heap, this, p#2, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#2, _module.StateC.st(stC'#1)))) && Set#Equal(_module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomC($Heap, this, _module.StateC.c(stC#0)), _module.__default.DomC($Heap, this, _module.StateC.c(stC'#1)))) && (forall h#3: BoxType :: GenericAlloc(h#3, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[h#3] ==> (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[h#3] ==> _module.__default.GetC($Heap, this, h#3, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#3, _module.StateC.c(stC#0))) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC'#1))[h#3] ==> _module.__default.GetC($Heap, this, h#3, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#3, _module.StateC.c(stC'#1)))) && DtAlloc(_module.__default.UnionC($LS($ly), $Heap, this, stC#0, stC'#1), $Heap) && DtType(_module.__default.UnionC($LS($ly), $Heap, this, stC#0, stC'#1)) == class._module.StateC);

procedure CheckWellformed$$_module.__default.UnionC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stC#0: DatatypeType where DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC, stC'#1: DatatypeType where DtAlloc(stC'#1, $Heap) && DtType(stC'#1) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 12 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))));
  ensures (forall p#4: DatatypeType :: DtAlloc(p#4, $Heap) && DtType(p#4) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[$Box(p#4)] ==> (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#4)] ==> _module.__default.GetSt($Heap, this, p#4, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#4, _module.StateC.st(stC#0))) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#4)] ==> _module.__default.GetSt($Heap, this, p#4, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#4, _module.StateC.st(stC'#1))));
  ensures Set#Equal(_module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomC($Heap, this, _module.StateC.c(stC#0)), _module.__default.DomC($Heap, this, _module.StateC.c(stC'#1))));
  ensures (forall h#5: BoxType :: GenericAlloc(h#5, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[h#5] ==> (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[h#5] ==> _module.__default.GetC($Heap, this, h#5, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#5, _module.StateC.c(stC#0))) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC'#1))[h#5] ==> _module.__default.GetC($Heap, this, h#5, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#5, _module.StateC.c(stC'#1))));



implementation CheckWellformed$$_module.__default.UnionC(this: ref, stC#0: DatatypeType, stC'#1: DatatypeType)
{
  var result#6: DatatypeType;
  var stC#7: DatatypeType;
  var stC'#8: DatatypeType;
  var st#9: BoxType;
  var st#10: BoxType;
  var st#11: BoxType;
  var p#12: DatatypeType;
  var st#13: BoxType;
  var st#14: BoxType;
  var p#15: DatatypeType;
  var st#16: BoxType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var st#19: BoxType;
  var p#20: DatatypeType;
  var st#21: BoxType;
  var p#22: DatatypeType;
  var st#23: BoxType;
  var c#24: BoxType;
  var c#25: BoxType;
  var c#26: BoxType;
  var h#28: BoxType;
  var c#29: BoxType;
  var c#30: BoxType;
  var h#31: BoxType;
  var c#32: BoxType;
  var h#33: BoxType;
  var c#34: BoxType;
  var c#35: BoxType;
  var h#36: BoxType;
  var c#37: BoxType;
  var h#38: BoxType;
  var c#39: BoxType;

    assume {:captureState "CachedBuilds0.dfy(64,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1), $Heap) && DtType(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)) == class._module.StateC;
        stC#7 := stC#0;
        stC'#8 := stC'#1;
        assert (this == this && stC#0 == stC#0 && stC'#1 == stC'#1) || DtRank(stC#7) < DtRank(stC#0) || (DtRank(stC#7) == DtRank(stC#0) && DtRank(stC'#8) < DtRank(stC'#1));
        assume (this == this && stC#0 == stC#0 && stC'#1 == stC'#1) || _module.__default.UnionC#canCall($Heap, this, stC#0, stC'#1);
        assume result#6 == _module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1);
        assume _module.__default.UnionC#canCall($Heap, this, stC#0, stC'#1);
        assume _module.StateC.S_q(result#6);
        st#9 := _module.StateC.st(result#6);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(result#6));
        assume _module.StateC.S_q(stC#0);
        st#10 := _module.StateC.st(stC#0);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#0));
        assume _module.StateC.S_q(stC'#1);
        st#11 := _module.StateC.st(stC'#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#1));
        if (Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(result#6)), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1)))))
        {
            havoc p#12;
            assume DtAlloc(p#12, $Heap) && DtType(p#12) == class._module.Path;
            assume _module.StateC.S_q(result#6);
            st#13 := _module.StateC.st(result#6);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(result#6));
            if (_module.__default.DomSt($Heap, this, _module.StateC.st(result#6))[$Box(p#12)])
            {
                assume _module.StateC.S_q(stC#0);
                st#14 := _module.StateC.st(stC#0);
                assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#0));
                if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#12)])
                {
                    assume _module.StateC.S_q(result#6);
                    p#15 := p#12;
                    st#16 := _module.StateC.st(result#6);
                    assume _module.__default.GetSt#canCall($Heap, this, p#12, _module.StateC.st(result#6));
                    assume _module.StateC.S_q(stC#0);
                    p#17 := p#12;
                    st#18 := _module.StateC.st(stC#0);
                    assume _module.__default.GetSt#canCall($Heap, this, p#12, _module.StateC.st(stC#0));
                }

                if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#12)] ==> _module.__default.GetSt($Heap, this, p#12, _module.StateC.st(result#6)) == _module.__default.GetSt($Heap, this, p#12, _module.StateC.st(stC#0)))
                {
                    assume _module.StateC.S_q(stC'#1);
                    st#19 := _module.StateC.st(stC'#1);
                    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#1));
                    if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#12)])
                    {
                        assume _module.StateC.S_q(result#6);
                        p#20 := p#12;
                        st#21 := _module.StateC.st(result#6);
                        assume _module.__default.GetSt#canCall($Heap, this, p#12, _module.StateC.st(result#6));
                        assume _module.StateC.S_q(stC'#1);
                        p#22 := p#12;
                        st#23 := _module.StateC.st(stC'#1);
                        assume _module.__default.GetSt#canCall($Heap, this, p#12, _module.StateC.st(stC'#1));
                    }
                }
            }
        }

        if (Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(result#6)), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1)))) && (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(result#6))[$Box(p#27)] ==> (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#27)] ==> _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(result#6)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC#0))) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#27)] ==> _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(result#6)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC'#1)))))
        {
            assume _module.StateC.S_q(result#6);
            c#24 := _module.StateC.c(result#6);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(result#6));
            assume _module.StateC.S_q(stC#0);
            c#25 := _module.StateC.c(stC#0);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#0));
            assume _module.StateC.S_q(stC'#1);
            c#26 := _module.StateC.c(stC'#1);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#1));
        }

        if (Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(result#6)), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1)))) && (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(result#6))[$Box(p#27)] ==> (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#27)] ==> _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(result#6)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC#0))) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#27)] ==> _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(result#6)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC'#1)))) && Set#Equal(_module.__default.DomC($Heap, this, _module.StateC.c(result#6)), Set#Union(_module.__default.DomC($Heap, this, _module.StateC.c(stC#0)), _module.__default.DomC($Heap, this, _module.StateC.c(stC'#1)))))
        {
            havoc h#28;
            assume GenericAlloc(h#28, $Heap);
            assume _module.StateC.S_q(result#6);
            c#29 := _module.StateC.c(result#6);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(result#6));
            if (_module.__default.DomC($Heap, this, _module.StateC.c(result#6))[h#28])
            {
                assume _module.StateC.S_q(stC#0);
                c#30 := _module.StateC.c(stC#0);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#0));
                if (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[h#28])
                {
                    assume _module.StateC.S_q(result#6);
                    h#31 := h#28;
                    c#32 := _module.StateC.c(result#6);
                    assume _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(result#6));
                    assume _module.StateC.S_q(stC#0);
                    h#33 := h#28;
                    c#34 := _module.StateC.c(stC#0);
                    assume _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(stC#0));
                }

                if (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[h#28] ==> _module.__default.GetC($Heap, this, h#28, _module.StateC.c(result#6)) == _module.__default.GetC($Heap, this, h#28, _module.StateC.c(stC#0)))
                {
                    assume _module.StateC.S_q(stC'#1);
                    c#35 := _module.StateC.c(stC'#1);
                    assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#1));
                    if (_module.__default.DomC($Heap, this, _module.StateC.c(stC'#1))[h#28])
                    {
                        assume _module.StateC.S_q(result#6);
                        h#36 := h#28;
                        c#37 := _module.StateC.c(result#6);
                        assume _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(result#6));
                        assume _module.StateC.S_q(stC'#1);
                        h#38 := h#28;
                        c#39 := _module.StateC.c(stC'#1);
                        assume _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(stC'#1));
                    }
                }
            }
        }

        assume Set#Equal(_module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1)))) && (forall p#40: DatatypeType :: DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[$Box(p#40)] ==> (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC#0))) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#1))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC'#1)))) && Set#Equal(_module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))), Set#Union(_module.__default.DomC($Heap, this, _module.StateC.c(stC#0)), _module.__default.DomC($Heap, this, _module.StateC.c(stC'#1)))) && (forall h#41: BoxType :: GenericAlloc(h#41, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1)))[h#41] ==> (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[h#41] ==> _module.__default.GetC($Heap, this, h#41, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#41, _module.StateC.c(stC#0))) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC'#1))[h#41] ==> _module.__default.GetC($Heap, this, h#41, _module.StateC.c(_module.__default.UnionC($LS($LZ), $Heap, this, stC#0, stC'#1))) == _module.__default.GetC($Heap, this, h#41, _module.StateC.c(stC'#1))));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.CompatibleC
function _module.__default.CompatibleC($heap: HeapType, this: ref, stsC#0: Set BoxType) : bool;

function _module.__default.CompatibleC#canCall($heap: HeapType, this: ref, stsC#0: Set BoxType) : bool;

// frame axiom for _module.__default.CompatibleC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, stsC#0: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.CompatibleC($h1, this, stsC#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.CompatibleC#canCall($h0, this, stsC#0) || (forall $t#2: BoxType :: { stsC#0[$t#2] } stsC#0[$t#2] ==> DtAlloc($Unbox($t#2): DatatypeType, $h0) && DtType($Unbox($t#2): DatatypeType) == class._module.StateC)) && (_module.__default.CompatibleC#canCall($h1, this, stsC#0) || (forall $t#3: BoxType :: { stsC#0[$t#3] } stsC#0[$t#3] ==> DtAlloc($Unbox($t#3): DatatypeType, $h1) && DtType($Unbox($t#3): DatatypeType) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.CompatibleC($h0, this, stsC#0) == _module.__default.CompatibleC($h1, this, stsC#0));

// consequence axiom for _module.__default.CompatibleC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 13 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CompatibleC($Heap, this, stsC#0) } _module.__default.CompatibleC#canCall($Heap, this, stsC#0) || ((0 != $ModuleContextHeight || 13 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#4: BoxType :: { stsC#0[$t#4] } stsC#0[$t#4] ==> DtAlloc($Unbox($t#4): DatatypeType, $Heap) && DtType($Unbox($t#4): DatatypeType) == class._module.StateC)) ==> true);

// definition axiom for _module.__default.CompatibleC (intra-module)
axiom 0 == $ModuleContextHeight && 13 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CompatibleC($Heap, this, stsC#0) } _module.__default.CompatibleC#canCall($Heap, this, stsC#0) || (13 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#5: BoxType :: { stsC#0[$t#5] } stsC#0[$t#5] ==> DtAlloc($Unbox($t#5): DatatypeType, $Heap) && DtType($Unbox($t#5): DatatypeType) == class._module.StateC)) ==> (forall stC#1: DatatypeType, stC'#2: DatatypeType, p#3: DatatypeType, h#4: BoxType :: DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && DtAlloc(stC'#2, $Heap) && DtType(stC'#2) == class._module.StateC && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path && GenericAlloc(h#4, $Heap) ==> (stsC#0[$Box(stC#1)] ==> true) && (stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1))) && (stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#3)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#2))) && (stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#3)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#2))[$Box(p#3)] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#1))) && (stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#3)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#2))[$Box(p#3)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#1))[h#4] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#2))) && (stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#3)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#2))[$Box(p#3)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#1))[h#4] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#2))[h#4] ==> _module.__default.GetSt#canCall($Heap, this, p#3, _module.StateC.st(stC#1)) && _module.__default.GetSt#canCall($Heap, this, p#3, _module.StateC.st(stC'#2)) && (_module.__default.GetSt($Heap, this, p#3, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#3, _module.StateC.st(stC'#2)) ==> _module.__default.GetC#canCall($Heap, this, h#4, _module.StateC.c(stC#1)) && _module.__default.GetC#canCall($Heap, this, h#4, _module.StateC.c(stC'#2))))) && _module.__default.CompatibleC($Heap, this, stsC#0) == (forall stC#1: DatatypeType, stC'#2: DatatypeType, p#3: DatatypeType, h#4: BoxType :: DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && DtAlloc(stC'#2, $Heap) && DtType(stC'#2) == class._module.StateC && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path && GenericAlloc(h#4, $Heap) ==> stsC#0[$Box(stC#1)] && stsC#0[$Box(stC'#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#3)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#2))[$Box(p#3)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#1))[h#4] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#2))[h#4] ==> _module.__default.GetSt($Heap, this, p#3, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#3, _module.StateC.st(stC'#2)) && _module.__default.GetC($Heap, this, h#4, _module.StateC.c(stC#1)) == _module.__default.GetC($Heap, this, h#4, _module.StateC.c(stC'#2))));

// definition axiom for _module.__default.CompatibleC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 13 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stsC#0: Set BoxType :: {:weight 10} { _module.__default.CompatibleC($Heap, this, Lit(stsC#0)) } _module.__default.CompatibleC#canCall($Heap, this, Lit(stsC#0)) || (13 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> (forall stC#5: DatatypeType, stC'#6: DatatypeType, p#7: DatatypeType, h#8: BoxType :: DtAlloc(stC#5, $Heap) && DtType(stC#5) == class._module.StateC && DtAlloc(stC'#6, $Heap) && DtType(stC'#6) == class._module.StateC && DtAlloc(p#7, $Heap) && DtType(p#7) == class._module.Path && GenericAlloc(h#8, $Heap) ==> (Lit(stsC#0)[$Box(stC#5)] ==> true) && (Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#5))) && (Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#7)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#6))) && (Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#7)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#7)] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#5))) && (Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#7)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#7)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#5))[h#8] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#6))) && (Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#7)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#7)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#5))[h#8] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#6))[h#8] ==> _module.__default.GetSt#canCall($Heap, this, p#7, _module.StateC.st(stC#5)) && _module.__default.GetSt#canCall($Heap, this, p#7, _module.StateC.st(stC'#6)) && (_module.__default.GetSt($Heap, this, p#7, _module.StateC.st(stC#5)) == _module.__default.GetSt($Heap, this, p#7, _module.StateC.st(stC'#6)) ==> _module.__default.GetC#canCall($Heap, this, h#8, _module.StateC.c(stC#5)) && _module.__default.GetC#canCall($Heap, this, h#8, _module.StateC.c(stC'#6))))) && _module.__default.CompatibleC($Heap, this, Lit(stsC#0)) == (forall stC#5: DatatypeType, stC'#6: DatatypeType, p#7: DatatypeType, h#8: BoxType :: DtAlloc(stC#5, $Heap) && DtType(stC#5) == class._module.StateC && DtAlloc(stC'#6, $Heap) && DtType(stC'#6) == class._module.StateC && DtAlloc(p#7, $Heap) && DtType(p#7) == class._module.Path && GenericAlloc(h#8, $Heap) ==> Lit(stsC#0)[$Box(stC#5)] && Lit(stsC#0)[$Box(stC'#6)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#7)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#7)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#5))[h#8] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#6))[h#8] ==> _module.__default.GetSt($Heap, this, p#7, _module.StateC.st(stC#5)) == _module.__default.GetSt($Heap, this, p#7, _module.StateC.st(stC'#6)) && _module.__default.GetC($Heap, this, h#8, _module.StateC.c(stC#5)) == _module.__default.GetC($Heap, this, h#8, _module.StateC.c(stC'#6))));

// definition axiom for _module.__default.CompatibleC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CompatibleC($Heap, this, stsC#0) } _module.__default.CompatibleC#canCall($Heap, this, stsC#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#6: BoxType :: { stsC#0[$t#6] } stsC#0[$t#6] ==> DtAlloc($Unbox($t#6): DatatypeType, $Heap) && DtType($Unbox($t#6): DatatypeType) == class._module.StateC)) ==> true);

// definition axiom for _module.__default.CompatibleC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stsC#0: Set BoxType :: {:weight 10} { _module.__default.CompatibleC($Heap, this, Lit(stsC#0)) } _module.__default.CompatibleC#canCall($Heap, this, Lit(stsC#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.CompatibleC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stsC#0: Set BoxType where (forall $t#7: BoxType :: { stsC#0[$t#7] } stsC#0[$t#7] ==> DtAlloc($Unbox($t#7): DatatypeType, $Heap) && DtType($Unbox($t#7): DatatypeType) == class._module.StateC));
  free requires 0 == $ModuleContextHeight && 13 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.CompatibleC(this: ref, stsC#0: Set BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stC#9: DatatypeType;
  var stC'#10: DatatypeType;
  var p#11: DatatypeType;
  var h#12: BoxType;
  var st#13: BoxType;
  var st#14: BoxType;
  var c#15: BoxType;
  var c#16: BoxType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var p#19: DatatypeType;
  var st#20: BoxType;
  var h#21: BoxType;
  var c#22: BoxType;
  var h#23: BoxType;
  var c#24: BoxType;

    assume {:captureState "CachedBuilds0.dfy(76,11): initial state"} true;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc stC#9;
        assume DtAlloc(stC#9, $Heap) && DtType(stC#9) == class._module.StateC;
        havoc stC'#10;
        assume DtAlloc(stC'#10, $Heap) && DtType(stC'#10) == class._module.StateC;
        havoc p#11;
        assume DtAlloc(p#11, $Heap) && DtType(p#11) == class._module.Path;
        havoc h#12;
        assume GenericAlloc(h#12, $Heap);
        if (stsC#0[$Box(stC#9)])
        {
        }

        if (stsC#0[$Box(stC#9)] && stsC#0[$Box(stC'#10)])
        {
            assume _module.StateC.S_q(stC#9);
            st#13 := _module.StateC.st(stC#9);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#9));
        }

        if (stsC#0[$Box(stC#9)] && stsC#0[$Box(stC'#10)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#9))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC'#10);
            st#14 := _module.StateC.st(stC'#10);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#10));
        }

        if (stsC#0[$Box(stC#9)] && stsC#0[$Box(stC'#10)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#9))[$Box(p#11)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#10))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC#9);
            c#15 := _module.StateC.c(stC#9);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#9));
        }

        if (stsC#0[$Box(stC#9)] && stsC#0[$Box(stC'#10)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#9))[$Box(p#11)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#10))[$Box(p#11)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#9))[h#12])
        {
            assume _module.StateC.S_q(stC'#10);
            c#16 := _module.StateC.c(stC'#10);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#10));
        }

        if (stsC#0[$Box(stC#9)] && stsC#0[$Box(stC'#10)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#9))[$Box(p#11)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#10))[$Box(p#11)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#9))[h#12] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#10))[h#12])
        {
            assume _module.StateC.S_q(stC#9);
            p#17 := p#11;
            st#18 := _module.StateC.st(stC#9);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC#9));
            assume _module.StateC.S_q(stC'#10);
            p#19 := p#11;
            st#20 := _module.StateC.st(stC'#10);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC'#10));
            if (_module.__default.GetSt($Heap, this, p#11, _module.StateC.st(stC#9)) == _module.__default.GetSt($Heap, this, p#11, _module.StateC.st(stC'#10)))
            {
                assume _module.StateC.S_q(stC#9);
                h#21 := h#12;
                c#22 := _module.StateC.c(stC#9);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetC#canCall($Heap, this, h#12, _module.StateC.c(stC#9));
                assume _module.StateC.S_q(stC'#10);
                h#23 := h#12;
                c#24 := _module.StateC.c(stC'#10);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetC#canCall($Heap, this, h#12, _module.StateC.c(stC'#10));
            }
        }

        assume _module.__default.CompatibleC($Heap, this, stsC#0) == (forall stC#25: DatatypeType, stC'#26: DatatypeType, p#27: DatatypeType, h#28: BoxType :: DtAlloc(stC#25, $Heap) && DtType(stC#25) == class._module.StateC && DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path && GenericAlloc(h#28, $Heap) ==> stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#25))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#25))[h#28] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#26))[h#28] ==> _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC#25)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC'#26)) && _module.__default.GetC($Heap, this, h#28, _module.StateC.c(stC#25)) == _module.__default.GetC($Heap, this, h#28, _module.StateC.c(stC'#26)));
        assume (forall stC#25: DatatypeType, stC'#26: DatatypeType, p#27: DatatypeType, h#28: BoxType :: DtAlloc(stC#25, $Heap) && DtType(stC#25) == class._module.StateC && DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path && GenericAlloc(h#28, $Heap) ==> (stsC#0[$Box(stC#25)] ==> true) && (stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#25))) && (stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#25))[$Box(p#27)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#26))) && (stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#25))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#25))) && (stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#25))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#25))[h#28] ==> _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC'#26))) && (stsC#0[$Box(stC#25)] && stsC#0[$Box(stC'#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#25))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#25))[h#28] && _module.__default.DomC($Heap, this, _module.StateC.c(stC'#26))[h#28] ==> _module.__default.GetSt#canCall($Heap, this, p#27, _module.StateC.st(stC#25)) && _module.__default.GetSt#canCall($Heap, this, p#27, _module.StateC.st(stC'#26)) && (_module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC#25)) == _module.__default.GetSt($Heap, this, p#27, _module.StateC.st(stC'#26)) ==> _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(stC#25)) && _module.__default.GetC#canCall($Heap, this, h#28, _module.StateC.c(stC'#26)))));
    }
}



// function declaration for _module._default.CombineC
function _module.__default.CombineC($ly: LayerType, $heap: HeapType, this: ref, stsC#0: Set BoxType) : DatatypeType;

function _module.__default.CombineC#canCall($heap: HeapType, this: ref, stsC#0: Set BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) } _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) == _module.__default.CombineC($ly, $Heap, this, stsC#0));

// frame axiom for _module.__default.CombineC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, stsC#0: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.CombineC($ly, $h1, this, stsC#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.CombineC#canCall($h0, this, stsC#0) || (forall $t#8: BoxType :: { stsC#0[$t#8] } stsC#0[$t#8] ==> DtAlloc($Unbox($t#8): DatatypeType, $h0) && DtType($Unbox($t#8): DatatypeType) == class._module.StateC)) && (_module.__default.CombineC#canCall($h1, this, stsC#0) || (forall $t#9: BoxType :: { stsC#0[$t#9] } stsC#0[$t#9] ==> DtAlloc($Unbox($t#9): DatatypeType, $h1) && DtType($Unbox($t#9): DatatypeType) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.CombineC($ly, $h0, this, stsC#0) == _module.__default.CombineC($ly, $h1, this, stsC#0));

// consequence axiom for _module.__default.CombineC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 14 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) } _module.__default.CombineC#canCall($Heap, this, stsC#0) || ((0 != $ModuleContextHeight || 14 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#10: BoxType :: { stsC#0[$t#10] } stsC#0[$t#10] ==> DtAlloc($Unbox($t#10): DatatypeType, $Heap) && DtType($Unbox($t#10): DatatypeType) == class._module.StateC) && !Set#Equal(stsC#0, Set#Empty(): Set BoxType)) ==> (forall stC#1: DatatypeType :: DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC ==> stsC#0[$Box(stC#1)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))))) && (forall stC#2: DatatypeType, p#3: DatatypeType :: DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && DtAlloc(p#3, $Heap) && DtType(p#3) == class._module.Path ==> stsC#0[$Box(stC#2)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#3)] ==> _module.__default.GetSt($Heap, this, p#3, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#3, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))) && (forall p#4: DatatypeType :: DtAlloc(p#4, $Heap) && DtType(p#4) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[$Box(p#4)] ==> (exists stC#5: DatatypeType :: DtAlloc(stC#5, $Heap) && DtType(stC#5) == class._module.StateC && stsC#0[$Box(stC#5)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#5))[$Box(p#4)])) && (forall stC#6: DatatypeType :: DtAlloc(stC#6, $Heap) && DtType(stC#6) == class._module.StateC ==> stsC#0[$Box(stC#6)] ==> Set#Subset(_module.__default.DomC($Heap, this, _module.StateC.c(stC#6)), _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))))) && (forall stC#7: DatatypeType, h#8: BoxType :: DtAlloc(stC#7, $Heap) && DtType(stC#7) == class._module.StateC && GenericAlloc(h#8, $Heap) ==> stsC#0[$Box(stC#7)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#7))[h#8] ==> _module.__default.GetC($Heap, this, h#8, _module.StateC.c(stC#7)) == _module.__default.GetC($Heap, this, h#8, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))) && (forall h#9: BoxType :: GenericAlloc(h#9, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[h#9] ==> (exists stC#10: DatatypeType :: DtAlloc(stC#10, $Heap) && DtType(stC#10) == class._module.StateC && stsC#0[$Box(stC#10)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#10))[h#9])) && DtAlloc(_module.__default.CombineC($LS($ly), $Heap, this, stsC#0), $Heap) && DtType(_module.__default.CombineC($LS($ly), $Heap, this, stsC#0)) == class._module.StateC);

function $let#3_stC($heap: HeapType, stsC: Set BoxType) : DatatypeType;

function $let#3$canCall($heap: HeapType, stsC: Set BoxType) : bool;

axiom (forall $heap: HeapType, stsC: Set BoxType :: { $let#3_stC($heap, stsC) } $let#3$canCall($heap, stsC) ==> stsC[$Box($let#3_stC($heap, stsC))]);

// definition axiom for _module.__default.CombineC (intra-module)
axiom 0 == $ModuleContextHeight && 14 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) } _module.__default.CombineC#canCall($Heap, this, stsC#0) || (14 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#11: BoxType :: { stsC#0[$t#11] } stsC#0[$t#11] ==> DtAlloc($Unbox($t#11): DatatypeType, $Heap) && DtType($Unbox($t#11): DatatypeType) == class._module.StateC) && !Set#Equal(stsC#0, Set#Empty(): Set BoxType)) ==> (forall stC#11: DatatypeType :: DtAlloc(stC#11, $Heap) && DtType(stC#11) == class._module.StateC ==> (stsC#0[$Box(stC#11)] ==> (Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))) ==> true) && (!Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))) ==> _module.__default.CombineC#canCall($Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11)))) && _module.__default.UnionC#canCall($Heap, this, stC#11, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))))))) && $let#3$canCall($Heap, stsC#0)) && _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) == (if Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box($let#3_stC($Heap, stsC#0)))) then $let#3_stC($Heap, stsC#0) else _module.__default.UnionC($LS($LZ), $Heap, this, $let#3_stC($Heap, stsC#0), _module.__default.CombineC($ly, $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box($let#3_stC($Heap, stsC#0))))))));

// definition axiom for _module.__default.CombineC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 14 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: {:weight 10} { _module.__default.CombineC($ly, $Heap, this, Lit(stsC#0)) } _module.__default.CombineC#canCall($Heap, this, Lit(stsC#0)) || (14 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && !Set#Equal(stsC#0, Set#Empty(): Set BoxType)) ==> (forall stC#11: DatatypeType :: DtAlloc(stC#11, $Heap) && DtType(stC#11) == class._module.StateC ==> (Lit(stsC#0)[$Box(stC#11)] ==> (Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))) ==> true) && (!Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))) ==> _module.__default.CombineC#canCall($Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11)))) && _module.__default.UnionC#canCall($Heap, this, stC#11, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#11))))))) && $let#3$canCall($Heap, Lit(stsC#0))) && _module.__default.CombineC($ly, $Heap, this, Lit(stsC#0)) == (if Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box($let#3_stC($Heap, Lit(stsC#0))))) then $let#3_stC($Heap, Lit(stsC#0)) else _module.__default.UnionC($LS($LZ), $Heap, this, $let#3_stC($Heap, Lit(stsC#0)), _module.__default.CombineC($ly, $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box($let#3_stC($Heap, Lit(stsC#0)))))))));

// definition axiom for _module.__default.CombineC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: { _module.__default.CombineC($LS($ly), $Heap, this, stsC#0) } _module.__default.CombineC#canCall($Heap, this, stsC#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $t#13: BoxType :: { stsC#0[$t#13] } stsC#0[$t#13] ==> DtAlloc($Unbox($t#13): DatatypeType, $Heap) && DtType($Unbox($t#13): DatatypeType) == class._module.StateC) && !Set#Equal(stsC#0, Set#Empty(): Set BoxType)) ==> true);

// definition axiom for _module.__default.CombineC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stsC#0: Set BoxType :: {:weight 10} { _module.__default.CombineC($ly, $Heap, this, Lit(stsC#0)) } _module.__default.CombineC#canCall($Heap, this, Lit(stsC#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && !Set#Equal(stsC#0, Set#Empty(): Set BoxType)) ==> true);

procedure CheckWellformed$$_module.__default.CombineC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stsC#0: Set BoxType where (forall $t#14: BoxType :: { stsC#0[$t#14] } stsC#0[$t#14] ==> DtAlloc($Unbox($t#14): DatatypeType, $Heap) && DtType($Unbox($t#14): DatatypeType) == class._module.StateC));
  free requires 0 == $ModuleContextHeight && 14 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures (forall stC#12: DatatypeType :: DtAlloc(stC#12, $Heap) && DtType(stC#12) == class._module.StateC ==> stsC#0[$Box(stC#12)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#12)), _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))));
  ensures (forall stC#13: DatatypeType, p#14: DatatypeType :: DtAlloc(stC#13, $Heap) && DtType(stC#13) == class._module.StateC && DtAlloc(p#14, $Heap) && DtType(p#14) == class._module.Path ==> stsC#0[$Box(stC#13)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#13))[$Box(p#14)] ==> _module.__default.GetSt($Heap, this, p#14, _module.StateC.st(stC#13)) == _module.__default.GetSt($Heap, this, p#14, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))));
  ensures (forall p#15: DatatypeType :: DtAlloc(p#15, $Heap) && DtType(p#15) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[$Box(p#15)] ==> (exists stC#16: DatatypeType :: DtAlloc(stC#16, $Heap) && DtType(stC#16) == class._module.StateC && stsC#0[$Box(stC#16)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#16))[$Box(p#15)]));
  ensures (forall stC#17: DatatypeType :: DtAlloc(stC#17, $Heap) && DtType(stC#17) == class._module.StateC ==> stsC#0[$Box(stC#17)] ==> Set#Subset(_module.__default.DomC($Heap, this, _module.StateC.c(stC#17)), _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))));
  ensures (forall stC#18: DatatypeType, h#19: BoxType :: DtAlloc(stC#18, $Heap) && DtType(stC#18) == class._module.StateC && GenericAlloc(h#19, $Heap) ==> stsC#0[$Box(stC#18)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#18))[h#19] ==> _module.__default.GetC($Heap, this, h#19, _module.StateC.c(stC#18)) == _module.__default.GetC($Heap, this, h#19, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))));
  ensures (forall h#20: BoxType :: GenericAlloc(h#20, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[h#20] ==> (exists stC#21: DatatypeType :: DtAlloc(stC#21, $Heap) && DtType(stC#21) == class._module.StateC && stsC#0[$Box(stC#21)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#21))[h#20]));



implementation CheckWellformed$$_module.__default.CombineC(this: ref, stsC#0: Set BoxType)
{
  var stCombinedC#22: DatatypeType;
  var stsC#23: Set BoxType;
  var stC#24: DatatypeType;
  var st#25: BoxType;
  var st#26: BoxType;
  var stC#27: DatatypeType;
  var p#28: DatatypeType;
  var st#29: BoxType;
  var p#30: DatatypeType;
  var st#31: BoxType;
  var p#32: DatatypeType;
  var st#33: BoxType;
  var p#35: DatatypeType;
  var st#36: BoxType;
  var stC#37: DatatypeType;
  var st#38: BoxType;
  var stC#41: DatatypeType;
  var c#42: BoxType;
  var c#43: BoxType;
  var stC#46: DatatypeType;
  var h#47: BoxType;
  var c#48: BoxType;
  var h#49: BoxType;
  var c#50: BoxType;
  var h#51: BoxType;
  var c#52: BoxType;
  var h#54: BoxType;
  var c#55: BoxType;
  var stC#56: DatatypeType;
  var c#57: BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var stC#70: DatatypeType;
  var stsC#71: Set BoxType;
  var stC#72: DatatypeType;
  var stC'#73: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(84,10): initial state"} true;
    assume !Set#Equal(stsC#0, Set#Empty(): Set BoxType);
    if (*)
    {
        assume DtAlloc(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0), $Heap) && DtType(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)) == class._module.StateC;
        stsC#23 := stsC#0;
        assert !Set#Equal(stsC#23, Set#Empty(): Set BoxType);
        assert (this == this && stsC#0 == stsC#0) || (Set#Subset(stsC#23, stsC#0) && !Set#Subset(stsC#0, stsC#23));
        assume (this == this && stsC#0 == stsC#0) || _module.__default.CombineC#canCall($Heap, this, stsC#0);
        assume stCombinedC#22 == _module.__default.CombineC($LS($LZ), $Heap, this, stsC#0);
        assume _module.__default.CombineC#canCall($Heap, this, stsC#0);
        havoc stC#24;
        assume DtAlloc(stC#24, $Heap) && DtType(stC#24) == class._module.StateC;
        if (stsC#0[$Box(stC#24)])
        {
            assume _module.StateC.S_q(stC#24);
            st#25 := _module.StateC.st(stC#24);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#24));
            assume _module.StateC.S_q(stCombinedC#22);
            st#26 := _module.StateC.st(stCombinedC#22);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#22));
        }

        if ((forall stC#34: DatatypeType :: DtAlloc(stC#34, $Heap) && DtType(stC#34) == class._module.StateC ==> stsC#0[$Box(stC#34)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#34)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22)))))
        {
            havoc stC#27;
            assume DtAlloc(stC#27, $Heap) && DtType(stC#27) == class._module.StateC;
            havoc p#28;
            assume DtAlloc(p#28, $Heap) && DtType(p#28) == class._module.Path;
            if (stsC#0[$Box(stC#27)])
            {
                assume _module.StateC.S_q(stC#27);
                st#29 := _module.StateC.st(stC#27);
                assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#27));
            }

            if (stsC#0[$Box(stC#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#27))[$Box(p#28)])
            {
                assume _module.StateC.S_q(stC#27);
                p#30 := p#28;
                st#31 := _module.StateC.st(stC#27);
                assume _module.__default.GetSt#canCall($Heap, this, p#28, _module.StateC.st(stC#27));
                assume _module.StateC.S_q(stCombinedC#22);
                p#32 := p#28;
                st#33 := _module.StateC.st(stCombinedC#22);
                assume _module.__default.GetSt#canCall($Heap, this, p#28, _module.StateC.st(stCombinedC#22));
            }
        }

        if ((forall stC#34: DatatypeType :: DtAlloc(stC#34, $Heap) && DtType(stC#34) == class._module.StateC ==> stsC#0[$Box(stC#34)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#34)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22)))) && (forall stC#39: DatatypeType, p#40: DatatypeType :: DtAlloc(stC#39, $Heap) && DtType(stC#39) == class._module.StateC && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> stsC#0[$Box(stC#39)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#39))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC#39)) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stCombinedC#22))))
        {
            havoc p#35;
            assume DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path;
            assume _module.StateC.S_q(stCombinedC#22);
            st#36 := _module.StateC.st(stCombinedC#22);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#22));
            if (_module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22))[$Box(p#35)])
            {
                havoc stC#37;
                assume DtAlloc(stC#37, $Heap) && DtType(stC#37) == class._module.StateC;
                if (stsC#0[$Box(stC#37)])
                {
                    assume _module.StateC.S_q(stC#37);
                    st#38 := _module.StateC.st(stC#37);
                    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#37));
                }
            }
        }

        if ((forall stC#34: DatatypeType :: DtAlloc(stC#34, $Heap) && DtType(stC#34) == class._module.StateC ==> stsC#0[$Box(stC#34)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#34)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22)))) && (forall stC#39: DatatypeType, p#40: DatatypeType :: DtAlloc(stC#39, $Heap) && DtType(stC#39) == class._module.StateC && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> stsC#0[$Box(stC#39)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#39))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC#39)) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stCombinedC#22))) && (forall p#44: DatatypeType :: DtAlloc(p#44, $Heap) && DtType(p#44) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22))[$Box(p#44)] ==> (exists stC#45: DatatypeType :: DtAlloc(stC#45, $Heap) && DtType(stC#45) == class._module.StateC && stsC#0[$Box(stC#45)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#45))[$Box(p#44)])))
        {
            havoc stC#41;
            assume DtAlloc(stC#41, $Heap) && DtType(stC#41) == class._module.StateC;
            if (stsC#0[$Box(stC#41)])
            {
                assume _module.StateC.S_q(stC#41);
                c#42 := _module.StateC.c(stC#41);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#41));
                assume _module.StateC.S_q(stCombinedC#22);
                c#43 := _module.StateC.c(stCombinedC#22);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stCombinedC#22));
            }
        }

        if ((forall stC#34: DatatypeType :: DtAlloc(stC#34, $Heap) && DtType(stC#34) == class._module.StateC ==> stsC#0[$Box(stC#34)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#34)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22)))) && (forall stC#39: DatatypeType, p#40: DatatypeType :: DtAlloc(stC#39, $Heap) && DtType(stC#39) == class._module.StateC && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> stsC#0[$Box(stC#39)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#39))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC#39)) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stCombinedC#22))) && (forall p#44: DatatypeType :: DtAlloc(p#44, $Heap) && DtType(p#44) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22))[$Box(p#44)] ==> (exists stC#45: DatatypeType :: DtAlloc(stC#45, $Heap) && DtType(stC#45) == class._module.StateC && stsC#0[$Box(stC#45)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#45))[$Box(p#44)])) && (forall stC#53: DatatypeType :: DtAlloc(stC#53, $Heap) && DtType(stC#53) == class._module.StateC ==> stsC#0[$Box(stC#53)] ==> Set#Subset(_module.__default.DomC($Heap, this, _module.StateC.c(stC#53)), _module.__default.DomC($Heap, this, _module.StateC.c(stCombinedC#22)))))
        {
            havoc stC#46;
            assume DtAlloc(stC#46, $Heap) && DtType(stC#46) == class._module.StateC;
            havoc h#47;
            assume GenericAlloc(h#47, $Heap);
            if (stsC#0[$Box(stC#46)])
            {
                assume _module.StateC.S_q(stC#46);
                c#48 := _module.StateC.c(stC#46);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#46));
            }

            if (stsC#0[$Box(stC#46)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#46))[h#47])
            {
                assume _module.StateC.S_q(stC#46);
                h#49 := h#47;
                c#50 := _module.StateC.c(stC#46);
                assume _module.__default.GetC#canCall($Heap, this, h#47, _module.StateC.c(stC#46));
                assume _module.StateC.S_q(stCombinedC#22);
                h#51 := h#47;
                c#52 := _module.StateC.c(stCombinedC#22);
                assume _module.__default.GetC#canCall($Heap, this, h#47, _module.StateC.c(stCombinedC#22));
            }
        }

        if ((forall stC#34: DatatypeType :: DtAlloc(stC#34, $Heap) && DtType(stC#34) == class._module.StateC ==> stsC#0[$Box(stC#34)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#34)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22)))) && (forall stC#39: DatatypeType, p#40: DatatypeType :: DtAlloc(stC#39, $Heap) && DtType(stC#39) == class._module.StateC && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> stsC#0[$Box(stC#39)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#39))[$Box(p#40)] ==> _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stC#39)) == _module.__default.GetSt($Heap, this, p#40, _module.StateC.st(stCombinedC#22))) && (forall p#44: DatatypeType :: DtAlloc(p#44, $Heap) && DtType(p#44) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#22))[$Box(p#44)] ==> (exists stC#45: DatatypeType :: DtAlloc(stC#45, $Heap) && DtType(stC#45) == class._module.StateC && stsC#0[$Box(stC#45)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#45))[$Box(p#44)])) && (forall stC#53: DatatypeType :: DtAlloc(stC#53, $Heap) && DtType(stC#53) == class._module.StateC ==> stsC#0[$Box(stC#53)] ==> Set#Subset(_module.__default.DomC($Heap, this, _module.StateC.c(stC#53)), _module.__default.DomC($Heap, this, _module.StateC.c(stCombinedC#22)))) && (forall stC#58: DatatypeType, h#59: BoxType :: DtAlloc(stC#58, $Heap) && DtType(stC#58) == class._module.StateC && GenericAlloc(h#59, $Heap) ==> stsC#0[$Box(stC#58)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#58))[h#59] ==> _module.__default.GetC($Heap, this, h#59, _module.StateC.c(stC#58)) == _module.__default.GetC($Heap, this, h#59, _module.StateC.c(stCombinedC#22))))
        {
            havoc h#54;
            assume GenericAlloc(h#54, $Heap);
            assume _module.StateC.S_q(stCombinedC#22);
            c#55 := _module.StateC.c(stCombinedC#22);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stCombinedC#22));
            if (_module.__default.DomC($Heap, this, _module.StateC.c(stCombinedC#22))[h#54])
            {
                havoc stC#56;
                assume DtAlloc(stC#56, $Heap) && DtType(stC#56) == class._module.StateC;
                if (stsC#0[$Box(stC#56)])
                {
                    assume _module.StateC.S_q(stC#56);
                    c#57 := _module.StateC.c(stC#56);
                    assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#56));
                }
            }
        }

        assume (forall stC#60: DatatypeType :: DtAlloc(stC#60, $Heap) && DtType(stC#60) == class._module.StateC ==> stsC#0[$Box(stC#60)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#60)), _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))))) && (forall stC#61: DatatypeType, p#62: DatatypeType :: DtAlloc(stC#61, $Heap) && DtType(stC#61) == class._module.StateC && DtAlloc(p#62, $Heap) && DtType(p#62) == class._module.Path ==> stsC#0[$Box(stC#61)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#61))[$Box(p#62)] ==> _module.__default.GetSt($Heap, this, p#62, _module.StateC.st(stC#61)) == _module.__default.GetSt($Heap, this, p#62, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))) && (forall p#63: DatatypeType :: DtAlloc(p#63, $Heap) && DtType(p#63) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[$Box(p#63)] ==> (exists stC#64: DatatypeType :: DtAlloc(stC#64, $Heap) && DtType(stC#64) == class._module.StateC && stsC#0[$Box(stC#64)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#64))[$Box(p#63)])) && (forall stC#65: DatatypeType :: DtAlloc(stC#65, $Heap) && DtType(stC#65) == class._module.StateC ==> stsC#0[$Box(stC#65)] ==> Set#Subset(_module.__default.DomC($Heap, this, _module.StateC.c(stC#65)), _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0))))) && (forall stC#66: DatatypeType, h#67: BoxType :: DtAlloc(stC#66, $Heap) && DtType(stC#66) == class._module.StateC && GenericAlloc(h#67, $Heap) ==> stsC#0[$Box(stC#66)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#66))[h#67] ==> _module.__default.GetC($Heap, this, h#67, _module.StateC.c(stC#66)) == _module.__default.GetC($Heap, this, h#67, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))) && (forall h#68: BoxType :: GenericAlloc(h#68, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(_module.__default.CombineC($LS($LZ), $Heap, this, stsC#0)))[h#68] ==> (exists stC#69: DatatypeType :: DtAlloc(stC#69, $Heap) && DtType(stC#69) == class._module.StateC && stsC#0[$Box(stC#69)] && _module.__default.DomC($Heap, this, _module.StateC.c(stC#69))[h#68]));
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc stC#70;
        assume DtAlloc(stC#70, $Heap) && DtType(stC#70) == class._module.StateC;
        assert (exists stC#11: DatatypeType :: DtAlloc(stC#11, $Heap) && DtType(stC#11) == class._module.StateC && stsC#0[$Box(stC#11)]);
        assume stsC#0[$Box(stC#70)];
        if (Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))))
        {
        }
        else
        {
            stsC#71 := Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70)));
            assert !Set#Equal(stsC#71, Set#Empty(): Set BoxType);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert Set#Subset(stsC#71, stsC#0) && !Set#Subset(stsC#0, stsC#71);
            assume _module.__default.CombineC#canCall($Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))));
            stC#72 := stC#70;
            stC'#73 := _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))));
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.UnionC#canCall($Heap, this, stC#70, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70)))));
        }

        assume _module.__default.CombineC($LS($LZ), $Heap, this, stsC#0) == (if Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))) then stC#70 else _module.__default.UnionC($LS($LZ), $Heap, this, stC#70, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))))));
        assume (Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))) ==> true) && (!Set#Equal(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))) ==> _module.__default.CombineC#canCall($Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70)))) && _module.__default.UnionC#canCall($Heap, this, stC#70, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Difference(stsC#0, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC#70))))));
    }
}



// function declaration for _module._default.ConsistentCache
function _module.__default.ConsistentCache($heap: HeapType, this: ref, stC#0: DatatypeType) : bool;

function _module.__default.ConsistentCache#canCall($heap: HeapType, this: ref, stC#0: DatatypeType) : bool;

// frame axiom for _module.__default.ConsistentCache
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, stC#0: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.ConsistentCache($h1, this, stC#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.ConsistentCache#canCall($h0, this, stC#0) || (DtAlloc(stC#0, $h0) && DtType(stC#0) == class._module.StateC)) && (_module.__default.ConsistentCache#canCall($h1, this, stC#0) || (DtAlloc(stC#0, $h1) && DtType(stC#0) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.ConsistentCache($h0, this, stC#0) == _module.__default.ConsistentCache($h1, this, stC#0));

// consequence axiom for _module.__default.ConsistentCache
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 15 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, stC#0: DatatypeType :: { _module.__default.ConsistentCache($Heap, this, stC#0) } _module.__default.ConsistentCache#canCall($Heap, this, stC#0) || ((0 != $ModuleContextHeight || 15 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC) ==> true);

// definition axiom for _module.__default.ConsistentCache (intra-module)
axiom 0 == $ModuleContextHeight && 15 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stC#0: DatatypeType :: { _module.__default.ConsistentCache($Heap, this, stC#0) } _module.__default.ConsistentCache#canCall($Heap, this, stC#0) || (15 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC) ==> (forall cmd#1: DatatypeType, deps#2: DatatypeType, e#3: BoxType :: DtAlloc(cmd#1, $Heap) && DtType(cmd#1) == class._module.Expression && DtAlloc(deps#2, $Heap) && DtType(deps#2) == class._module.Expression && GenericAlloc(e#3, $Heap) ==> _module.__default.Loc#canCall($Heap, this, cmd#1, deps#2, e#3) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#1, deps#2, e#3)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#0)) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#1, deps#2, e#3))] ==> _module.__default.Loc#canCall($Heap, this, cmd#1, deps#2, e#3) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#0)))) && _module.__default.ConsistentCache($Heap, this, stC#0) == (forall cmd#1: DatatypeType, deps#2: DatatypeType, e#3: BoxType :: DtAlloc(cmd#1, $Heap) && DtType(cmd#1) == class._module.Expression && DtAlloc(deps#2, $Heap) && DtType(deps#2) == class._module.Expression && GenericAlloc(e#3, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#1, deps#2, e#3))] ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(_module.__default.Loc($Heap, this, cmd#1, deps#2, e#3))]));

// definition axiom for _module.__default.ConsistentCache for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 15 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stC#0: DatatypeType :: {:weight 10} { _module.__default.ConsistentCache($Heap, this, Lit(stC#0)) } _module.__default.ConsistentCache#canCall($Heap, this, Lit(stC#0)) || (15 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> (forall cmd#4: DatatypeType, deps#5: DatatypeType, e#6: BoxType :: DtAlloc(cmd#4, $Heap) && DtType(cmd#4) == class._module.Expression && DtAlloc(deps#5, $Heap) && DtType(deps#5) == class._module.Expression && GenericAlloc(e#6, $Heap) ==> _module.__default.Loc#canCall($Heap, this, cmd#4, deps#5, e#6) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#4, deps#5, e#6)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(Lit(stC#0))) && (_module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#0)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#4, deps#5, e#6))] ==> _module.__default.Loc#canCall($Heap, this, cmd#4, deps#5, e#6) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(Lit(stC#0))))) && _module.__default.ConsistentCache($Heap, this, Lit(stC#0)) == (forall cmd#4: DatatypeType, deps#5: DatatypeType, e#6: BoxType :: DtAlloc(cmd#4, $Heap) && DtType(cmd#4) == class._module.Expression && DtAlloc(deps#5, $Heap) && DtType(deps#5) == class._module.Expression && GenericAlloc(e#6, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#0)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#4, deps#5, e#6))] ==> _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#0)))[$Box(_module.__default.Loc($Heap, this, cmd#4, deps#5, e#6))]));

// definition axiom for _module.__default.ConsistentCache (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stC#0: DatatypeType :: { _module.__default.ConsistentCache($Heap, this, stC#0) } _module.__default.ConsistentCache#canCall($Heap, this, stC#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC) ==> true);

// definition axiom for _module.__default.ConsistentCache for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stC#0: DatatypeType :: {:weight 10} { _module.__default.ConsistentCache($Heap, this, Lit(stC#0)) } _module.__default.ConsistentCache#canCall($Heap, this, Lit(stC#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.ConsistentCache(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stC#0: DatatypeType where DtAlloc(stC#0, $Heap) && DtType(stC#0) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 15 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.ConsistentCache(this: ref, stC#0: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var e#9: BoxType;
  var cmd#10: DatatypeType;
  var deps#11: DatatypeType;
  var ext#12: BoxType;
  var p#13: DatatypeType;
  var c#14: BoxType;
  var cmd#15: DatatypeType;
  var deps#16: DatatypeType;
  var ext#17: BoxType;
  var st#18: BoxType;

    assume {:captureState "CachedBuilds0.dfy(104,11): initial state"} true;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc cmd#7;
        assume DtAlloc(cmd#7, $Heap) && DtType(cmd#7) == class._module.Expression;
        havoc deps#8;
        assume DtAlloc(deps#8, $Heap) && DtType(deps#8) == class._module.Expression;
        havoc e#9;
        assume GenericAlloc(e#9, $Heap);
        cmd#10 := cmd#7;
        deps#11 := deps#8;
        ext#12 := e#9;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Loc#canCall($Heap, this, cmd#7, deps#8, e#9);
        p#13 := _module.__default.Loc($Heap, this, cmd#7, deps#8, e#9);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#7, deps#8, e#9));
        assume _module.StateC.S_q(stC#0);
        c#14 := _module.StateC.c(stC#0);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#0));
        if (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#7, deps#8, e#9))])
        {
            cmd#15 := cmd#7;
            deps#16 := deps#8;
            ext#17 := e#9;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Loc#canCall($Heap, this, cmd#7, deps#8, e#9);
            assume _module.StateC.S_q(stC#0);
            st#18 := _module.StateC.st(stC#0);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#0));
        }

        assume _module.__default.ConsistentCache($Heap, this, stC#0) == (forall cmd#19: DatatypeType, deps#20: DatatypeType, e#21: BoxType :: DtAlloc(cmd#19, $Heap) && DtType(cmd#19) == class._module.Expression && DtAlloc(deps#20, $Heap) && DtType(deps#20) == class._module.Expression && GenericAlloc(e#21, $Heap) ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#19, deps#20, e#21))] ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#0))[$Box(_module.__default.Loc($Heap, this, cmd#19, deps#20, e#21))]);
        assume (forall cmd#19: DatatypeType, deps#20: DatatypeType, e#21: BoxType :: DtAlloc(cmd#19, $Heap) && DtType(cmd#19) == class._module.Expression && DtAlloc(deps#20, $Heap) && DtType(deps#20) == class._module.Expression && GenericAlloc(e#21, $Heap) ==> _module.__default.Loc#canCall($Heap, this, cmd#19, deps#20, e#21) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#19, deps#20, e#21)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#0)) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC#0))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#19, deps#20, e#21))] ==> _module.__default.Loc#canCall($Heap, this, cmd#19, deps#20, e#21) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#0))));
    }
}



// function declaration for _module._default.EmptyEnv
function _module.__default.EmptyEnv($heap: HeapType, this: ref) : BoxType;

function _module.__default.EmptyEnv#canCall($heap: HeapType, this: ref) : bool;

// frame axiom for _module.__default.EmptyEnv
axiom (forall $h0: HeapType, $h1: HeapType, this: ref :: { $HeapSucc($h0, $h1), _module.__default.EmptyEnv($h1, this) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.EmptyEnv($h0, this) == _module.__default.EmptyEnv($h1, this));

// consequence axiom for _module.__default.EmptyEnv
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 31 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref :: { _module.__default.EmptyEnv($Heap, this) } _module.__default.EmptyEnv#canCall($Heap, this) || ((0 != $ModuleContextHeight || 31 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> GenericAlloc(_module.__default.EmptyEnv($Heap, this), $Heap));

procedure CheckWellformed$$_module.__default.EmptyEnv(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default);
  free requires 0 == $ModuleContextHeight && 31 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.EmptyEnv(this: ref)
{
    assume {:captureState "CachedBuilds0.dfy(113,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.EmptyEnv($Heap, this), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.GetEnv
function _module.__default.GetEnv($ly: LayerType, $heap: HeapType, this: ref, id#0: BoxType, env#1: BoxType) : DatatypeType;

function _module.__default.GetEnv#canCall($heap: HeapType, this: ref, id#0: BoxType, env#1: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, id#0: BoxType, env#1: BoxType :: { _module.__default.GetEnv($LS($ly), $Heap, this, id#0, env#1) } _module.__default.GetEnv($LS($ly), $Heap, this, id#0, env#1) == _module.__default.GetEnv($ly, $Heap, this, id#0, env#1));

// frame axiom for _module.__default.GetEnv
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, id#0: BoxType, env#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.GetEnv($ly, $h1, this, id#0, env#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.GetEnv#canCall($h0, this, id#0, env#1) || (GenericAlloc(id#0, $h0) && GenericAlloc(env#1, $h0))) && (_module.__default.GetEnv#canCall($h1, this, id#0, env#1) || (GenericAlloc(id#0, $h1) && GenericAlloc(env#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.GetEnv($ly, $h0, this, id#0, env#1) == _module.__default.GetEnv($ly, $h1, this, id#0, env#1));

// consequence axiom for _module.__default.GetEnv
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 17 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, id#0: BoxType, env#1: BoxType :: { _module.__default.GetEnv($LS($ly), $Heap, this, id#0, env#1) } _module.__default.GetEnv#canCall($Heap, this, id#0, env#1) || ((0 != $ModuleContextHeight || 17 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(id#0, $Heap) && GenericAlloc(env#1, $Heap)) ==> _module.__default.Value($Heap, this, _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1)) && DtAlloc(_module.__default.GetEnv($LS($ly), $Heap, this, id#0, env#1), $Heap) && DtType(_module.__default.GetEnv($LS($ly), $Heap, this, id#0, env#1)) == class._module.Expression);

procedure CheckWellformed$$_module.__default.GetEnv(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, id#0: BoxType where GenericAlloc(id#0, $Heap), env#1: BoxType where GenericAlloc(env#1, $Heap));
  free requires 0 == $ModuleContextHeight && 17 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures _module.__default.Value#canCall($Heap, this, _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1)) ==> _module.__default.Value($Heap, this, _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1)) || _module.Expression.exprLiteral_q(_module.__default.GetEnv($LS($LS($LZ)), $Heap, this, id#0, env#1));



implementation CheckWellformed$$_module.__default.GetEnv(this: ref, id#0: BoxType, env#1: BoxType)
{
  var id#2: BoxType;
  var env#3: BoxType;
  var expr#4: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(114,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1), $Heap) && DtType(_module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1)) == class._module.Expression;
        id#2 := id#0;
        env#3 := env#1;
        assert this == this && id#0 == id#0 && env#1 == env#1;
        assume (this == this && id#0 == id#0 && env#1 == env#1) || _module.__default.GetEnv#canCall($Heap, this, id#0, env#1);
        expr#4 := _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1);
        assume _module.__default.Value#canCall($Heap, this, _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1));
        assume _module.__default.Value($Heap, this, _module.__default.GetEnv($LS($LZ), $Heap, this, id#0, env#1));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.SetEnv
function _module.__default.SetEnv($heap: HeapType, this: ref, id#0: BoxType, expr#1: DatatypeType, env#2: BoxType) : BoxType;

function _module.__default.SetEnv#canCall($heap: HeapType, this: ref, id#0: BoxType, expr#1: DatatypeType, env#2: BoxType) : bool;

// frame axiom for _module.__default.SetEnv
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, id#0: BoxType, expr#1: DatatypeType, env#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.SetEnv($h1, this, id#0, expr#1, env#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.SetEnv#canCall($h0, this, id#0, expr#1, env#2) || (GenericAlloc(id#0, $h0) && DtAlloc(expr#1, $h0) && DtType(expr#1) == class._module.Expression && GenericAlloc(env#2, $h0))) && (_module.__default.SetEnv#canCall($h1, this, id#0, expr#1, env#2) || (GenericAlloc(id#0, $h1) && DtAlloc(expr#1, $h1) && DtType(expr#1) == class._module.Expression && GenericAlloc(env#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.SetEnv($h0, this, id#0, expr#1, env#2) == _module.__default.SetEnv($h1, this, id#0, expr#1, env#2));

// consequence axiom for _module.__default.SetEnv
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 18 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, id#0: BoxType, expr#1: DatatypeType, env#2: BoxType :: { _module.__default.SetEnv($Heap, this, id#0, expr#1, env#2) } _module.__default.SetEnv#canCall($Heap, this, id#0, expr#1, env#2) || ((0 != $ModuleContextHeight || 18 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && GenericAlloc(id#0, $Heap) && DtAlloc(expr#1, $Heap) && DtType(expr#1) == class._module.Expression && GenericAlloc(env#2, $Heap) && _module.__default.Value($Heap, this, expr#1)) ==> GenericAlloc(_module.__default.SetEnv($Heap, this, id#0, expr#1, env#2), $Heap));

procedure CheckWellformed$$_module.__default.SetEnv(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, id#0: BoxType where GenericAlloc(id#0, $Heap), expr#1: DatatypeType where DtAlloc(expr#1, $Heap) && DtType(expr#1) == class._module.Expression, env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 18 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.SetEnv(this: ref, id#0: BoxType, expr#1: DatatypeType, env#2: BoxType)
{
  var expr#3: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(116,10): initial state"} true;
    expr#3 := expr#1;
    assume _module.__default.Value#canCall($Heap, this, expr#1);
    assume _module.__default.Value($Heap, this, expr#1);
    if (*)
    {
        assume GenericAlloc(_module.__default.SetEnv($Heap, this, id#0, expr#1, env#2), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.exec
function _module.__default.exec($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : DatatypeType;

function _module.__default.exec#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : bool;

// frame axiom for _module.__default.exec
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.exec($h1, this, cmd#0, deps#1, exts#2, st#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.exec#canCall($h0, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h0))) && (_module.__default.exec#canCall($h1, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.exec($h0, this, cmd#0, deps#1, exts#2, st#3) == _module.__default.exec($h1, this, cmd#0, deps#1, exts#2, st#3));

// consequence axiom for _module.__default.exec
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 21 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || ((0 != $ModuleContextHeight || 21 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap)) ==> DtAlloc(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3), $Heap) && DtType(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)) == class._module.Tuple);

procedure CheckWellformed$$_module.__default.exec(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, st#3: BoxType where GenericAlloc(st#3, $Heap));
  free requires 0 == $ModuleContextHeight && 21 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.exec(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(120,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3), $Heap) && DtType(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)) == class._module.Tuple;
        assume false;
    }
    else
    {
        assume false;
    }
}



procedure CheckWellformed$$_module.__default.ExecProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), st#3: BoxType where GenericAlloc(st#3, $Heap));
  free requires 0 == $ModuleContextHeight && 24 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.ExecProperty(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var st#4: BoxType;
  var paths#5: Set BoxType;
  var st#6: BoxType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var exts#9: DatatypeType;
  var st#10: BoxType;
  var result#11: DatatypeType;
  var cmd#12: DatatypeType;
  var deps#13: DatatypeType;
  var exts#14: DatatypeType;
  var st#15: BoxType;
  var expr'#16: DatatypeType;
  var st'#17: BoxType;
  var st#18: BoxType;
  var st#19: BoxType;
  var st#20: BoxType;
  var st#21: BoxType;
  var paths#22: Set BoxType;
  var st#23: BoxType;
  var cmd#24: DatatypeType;
  var deps#25: DatatypeType;
  var exts#26: DatatypeType;
  var paths#27: DatatypeType;
  var paths#28: Set BoxType;
  var st#29: BoxType;
  var cmd#30: DatatypeType;
  var deps#31: DatatypeType;
  var exts#32: DatatypeType;
  var st#33: BoxType;
  var p#34: DatatypeType;
  var st#35: BoxType;
  var st#36: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(122,14): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        st#4 := st#3;
        assume _module.__default.DomSt#canCall($Heap, this, st#3);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, st#3)))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        paths#5 := _module.Literal.paths(_module.Expression.lit(deps#1));
        st#6 := st#3;
        assert Set#Subset(paths#5, _module.__default.DomSt($Heap, this, st#6));
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3);
        cmd#7 := cmd#0;
        deps#8 := deps#1;
        exts#9 := exts#2;
        st#10 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3);
        assert _module.Expression.exprLiteral_q(cmd#7) && _module.Literal.litString_q(_module.Expression.lit(cmd#7)) && _module.Expression.exprLiteral_q(deps#8) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#8)) && _module.Expression.exprLiteral_q(exts#9) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#9));
        assume _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3));
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, st#3)) && _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(130,5): post-state"} true;
    cmd#12 := cmd#0;
    deps#13 := deps#1;
    exts#14 := exts#2;
    st#15 := st#3;
    assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3);
    assume result#11 == _module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3);
    assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3);
    assume _module.Tuple.Pair_q(result#11);
    assume expr'#16 == $Unbox(_module.Tuple.fst(result#11)): DatatypeType;
    assume true;
    assume _module.Tuple.Pair_q(result#11);
    assume st'#17 == _module.Tuple.snd(result#11);
    assume true;
    if (_module.Expression.exprLiteral_q(expr'#16))
    {
        assert _module.Expression.exprLiteral_q(expr'#16);
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)))
    {
        assert _module.Expression.exprLiteral_q(expr'#16);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16));
        st#18 := st'#17;
        assume _module.__default.DomSt#canCall($Heap, this, st'#17);
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#16)), _module.__default.DomSt($Heap, this, st'#17)))
    {
        st#19 := st#3;
        assume _module.__default.DomSt#canCall($Heap, this, st#3);
        st#20 := st'#17;
        assume _module.__default.DomSt#canCall($Heap, this, st'#17);
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#16)), _module.__default.DomSt($Heap, this, st'#17)) && Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, st'#17)))
    {
        st#21 := st#3;
        assume _module.__default.DomSt#canCall($Heap, this, st#3);
        paths#22 := _module.__default.DomSt($Heap, this, st#3);
        st#23 := st'#17;
        assert Set#Subset(paths#22, _module.__default.DomSt($Heap, this, st#23));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, st#3), st'#17);
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#16)), _module.__default.DomSt($Heap, this, st'#17)) && Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, st'#17)) && st#3 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st#3), st'#17))
    {
        cmd#24 := cmd#0;
        deps#25 := deps#1;
        exts#26 := exts#2;
        paths#27 := expr'#16;
        assert _module.Expression.exprLiteral_q(cmd#24) && _module.Literal.litString_q(_module.Expression.lit(cmd#24)) && _module.Expression.exprLiteral_q(deps#25) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#25)) && _module.Expression.exprLiteral_q(exts#26) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#26)) && _module.Expression.exprLiteral_q(paths#27) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#27));
        assume _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, expr'#16);
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#16)), _module.__default.DomSt($Heap, this, st'#17)) && Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, st'#17)) && st#3 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st#3), st'#17) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, expr'#16))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        paths#28 := _module.Literal.paths(_module.Expression.lit(deps#1));
        st#29 := st'#17;
        assert Set#Subset(paths#28, _module.__default.DomSt($Heap, this, st#29));
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st'#17);
        cmd#30 := cmd#0;
        deps#31 := deps#1;
        exts#32 := exts#2;
        st#33 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st'#17);
        assert _module.Expression.exprLiteral_q(cmd#30) && _module.Literal.litString_q(_module.Expression.lit(cmd#30)) && _module.Expression.exprLiteral_q(deps#31) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#31)) && _module.Expression.exprLiteral_q(exts#32) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#32));
        assume _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st'#17));
    }

    if (_module.Expression.exprLiteral_q(expr'#16) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#16)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#16)), _module.__default.DomSt($Heap, this, st'#17)) && Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, st'#17)) && st#3 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st#3), st'#17) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, expr'#16) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st'#17)))
    {
        havoc p#34;
        assume DtAlloc(p#34, $Heap) && DtType(p#34) == class._module.Path;
        st#35 := st#3;
        assume _module.__default.DomSt#canCall($Heap, this, st#3);
        if (!_module.__default.DomSt($Heap, this, st#3)[$Box(p#34)])
        {
            st#36 := st'#17;
            assume _module.__default.DomSt#canCall($Heap, this, st'#17);
        }

        if (!_module.__default.DomSt($Heap, this, st#3)[$Box(p#34)] && _module.__default.DomSt($Heap, this, st'#17)[$Box(p#34)])
        {
        }
    }

    assume _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) && Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) && st#3 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st#3), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) && (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#3)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))[$Box(p#37)] ==> _module.Path.OpaquePath_q(p#37));
}



procedure InterModuleCall$$_module.__default.ExecProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), st#3: BoxType where GenericAlloc(st#3, $Heap));
  // user-defined preconditions
  requires _module.Expression.exprLiteral_q(cmd#0);
  requires _module.Literal.litString_q(_module.Expression.lit(cmd#0));
  requires _module.Expression.exprLiteral_q(deps#1);
  requires _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
  requires _module.Expression.exprLiteral_q(exts#2);
  requires _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
  requires Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, st#3));
  requires _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType);
  ensures _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType));
  ensures Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))));
  ensures st#3 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st#3), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)));
  ensures _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType);
  ensures _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))));
  ensures (forall p#38: DatatypeType :: DtAlloc(p#38, $Heap) && DtType(p#38) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#3)[$Box(p#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))[$Box(p#38)] ==> _module.Path.OpaquePath_q(p#38));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.ExecProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), st#3: BoxType where GenericAlloc(st#3, $Heap));
  // user-defined preconditions
  requires _module.Expression.exprLiteral_q(cmd#0);
  requires _module.Literal.litString_q(_module.Expression.lit(cmd#0));
  requires _module.Expression.exprLiteral_q(deps#1);
  requires _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
  requires _module.Expression.exprLiteral_q(exts#2);
  requires _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
  requires Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, st#3));
  free requires _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) && _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) && (forall e#39: BoxType :: GenericAlloc(e#39, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#39] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#39))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#39), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#39, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)));
  requires _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) ==> _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) || (forall e#40: BoxType :: GenericAlloc(e#40, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#40] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#40))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#40), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#40, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), st#3)));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType);
  ensures _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType));
  ensures Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#3), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))));
  ensures st#3 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st#3), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)));
  free ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) && (forall e#41: BoxType :: GenericAlloc(e#41, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#41] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#41))]);
  ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) ==> _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType) || (forall e#42: BoxType :: GenericAlloc(e#42, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#42] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#42))]);
  free ensures _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) && (forall e#43: BoxType :: GenericAlloc(e#43, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#43] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#43))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#43), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#43, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))));
  ensures _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) ==> _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) || (forall e#44: BoxType :: GenericAlloc(e#44, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#44] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3))))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#44))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#44), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#44, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))));
  ensures (forall p#45: DatatypeType :: DtAlloc(p#45, $Heap) && DtType(p#45) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#3)[$Box(p#45)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, st#3)))[$Box(p#45)] ==> _module.Path.OpaquePath_q(p#45));
  // frame condition
  free ensures old($Heap) == $Heap;



// function declaration for _module._default.Pre
function _module.__default.Pre($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : bool;

function _module.__default.Pre#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : bool;

// frame axiom for _module.__default.Pre
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Pre($h1, this, cmd#0, deps#1, exts#2, st#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Pre#canCall($h0, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h0))) && (_module.__default.Pre#canCall($h1, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Pre($h0, this, cmd#0, deps#1, exts#2, st#3) == _module.__default.Pre($h1, this, cmd#0, deps#1, exts#2, st#3));

// consequence axiom for _module.__default.Pre
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 20 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || ((0 != $ModuleContextHeight || 20 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> true);

// definition axiom for _module.__default.Pre (intra-module)
axiom 0 == $ModuleContextHeight && 20 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || (20 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.DomSt#canCall($Heap, this, st#3) && (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4), st#3) && _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#4, st#3))) && _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, st#3) == (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4), st#3) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#4, st#3)));

// definition axiom for _module.__default.Pre for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 20 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: {:weight 10} { _module.__default.Pre($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) } _module.__default.Pre#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) || (20 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.DomSt#canCall($Heap, this, Lit(st#3)) && (_module.__default.DomSt($Heap, this, Lit(st#3))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5), Lit(st#3)) && _module.__default.Res#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5, Lit(st#3)))) && _module.__default.Pre($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) == (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.DomSt($Heap, this, Lit(st#3))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5), Lit(st#3)) == _module.__default.Res($Heap, this, Lit(cmd#0), Lit(deps#1), e#5, Lit(st#3))));

// definition axiom for _module.__default.Pre (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> true);

// definition axiom for _module.__default.Pre for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: {:weight 10} { _module.__default.Pre($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) } _module.__default.Pre#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> true);

procedure CheckWellformed$$_module.__default.Pre(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, st#3: BoxType where GenericAlloc(st#3, $Heap));
  free requires 0 == $ModuleContextHeight && 20 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Pre(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var e#6: BoxType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var ext#9: BoxType;
  var st#10: BoxType;
  var cmd#11: DatatypeType;
  var deps#12: DatatypeType;
  var ext#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var cmd#16: DatatypeType;
  var deps#17: DatatypeType;
  var ext#18: BoxType;
  var st#19: BoxType;

    assume {:captureState "CachedBuilds0.dfy(140,11): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc e#6;
        assume GenericAlloc(e#6, $Heap);
        assert _module.Expression.exprLiteral_q(exts#2);
        assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
        if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#6])
        {
            cmd#7 := cmd#0;
            deps#8 := deps#1;
            ext#9 := e#6;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#6);
            st#10 := st#3;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, st#3);
            if (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#6))])
            {
                cmd#11 := cmd#0;
                deps#12 := deps#1;
                ext#13 := e#6;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#6);
                p#14 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#6);
                st#15 := st#3;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#6), st#3);
                cmd#16 := cmd#0;
                deps#17 := deps#1;
                ext#18 := e#6;
                st#19 := st#3;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#6, st#3);
            }
        }

        assume _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, st#3) == (forall e#20: BoxType :: GenericAlloc(e#20, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#20] ==> _module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#20))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#20), st#3) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#20, st#3));
        assume (forall e#20: BoxType :: GenericAlloc(e#20, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#20] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#20) && _module.__default.DomSt#canCall($Heap, this, st#3) && (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#20))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#20) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#20), st#3) && _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#20, st#3)));
    }
}



// function declaration for _module._default.Post
function _module.__default.Post($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : bool;

function _module.__default.Post#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType) : bool;

// frame axiom for _module.__default.Post
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Post($h1, this, cmd#0, deps#1, exts#2, st#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Post#canCall($h0, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h0))) && (_module.__default.Post#canCall($h1, this, cmd#0, deps#1, exts#2, st#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Post($h0, this, cmd#0, deps#1, exts#2, st#3) == _module.__default.Post($h1, this, cmd#0, deps#1, exts#2, st#3));

// consequence axiom for _module.__default.Post
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 23 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || ((0 != $ModuleContextHeight || 23 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> true);

// definition axiom for _module.__default.Post (intra-module)
axiom 0 == $ModuleContextHeight && 23 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || (23 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.DomSt#canCall($Heap, this, st#3) && (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4), st#3) && _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#4, st#3))) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, st#3) == (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4), st#3) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#4, st#3)));

// definition axiom for _module.__default.Post for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 23 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: {:weight 10} { _module.__default.Post($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) } _module.__default.Post#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) || (23 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.DomSt#canCall($Heap, this, Lit(st#3)) && (_module.__default.DomSt($Heap, this, Lit(st#3))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5), Lit(st#3)) && _module.__default.Res#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5, Lit(st#3)))) && _module.__default.Post($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) == (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.DomSt($Heap, this, Lit(st#3))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5), Lit(st#3)) == _module.__default.Res($Heap, this, Lit(cmd#0), Lit(deps#1), e#5, Lit(st#3))));

// definition axiom for _module.__default.Post (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: { _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, st#3) } _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, st#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && GenericAlloc(st#3, $Heap) && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> true);

// definition axiom for _module.__default.Post for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType :: {:weight 10} { _module.__default.Post($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) } _module.__default.Post#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(st#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> true);

procedure CheckWellformed$$_module.__default.Post(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, st#3: BoxType where GenericAlloc(st#3, $Heap));
  free requires 0 == $ModuleContextHeight && 23 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Post(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, st#3: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var e#6: BoxType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var ext#9: BoxType;
  var st#10: BoxType;
  var cmd#11: DatatypeType;
  var deps#12: DatatypeType;
  var ext#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var cmd#16: DatatypeType;
  var deps#17: DatatypeType;
  var ext#18: BoxType;
  var st#19: BoxType;

    assume {:captureState "CachedBuilds0.dfy(150,11): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc e#6;
        assume GenericAlloc(e#6, $Heap);
        assert _module.Expression.exprLiteral_q(exts#2);
        assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
        if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#6])
        {
            cmd#7 := cmd#0;
            deps#8 := deps#1;
            ext#9 := e#6;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#6);
            st#10 := st#3;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomSt#canCall($Heap, this, st#3);
            if (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#6))])
            {
                cmd#11 := cmd#0;
                deps#12 := deps#1;
                ext#13 := e#6;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#6);
                p#14 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#6);
                st#15 := st#3;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#6), st#3);
                cmd#16 := cmd#0;
                deps#17 := deps#1;
                ext#18 := e#6;
                st#19 := st#3;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#6, st#3);
            }
        }

        assume _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, st#3) == (forall e#20: BoxType :: GenericAlloc(e#20, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#20] ==> _module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#20))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#20), st#3) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#20, st#3));
        assume (forall e#20: BoxType :: GenericAlloc(e#20, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#20] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#20) && _module.__default.DomSt#canCall($Heap, this, st#3) && (_module.__default.DomSt($Heap, this, st#3)[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#20))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#20) && _module.__default.GetSt#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#20), st#3) && _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, e#20, st#3)));
    }
}



// function declaration for _module._default.Res
function _module.__default.Res($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType, st#3: BoxType) : BoxType;

function _module.__default.Res#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType, st#3: BoxType) : bool;

// frame axiom for _module.__default.Res
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType, st#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Res($h1, this, cmd#0, deps#1, ext#2, st#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Res#canCall($h0, this, cmd#0, deps#1, ext#2, st#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $h0) && GenericAlloc(st#3, $h0))) && (_module.__default.Res#canCall($h1, this, cmd#0, deps#1, ext#2, st#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $h1) && GenericAlloc(st#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Res($h0, this, cmd#0, deps#1, ext#2, st#3) == _module.__default.Res($h1, this, cmd#0, deps#1, ext#2, st#3));

// consequence axiom for _module.__default.Res
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 19 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType, st#3: BoxType :: { _module.__default.Res($Heap, this, cmd#0, deps#1, ext#2, st#3) } _module.__default.Res#canCall($Heap, this, cmd#0, deps#1, ext#2, st#3) || ((0 != $ModuleContextHeight || 19 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $Heap) && GenericAlloc(st#3, $Heap)) ==> GenericAlloc(_module.__default.Res($Heap, this, cmd#0, deps#1, ext#2, st#3), $Heap));

procedure CheckWellformed$$_module.__default.Res(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, ext#2: BoxType where GenericAlloc(ext#2, $Heap), st#3: BoxType where GenericAlloc(st#3, $Heap));
  free requires 0 == $ModuleContextHeight && 19 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Res(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType, st#3: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(160,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.Res($Heap, this, cmd#0, deps#1, ext#2, st#3), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.Res'
function _module.__default.Res_k($ly: LayerType, $heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType) : BoxType;

function _module.__default.Res_k#canCall($heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType :: { _module.__default.Res_k($LS($ly), $Heap, this, p#0, st#1) } _module.__default.Res_k($LS($ly), $Heap, this, p#0, st#1) == _module.__default.Res_k($ly, $Heap, this, p#0, st#1));

// frame axiom for _module.__default.Res_k
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Res_k($ly, $h1, this, p#0, st#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Res_k#canCall($h0, this, p#0, st#1) || (DtAlloc(p#0, $h0) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $h0))) && (_module.__default.Res_k#canCall($h1, this, p#0, st#1) || (DtAlloc(p#0, $h1) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Res_k($ly, $h0, this, p#0, st#1) == _module.__default.Res_k($ly, $h1, this, p#0, st#1));

// consequence axiom for _module.__default.Res_k
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 25 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, p#0: DatatypeType, st#1: BoxType :: { _module.__default.Res_k($LS($ly), $Heap, this, p#0, st#1) } _module.__default.Res_k#canCall($Heap, this, p#0, st#1) || ((0 != $ModuleContextHeight || 25 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path && GenericAlloc(st#1, $Heap)) ==> (exists cmd#2: DatatypeType, deps#3: DatatypeType, ext#4: BoxType :: DtAlloc(cmd#2, $Heap) && DtType(cmd#2) == class._module.Expression && DtAlloc(deps#3, $Heap) && DtType(deps#3) == class._module.Expression && GenericAlloc(ext#4, $Heap) && p#0 == _module.__default.Loc($Heap, this, cmd#2, deps#3, ext#4) && _module.__default.Res_k($LS($LZ), $Heap, this, p#0, st#1) == _module.__default.Res($Heap, this, cmd#2, deps#3, ext#4, st#1) && (forall cmd'#5: DatatypeType, deps'#6: DatatypeType, ext'#7: BoxType :: DtAlloc(cmd'#5, $Heap) && DtType(cmd'#5) == class._module.Expression && DtAlloc(deps'#6, $Heap) && DtType(deps'#6) == class._module.Expression && GenericAlloc(ext'#7, $Heap) ==> p#0 == _module.__default.Loc($Heap, this, cmd#2, deps#3, ext#4) ==> cmd#2 == cmd'#5 && deps#3 == deps'#6 && ext#4 == ext'#7)) && GenericAlloc(_module.__default.Res_k($LS($ly), $Heap, this, p#0, st#1), $Heap));

procedure CheckWellformed$$_module.__default.Res_k(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, p#0: DatatypeType where DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path, st#1: BoxType where GenericAlloc(st#1, $Heap));
  free requires 0 == $ModuleContextHeight && 25 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  ensures (exists cmd#8: DatatypeType, deps#9: DatatypeType, ext#10: BoxType :: DtAlloc(cmd#8, $Heap) && DtType(cmd#8) == class._module.Expression && DtAlloc(deps#9, $Heap) && DtType(deps#9) == class._module.Expression && GenericAlloc(ext#10, $Heap) && p#0 == _module.__default.Loc($Heap, this, cmd#8, deps#9, ext#10) && _module.__default.Res_k($LS($LZ), $Heap, this, p#0, st#1) == _module.__default.Res($Heap, this, cmd#8, deps#9, ext#10, st#1) && (forall cmd'#11: DatatypeType, deps'#12: DatatypeType, ext'#13: BoxType :: DtAlloc(cmd'#11, $Heap) && DtType(cmd'#11) == class._module.Expression && DtAlloc(deps'#12, $Heap) && DtType(deps'#12) == class._module.Expression && GenericAlloc(ext'#13, $Heap) ==> p#0 == _module.__default.Loc($Heap, this, cmd#8, deps#9, ext#10) ==> cmd#8 == cmd'#11 && deps#9 == deps'#12 && ext#10 == ext'#13));



implementation CheckWellformed$$_module.__default.Res_k(this: ref, p#0: DatatypeType, st#1: BoxType)
{
  var cmd#14: DatatypeType;
  var deps#15: DatatypeType;
  var ext#16: BoxType;
  var cmd#17: DatatypeType;
  var deps#18: DatatypeType;
  var ext#19: BoxType;
  var p#20: DatatypeType;
  var st#21: BoxType;
  var cmd#22: DatatypeType;
  var deps#23: DatatypeType;
  var ext#24: BoxType;
  var st#25: BoxType;
  var cmd'#26: DatatypeType;
  var deps'#27: DatatypeType;
  var ext'#28: BoxType;
  var cmd#29: DatatypeType;
  var deps#30: DatatypeType;
  var ext#31: BoxType;

    assume {:captureState "CachedBuilds0.dfy(162,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.Res_k($LS($LZ), $Heap, this, p#0, st#1), $Heap);
        havoc cmd#14;
        assume DtAlloc(cmd#14, $Heap) && DtType(cmd#14) == class._module.Expression;
        havoc deps#15;
        assume DtAlloc(deps#15, $Heap) && DtType(deps#15) == class._module.Expression;
        havoc ext#16;
        assume GenericAlloc(ext#16, $Heap);
        cmd#17 := cmd#14;
        deps#18 := deps#15;
        ext#19 := ext#16;
        assume _module.__default.Loc#canCall($Heap, this, cmd#14, deps#15, ext#16);
        if (p#0 == _module.__default.Loc($Heap, this, cmd#14, deps#15, ext#16))
        {
            p#20 := p#0;
            st#21 := st#1;
            assert (this == this && p#0 == p#0 && st#1 == st#1) || DtRank(p#20) < DtRank(p#0);
            assume (this == this && p#0 == p#0 && st#1 == st#1) || _module.__default.Res_k#canCall($Heap, this, p#0, st#1);
            cmd#22 := cmd#14;
            deps#23 := deps#15;
            ext#24 := ext#16;
            st#25 := st#1;
            assume _module.__default.Res#canCall($Heap, this, cmd#14, deps#15, ext#16, st#1);
        }

        if (p#0 == _module.__default.Loc($Heap, this, cmd#14, deps#15, ext#16) && _module.__default.Res_k($LS($LZ), $Heap, this, p#0, st#1) == _module.__default.Res($Heap, this, cmd#14, deps#15, ext#16, st#1))
        {
            havoc cmd'#26;
            assume DtAlloc(cmd'#26, $Heap) && DtType(cmd'#26) == class._module.Expression;
            havoc deps'#27;
            assume DtAlloc(deps'#27, $Heap) && DtType(deps'#27) == class._module.Expression;
            havoc ext'#28;
            assume GenericAlloc(ext'#28, $Heap);
            cmd#29 := cmd#14;
            deps#30 := deps#15;
            ext#31 := ext#16;
            assume _module.__default.Loc#canCall($Heap, this, cmd#14, deps#15, ext#16);
            if (p#0 == _module.__default.Loc($Heap, this, cmd#14, deps#15, ext#16))
            {
                if (cmd#14 == cmd'#26)
                {
                }

                if (cmd#14 == cmd'#26 && deps#15 == deps'#27)
                {
                }
            }
        }

        assume (exists cmd#8: DatatypeType, deps#9: DatatypeType, ext#10: BoxType :: DtAlloc(cmd#8, $Heap) && DtType(cmd#8) == class._module.Expression && DtAlloc(deps#9, $Heap) && DtType(deps#9) == class._module.Expression && GenericAlloc(ext#10, $Heap) && p#0 == _module.__default.Loc($Heap, this, cmd#8, deps#9, ext#10) && _module.__default.Res_k($LS($LZ), $Heap, this, p#0, st#1) == _module.__default.Res($Heap, this, cmd#8, deps#9, ext#10, st#1) && (forall cmd'#11: DatatypeType, deps'#12: DatatypeType, ext'#13: BoxType :: DtAlloc(cmd'#11, $Heap) && DtType(cmd'#11) == class._module.Expression && DtAlloc(deps'#12, $Heap) && DtType(deps'#12) == class._module.Expression && GenericAlloc(ext'#13, $Heap) ==> p#0 == _module.__default.Loc($Heap, this, cmd#8, deps#9, ext#10) ==> cmd#8 == cmd'#11 && deps#9 == deps'#12 && ext#10 == ext'#13));
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.OneToOne
function _module.__default.OneToOne($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType) : bool;

function _module.__default.OneToOne#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType) : bool;

// frame axiom for _module.__default.OneToOne
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.OneToOne($h1, this, cmd#0, deps#1, exts#2, paths#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.OneToOne#canCall($h0, this, cmd#0, deps#1, exts#2, paths#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && DtAlloc(paths#3, $h0) && DtType(paths#3) == class._module.Expression)) && (_module.__default.OneToOne#canCall($h1, this, cmd#0, deps#1, exts#2, paths#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && DtAlloc(paths#3, $h1) && DtType(paths#3) == class._module.Expression)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.OneToOne($h0, this, cmd#0, deps#1, exts#2, paths#3) == _module.__default.OneToOne($h1, this, cmd#0, deps#1, exts#2, paths#3));

// consequence axiom for _module.__default.OneToOne
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 22 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: { _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, paths#3) } _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, paths#3) || ((0 != $ModuleContextHeight || 22 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(paths#3, $Heap) && DtType(paths#3) == class._module.Expression && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && _module.Expression.exprLiteral_q(paths#3) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#3))) ==> true);

// definition axiom for _module.__default.OneToOne (intra-module)
axiom 0 == $ModuleContextHeight && 22 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: { _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, paths#3) } _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, paths#3) || (22 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(paths#3, $Heap) && DtType(paths#3) == class._module.Expression && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && _module.Expression.exprLiteral_q(paths#3) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#3))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4)) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, paths#3) == (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.Literal.paths(_module.Expression.lit(paths#3))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))]));

// definition axiom for _module.__default.OneToOne for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 22 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: {:weight 10} { _module.__default.OneToOne($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(paths#3)) } _module.__default.OneToOne#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(paths#3)) || (22 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && _module.Expression.exprLiteral_q(Lit(paths#3)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(paths#3)))) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5)) && _module.__default.OneToOne($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(paths#3)) == (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.Literal.paths(_module.Expression.lit(Lit(paths#3)))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))]));

// definition axiom for _module.__default.OneToOne (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: { _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, paths#3) } _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, paths#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(paths#3, $Heap) && DtType(paths#3) == class._module.Expression && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && _module.Expression.exprLiteral_q(paths#3) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#3))) ==> true);

// definition axiom for _module.__default.OneToOne for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType :: {:weight 10} { _module.__default.OneToOne($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(paths#3)) } _module.__default.OneToOne#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(paths#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && _module.Expression.exprLiteral_q(Lit(paths#3)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(paths#3)))) ==> true);

procedure CheckWellformed$$_module.__default.OneToOne(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, paths#3: DatatypeType where DtAlloc(paths#3, $Heap) && DtType(paths#3) == class._module.Expression);
  free requires 0 == $ModuleContextHeight && 22 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.OneToOne(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, paths#3: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var e#6: BoxType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var ext#9: BoxType;

    assume {:captureState "CachedBuilds0.dfy(169,11): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && _module.Expression.exprLiteral_q(paths#3))
    {
        assert _module.Expression.exprLiteral_q(paths#3);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && _module.Expression.exprLiteral_q(paths#3) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#3));
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc e#6;
        assume GenericAlloc(e#6, $Heap);
        assert _module.Expression.exprLiteral_q(exts#2);
        assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
        if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#6])
        {
            cmd#7 := cmd#0;
            deps#8 := deps#1;
            ext#9 := e#6;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#6);
            assert _module.Expression.exprLiteral_q(paths#3);
            assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#3));
        }

        assume _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, paths#3) == (forall e#10: BoxType :: GenericAlloc(e#10, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#10] ==> _module.Literal.paths(_module.Expression.lit(paths#3))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#10))]);
        assume (forall e#10: BoxType :: GenericAlloc(e#10, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#10] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#10));
    }
}



// function declaration for _module._default.Loc
function _module.__default.Loc($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType) : DatatypeType;

function _module.__default.Loc#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType) : bool;

// frame axiom for _module.__default.Loc
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.Loc($h1, this, cmd#0, deps#1, ext#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Loc#canCall($h0, this, cmd#0, deps#1, ext#2) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $h0))) && (_module.__default.Loc#canCall($h1, this, cmd#0, deps#1, ext#2) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Loc($h0, this, cmd#0, deps#1, ext#2) == _module.__default.Loc($h1, this, cmd#0, deps#1, ext#2));

// consequence axiom for _module.__default.Loc
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 7 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType :: { _module.__default.Loc($Heap, this, cmd#0, deps#1, ext#2) } _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, ext#2) || ((0 != $ModuleContextHeight || 7 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && GenericAlloc(ext#2, $Heap)) ==> DtAlloc(_module.__default.Loc($Heap, this, cmd#0, deps#1, ext#2), $Heap) && DtType(_module.__default.Loc($Heap, this, cmd#0, deps#1, ext#2)) == class._module.Path);

procedure CheckWellformed$$_module.__default.Loc(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, ext#2: BoxType where GenericAlloc(ext#2, $Heap));
  free requires 0 == $ModuleContextHeight && 7 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Loc(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, ext#2: BoxType)
{
    assume {:captureState "CachedBuilds0.dfy(179,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.Loc($Heap, this, cmd#0, deps#1, ext#2), $Heap) && DtType(_module.__default.Loc($Heap, this, cmd#0, deps#1, ext#2)) == class._module.Path;
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.execC
function _module.__default.execC($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : DatatypeType;

function _module.__default.execC#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

// frame axiom for _module.__default.execC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.execC($h1, this, cmd#0, deps#1, exts#2, stC#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.execC#canCall($h0, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h0) && DtType(stC#3) == class._module.StateC)) && (_module.__default.execC#canCall($h1, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h1) && DtType(stC#3) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.execC($h0, this, cmd#0, deps#1, exts#2, stC#3) == _module.__default.execC($h1, this, cmd#0, deps#1, exts#2, stC#3));

// consequence axiom for _module.__default.execC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 26 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ((0 != $ModuleContextHeight || 26 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> DtAlloc(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3), $Heap) && DtType(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3)) == class._module.Tuple);

// definition axiom for _module.__default.execC (intra-module)
axiom 0 == $ModuleContextHeight && 26 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (26 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3))) && ((forall e#4: BoxType :: GenericAlloc(e#4, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))]) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#5] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#5))) && (!(forall e#4: BoxType :: GenericAlloc(e#4, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))]) ==> _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3)) && _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, #_module.StateC.S(_module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3))), _module.StateC.c(stC#3)))) && _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == (if (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))]) then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litArrOfPaths((lambda $y#1: BoxType :: (exists e#5: BoxType :: GenericAlloc(e#5, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#5] && $y#1 == $Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#5))))))), $Box(stC#3)) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3)))): DatatypeType), $Box(_module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, #_module.StateC.S(_module.Tuple.snd(_module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3))), _module.StateC.c(stC#3)))))));

// definition axiom for _module.__default.execC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 26 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.execC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.execC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || (26 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> (forall e#6: BoxType :: GenericAlloc(e#6, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#6] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#6) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#6)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(Lit(stC#3)))) && ((forall e#6: BoxType :: GenericAlloc(e#6, $Heap) && _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#6] ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#6))]) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))) && (!(forall e#6: BoxType :: GenericAlloc(e#6, $Heap) && _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#6] ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#6))]) ==> _module.__default.exec#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.StateC.st(Lit(stC#3))) && _module.__default.UpdateC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), #_module.StateC.S(_module.Tuple.snd(_module.__default.exec($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.StateC.st(Lit(stC#3)))), _module.StateC.c(Lit(stC#3))))) && _module.__default.execC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) == (if (forall e#6: BoxType :: GenericAlloc(e#6, $Heap) && _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#6] ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#6))]) then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litArrOfPaths((lambda $y#3: BoxType :: (exists e#5: BoxType :: GenericAlloc(e#5, $Heap) && _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] && $y#3 == $Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))))))), $Box(Lit(stC#3))) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.exec($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.StateC.st(Lit(stC#3))))): DatatypeType), $Box(_module.__default.UpdateC($LS($LZ), $Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), #_module.StateC.S(_module.Tuple.snd(_module.__default.exec($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.StateC.st(Lit(stC#3)))), _module.StateC.c(Lit(stC#3))))))));

// definition axiom for _module.__default.execC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2))) ==> true);

// definition axiom for _module.__default.execC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.execC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.execC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2)))) ==> true);

procedure CheckWellformed$$_module.__default.execC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 26 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.execC(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var e#7: BoxType;
  var cmd#8: DatatypeType;
  var deps#9: DatatypeType;
  var ext#10: BoxType;
  var p#11: DatatypeType;
  var c#12: BoxType;
  var paths#13: Set BoxType;
  var e#14: BoxType;
  var cmd#15: DatatypeType;
  var deps#16: DatatypeType;
  var ext#17: BoxType;
  var expr'#18: DatatypeType;
  var result#19: DatatypeType;
  var cmd#20: DatatypeType;
  var deps#21: DatatypeType;
  var exts#22: DatatypeType;
  var st#23: BoxType;
  var expr'#24: DatatypeType;
  var st'#25: BoxType;
  var stC'#26: DatatypeType;
  var cmd#27: DatatypeType;
  var deps#28: DatatypeType;
  var exts#29: DatatypeType;
  var stC#30: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(182,10): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
    if (*)
    {
        assume DtAlloc(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3), $Heap) && DtType(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        havoc e#7;
        assume GenericAlloc(e#7, $Heap);
        assert _module.Expression.exprLiteral_q(exts#2);
        assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
        if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#7])
        {
            cmd#8 := cmd#0;
            deps#9 := deps#1;
            ext#10 := e#7;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#7);
            p#11 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#7);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#7));
            assume _module.StateC.S_q(stC#3);
            c#12 := _module.StateC.c(stC#3);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3));
        }

        if ((forall e#31: BoxType :: GenericAlloc(e#31, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#31] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#31))]))
        {
            havoc e#14;
            assume GenericAlloc(e#14, $Heap);
            assert _module.Expression.exprLiteral_q(exts#2);
            assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
            if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#14])
            {
                cmd#15 := cmd#0;
                deps#16 := deps#1;
                ext#17 := e#14;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#14);
            }

            assume paths#13 == (lambda $y#4: BoxType :: (exists e#5: BoxType :: GenericAlloc(e#5, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#5] && $y#4 == $Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#5))));
            assume (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#5] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#5));
            assume expr'#18 == #_module.Expression.exprLiteral(#_module.Literal.litArrOfPaths(paths#13));
            assume true;
            assume _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == #_module.Tuple.Pair($Box(expr'#18), $Box(stC#3));
            assume true;
        }
        else
        {
            assume _module.StateC.S_q(stC#3);
            cmd#20 := cmd#0;
            deps#21 := deps#1;
            exts#22 := exts#2;
            st#23 := _module.StateC.st(stC#3);
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
            assume result#19 == _module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
            assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
            assume _module.Tuple.Pair_q(result#19);
            assume expr'#24 == $Unbox(_module.Tuple.fst(result#19)): DatatypeType;
            assume true;
            assume _module.Tuple.Pair_q(result#19);
            assume st'#25 == _module.Tuple.snd(result#19);
            assume true;
            assume _module.StateC.S_q(stC#3);
            cmd#27 := cmd#0;
            deps#28 := deps#1;
            exts#29 := exts#2;
            stC#30 := #_module.StateC.S(st'#25, _module.StateC.c(stC#3));
            assert _module.Expression.exprLiteral_q(cmd#27) && _module.Literal.litString_q(_module.Expression.lit(cmd#27)) && _module.Expression.exprLiteral_q(deps#28) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#28)) && _module.Expression.exprLiteral_q(exts#29) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#29));
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, #_module.StateC.S(st'#25, _module.StateC.c(stC#3)));
            assume stC'#26 == _module.__default.UpdateC($LS($LZ), $Heap, this, cmd#0, deps#1, exts#2, #_module.StateC.S(st'#25, _module.StateC.c(stC#3)));
            assume _module.__default.UpdateC#canCall($Heap, this, cmd#0, deps#1, exts#2, #_module.StateC.S(st'#25, _module.StateC.c(stC#3)));
            assume _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == #_module.Tuple.Pair($Box(expr'#24), $Box(stC'#26));
            assume true;
        }
    }
}



procedure CheckWellformed$$_module.__default.ExecCProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && $IsA#_module.StateC(stC#3));
  free requires 0 == $ModuleContextHeight && 29 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.ExecCProperty(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var st#4: BoxType;
  var cmd#5: DatatypeType;
  var deps#6: DatatypeType;
  var exts#7: DatatypeType;
  var stC#8: DatatypeType;
  var result#9: DatatypeType;
  var cmd#10: DatatypeType;
  var deps#11: DatatypeType;
  var exts#12: DatatypeType;
  var stC#13: DatatypeType;
  var expr'#14: DatatypeType;
  var stC'#15: DatatypeType;
  var st#16: BoxType;
  var st#17: BoxType;
  var st#18: BoxType;
  var st#19: BoxType;
  var paths#20: Set BoxType;
  var st#21: BoxType;
  var cmd#22: DatatypeType;
  var deps#23: DatatypeType;
  var exts#24: DatatypeType;
  var paths#25: DatatypeType;
  var cmd#26: DatatypeType;
  var deps#27: DatatypeType;
  var exts#28: DatatypeType;
  var stC#29: DatatypeType;
  var p#30: DatatypeType;
  var st#31: BoxType;
  var st#32: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(199,14): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        assume _module.StateC.S_q(stC#3);
        st#4 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))))
    {
        cmd#5 := cmd#0;
        deps#6 := deps#1;
        exts#7 := exts#2;
        stC#8 := stC#3;
        assert _module.Expression.exprLiteral_q(cmd#5) && _module.Literal.litString_q(_module.Expression.lit(cmd#5)) && _module.Expression.exprLiteral_q(deps#6) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#6)) && _module.Expression.exprLiteral_q(exts#7) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#7)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#6)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#8)));
        assume _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))) && _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(207,5): post-state"} true;
    cmd#10 := cmd#0;
    deps#11 := deps#1;
    exts#12 := exts#2;
    stC#13 := stC#3;
    assert _module.Expression.exprLiteral_q(cmd#10) && _module.Literal.litString_q(_module.Expression.lit(cmd#10)) && _module.Expression.exprLiteral_q(deps#11) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#11)) && _module.Expression.exprLiteral_q(exts#12) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#12));
    assume _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    assume result#9 == _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    assume _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    assume _module.Tuple.Pair_q(result#9);
    assume expr'#14 == $Unbox(_module.Tuple.fst(result#9)): DatatypeType;
    assume true;
    assume _module.Tuple.Pair_q(result#9);
    assume stC'#15 == $Unbox(_module.Tuple.snd(result#9)): DatatypeType;
    assume true;
    if (_module.Expression.exprLiteral_q(expr'#14))
    {
        assert _module.Expression.exprLiteral_q(expr'#14);
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)))
    {
        assert _module.Expression.exprLiteral_q(expr'#14);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14));
        assume _module.StateC.S_q(stC'#15);
        st#16 := _module.StateC.st(stC'#15);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#15));
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#14)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))))
    {
        assume _module.StateC.S_q(stC#3);
        st#17 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
        assume _module.StateC.S_q(stC'#15);
        st#18 := _module.StateC.st(stC'#15);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#15));
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#14)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))))
    {
        assume _module.StateC.S_q(stC#3);
        assume _module.StateC.S_q(stC#3);
        st#19 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
        assume _module.StateC.S_q(stC'#15);
        paths#20 := _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3));
        st#21 := _module.StateC.st(stC'#15);
        assert Set#Subset(paths#20, _module.__default.DomSt($Heap, this, st#21));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#15));
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#14)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#15)))
    {
        cmd#22 := cmd#0;
        deps#23 := deps#1;
        exts#24 := exts#2;
        paths#25 := expr'#14;
        assert _module.Expression.exprLiteral_q(cmd#22) && _module.Literal.litString_q(_module.Expression.lit(cmd#22)) && _module.Expression.exprLiteral_q(deps#23) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#23)) && _module.Expression.exprLiteral_q(exts#24) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#24)) && _module.Expression.exprLiteral_q(paths#25) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(paths#25));
        assume _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, expr'#14);
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#14)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#15)) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, expr'#14))
    {
        cmd#26 := cmd#0;
        deps#27 := deps#1;
        exts#28 := exts#2;
        stC#29 := stC'#15;
        assert _module.Expression.exprLiteral_q(cmd#26) && _module.Literal.litString_q(_module.Expression.lit(cmd#26)) && _module.Expression.exprLiteral_q(deps#27) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#27)) && _module.Expression.exprLiteral_q(exts#28) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#28)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#27)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#29)));
        assume _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC'#15);
    }

    if (_module.Expression.exprLiteral_q(expr'#14) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(expr'#14)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(expr'#14)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))) && _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#15)) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, expr'#14) && _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC'#15))
    {
        havoc p#30;
        assume DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path;
        assume _module.StateC.S_q(stC#3);
        st#31 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#30)])
        {
            assume _module.StateC.S_q(stC'#15);
            st#32 := _module.StateC.st(stC'#15);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#15));
        }

        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#30)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#15))[$Box(p#30)])
        {
        }
    }

    assume _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) && _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(p#33)] ==> _module.Path.OpaquePath_q(p#33));
}



procedure InterModuleCall$$_module.__default.ExecCProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && $IsA#_module.StateC(stC#3));
  // user-defined preconditions
  requires _module.Expression.exprLiteral_q(cmd#0);
  requires _module.Literal.litString_q(_module.Expression.lit(cmd#0));
  requires _module.Expression.exprLiteral_q(deps#1);
  requires _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
  requires _module.Expression.exprLiteral_q(exts#2);
  requires _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
  requires Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)));
  requires _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3);
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType);
  ensures _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  ensures Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  ensures _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType);
  ensures _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType);
  ensures (forall p#34: DatatypeType :: DtAlloc(p#34, $Heap) && DtType(p#34) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#34)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(p#34)] ==> _module.Path.OpaquePath_q(p#34));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.ExecCProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && $IsA#_module.StateC(stC#3));
  // user-defined preconditions
  requires _module.Expression.exprLiteral_q(cmd#0);
  requires _module.Literal.litString_q(_module.Expression.lit(cmd#0));
  requires _module.Expression.exprLiteral_q(deps#1);
  requires _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
  requires _module.Expression.exprLiteral_q(exts#2);
  requires _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
  requires Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)));
  free requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) && _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) && _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#35: BoxType :: GenericAlloc(e#35, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#35] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#35))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#35))]);
  requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) ==> _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (_module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) || (forall e#37: BoxType :: GenericAlloc(e#37, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#37] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#37))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#37), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#37, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)))));
  requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) ==> _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (forall e#38: BoxType :: GenericAlloc(e#38, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#38] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#38))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#38))]);
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType);
  ensures _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  ensures Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  free ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && (forall e#39: BoxType :: GenericAlloc(e#39, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#39] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#39))]);
  ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (forall e#40: BoxType :: GenericAlloc(e#40, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#40] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#40))]);
  free ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) && (forall e#41: BoxType :: GenericAlloc(e#41, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#41] ==> _module.__default.DomC($Heap, this, _module.StateC.c($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#41))]);
  ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (_module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) ==> _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) || (forall e#43: BoxType :: GenericAlloc(e#43, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#43] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#43))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#43), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#43, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)))));
  ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (forall e#44: BoxType :: GenericAlloc(e#44, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#44] ==> _module.__default.DomC($Heap, this, _module.StateC.c($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#44))]);
  ensures (forall p#45: DatatypeType :: DtAlloc(p#45, $Heap) && DtType(p#45) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#45)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(p#45)] ==> _module.Path.OpaquePath_q(p#45));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.ExecCProperty(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && $IsA#_module.Expression(cmd#0), deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && $IsA#_module.Expression(deps#1), exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && $IsA#_module.Expression(exts#2), stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && $IsA#_module.StateC(stC#3)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 29 == $FunctionContextHeight;
  // user-defined preconditions
  requires _module.Expression.exprLiteral_q(cmd#0);
  requires _module.Literal.litString_q(_module.Expression.lit(cmd#0));
  requires _module.Expression.exprLiteral_q(deps#1);
  requires _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
  requires _module.Expression.exprLiteral_q(exts#2);
  requires _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
  requires Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)));
  free requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) && _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) && _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#46: BoxType :: GenericAlloc(e#46, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#46] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#46))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#46))]);
  requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) ==> _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (_module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> _module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) || (forall e#48: BoxType :: GenericAlloc(e#48, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#48] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#48))] ==> _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#48), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#48, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)))));
  requires _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) ==> _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (forall e#49: BoxType :: GenericAlloc(e#49, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#49] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#49))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#49))]);
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType);
  ensures _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  ensures Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)));
  ensures _module.StateC.st(stC#3) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType));
  free ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && (forall e#50: BoxType :: GenericAlloc(e#50, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#50] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#50))]);
  ensures _module.__default.OneToOne#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.OneToOne($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (forall e#51: BoxType :: GenericAlloc(e#51, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#51] ==> _module.Literal.paths(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#51))]);
  free ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) && _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) && (forall e#52: BoxType :: GenericAlloc(e#52, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#52] ==> _module.__default.DomC($Heap, this, _module.StateC.c($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#52))]);
  ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (_module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) ==> _module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) || (forall e#54: BoxType :: GenericAlloc(e#54, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#54] ==> _module.__default.DomSt($Heap, this, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#54))] && _module.__default.GetSt($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#54), _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))) == _module.__default.Res($Heap, this, cmd#0, deps#1, e#54, _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType)))));
  ensures _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) ==> _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, $Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType) || (forall e#55: BoxType :: GenericAlloc(e#55, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#55] ==> _module.__default.DomC($Heap, this, _module.StateC.c($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#55))]);
  ensures (forall p#56: DatatypeType :: DtAlloc(p#56, $Heap) && DtType(p#56) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3))[$Box(p#56)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3))): DatatypeType))[$Box(p#56)] ==> _module.Path.OpaquePath_q(p#56));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.ExecCProperty(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var result#57: DatatypeType where DtAlloc(result#57, $Heap) && DtType(result#57) == class._module.Tuple;
  var cmd#58: DatatypeType;
  var deps#59: DatatypeType;
  var exts#60: DatatypeType;
  var stC#61: DatatypeType;
  var expr'#62: DatatypeType where DtAlloc(expr'#62, $Heap) && DtType(expr'#62) == class._module.Expression;
  var stC'#63: DatatypeType where DtAlloc(stC'#63, $Heap) && DtType(stC'#63) == class._module.StateC;
  var $rhs#0: DatatypeType;
  var $rhs#1: DatatypeType;
  var e#64: BoxType;
  var cmd#65: DatatypeType;
  var deps#66: DatatypeType;
  var ext#67: BoxType;
  var p#68: DatatypeType;
  var c#69: BoxType;
  var st##71: BoxType;
  var st'##72: BoxType;
  var st#73: BoxType;
  var paths#74: Set BoxType;
  var st#75: BoxType;
  var cmd##76: DatatypeType;
  var deps##77: DatatypeType;
  var exts##78: DatatypeType;
  var st##79: BoxType;
  var execResult#80: DatatypeType where DtAlloc(execResult#80, $Heap) && DtType(execResult#80) == class._module.Tuple;
  var cmd#81: DatatypeType;
  var deps#82: DatatypeType;
  var exts#83: DatatypeType;
  var st#84: BoxType;
  var st'#85: BoxType where GenericAlloc(st'#85, $Heap);
  var st#86: BoxType;
  var st#87: BoxType;
  var st##88: BoxType;
  var st'##89: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(199,14): initial state"} true;
    $_reverifyPost := false;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(217,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(217,14)
    assume true;
    cmd#58 := cmd#0;
    deps#59 := deps#1;
    exts#60 := exts#2;
    stC#61 := stC#3;
    assert _module.Expression.exprLiteral_q(cmd#58) && _module.Literal.litString_q(_module.Expression.lit(cmd#58)) && _module.Expression.exprLiteral_q(deps#59) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#59)) && _module.Expression.exprLiteral_q(exts#60) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#60));
    assume _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    assume _module.__default.execC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    result#57 := _module.__default.execC($Heap, this, cmd#0, deps#1, exts#2, stC#3);
    assume {:captureState "CachedBuilds0.dfy(217,14)"} true;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(218,7)
    // ----- var-declaration statement ----- CachedBuilds0.dfy(218,14)
    // ----- update statement ----- CachedBuilds0.dfy(218,19)
    assume true;
    assume true;
    assume _module.Tuple.Pair_q(result#57);
    assume true;
    $rhs#0 := $Unbox(_module.Tuple.fst(result#57)): DatatypeType;
    assume _module.Tuple.Pair_q(result#57);
    assume true;
    $rhs#1 := $Unbox(_module.Tuple.snd(result#57)): DatatypeType;
    expr'#62 := $rhs#0;
    stC'#63 := $rhs#1;
    assume {:captureState "CachedBuilds0.dfy(218,19)"} true;
    // ----- if statement ----- CachedBuilds0.dfy(219,3)
    havoc e#64;
    assume GenericAlloc(e#64, $Heap);
    assert _module.Expression.exprLiteral_q(exts#2);
    assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
    if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#64])
    {
        cmd#65 := cmd#0;
        deps#66 := deps#1;
        ext#67 := e#64;
        assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#64);
        p#68 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#64);
        assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#64));
        assume _module.StateC.S_q(stC#3);
        c#69 := _module.StateC.c(stC#3);
        assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3));
    }

    assume (forall e#70: BoxType :: GenericAlloc(e#70, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#70] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#70) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#70)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3)));
    if ((forall e#70: BoxType :: GenericAlloc(e#70, $Heap) && _module.Literal.strs(_module.Expression.lit(exts#2))[e#70] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#70))]))
    {
        // ----- call statement ----- CachedBuilds0.dfy(220,5)
        assume _module.StateC.S_q(stC#3);
        assume true;
        st##71 := _module.StateC.st(stC#3);
        assume _module.StateC.S_q(stC#3);
        st#73 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
        assume _module.StateC.S_q(stC'#63);
        paths#74 := _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3));
        st#75 := _module.StateC.st(stC'#63);
        assert Set#Subset(paths#74, _module.__default.DomSt($Heap, this, st#75));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#63));
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3)) && _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#63));
        st'##72 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.StateC.st(stC'#63));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.StateEqualityProperty(this, st##71, st'##72);
        assume {:captureState "CachedBuilds0.dfy(220,5)"} true;
    }
    else
    {
        // ----- call statement ----- CachedBuilds0.dfy(222,5)
        assume true;
        cmd##76 := cmd#0;
        assume true;
        deps##77 := deps#1;
        assume true;
        exts##78 := exts#2;
        assume _module.StateC.S_q(stC#3);
        assume true;
        st##79 := _module.StateC.st(stC#3);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.ExecProperty(this, cmd##76, deps##77, exts##78, st##79);
        assume {:captureState "CachedBuilds0.dfy(222,5)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(223,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(223,20)
        assume true;
        assume _module.StateC.S_q(stC#3);
        cmd#81 := cmd#0;
        deps#82 := deps#1;
        exts#83 := exts#2;
        st#84 := _module.StateC.st(stC#3);
        assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
        assume _module.__default.exec#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
        execResult#80 := _module.__default.exec($Heap, this, cmd#0, deps#1, exts#2, _module.StateC.st(stC#3));
        assume {:captureState "CachedBuilds0.dfy(223,20)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(224,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(224,13)
        assume true;
        assume _module.Tuple.Pair_q(execResult#80);
        assume true;
        st'#85 := _module.Tuple.snd(execResult#80);
        assume {:captureState "CachedBuilds0.dfy(224,13)"} true;
        // ----- assert statement ----- CachedBuilds0.dfy(225,5)
        assume _module.StateC.S_q(stC#3);
        st#86 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
        st#87 := st'#85;
        assume _module.__default.DomSt#canCall($Heap, this, st'#85);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3)) && _module.__default.DomSt#canCall($Heap, this, st'#85);
        assert Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)), _module.__default.DomSt($Heap, this, st'#85));
        // ----- call statement ----- CachedBuilds0.dfy(226,5)
        assume _module.StateC.S_q(stC'#63);
        assume true;
        st##88 := _module.StateC.st(stC'#63);
        assume true;
        st'##89 := st'#85;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.StateEqualityProperty(this, st##88, st'##89);
        assume {:captureState "CachedBuilds0.dfy(226,5)"} true;
    }
}



// function declaration for _module._default.PreC
function _module.__default.PreC($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

function _module.__default.PreC#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

// frame axiom for _module.__default.PreC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.PreC($h1, this, cmd#0, deps#1, exts#2, stC#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.PreC#canCall($h0, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h0) && DtType(stC#3) == class._module.StateC)) && (_module.__default.PreC#canCall($h1, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h1) && DtType(stC#3) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.PreC($h0, this, cmd#0, deps#1, exts#2, stC#3) == _module.__default.PreC($h1, this, cmd#0, deps#1, exts#2, stC#3));

// consequence axiom for _module.__default.PreC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 27 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ((0 != $ModuleContextHeight || 27 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> true);

// definition axiom for _module.__default.PreC (intra-module)
axiom 0 == $ModuleContextHeight && 27 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (27 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)) && _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (_module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3)) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4)))) && _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == (_module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))])));

// definition axiom for _module.__default.PreC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 27 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.PreC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.PreC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || (27 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && Set#Subset(_module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#3))))) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3))) && _module.__default.Pre#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) && (_module.__default.Pre($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(Lit(stC#3))) && (_module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5)))) && _module.__default.PreC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) == (_module.__default.Pre($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) && (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))] ==> _module.Literal.paths(_module.Expression.lit(Lit(deps#1)))[$Box(_module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))])));

// definition axiom for _module.__default.PreC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PreC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> true);

// definition axiom for _module.__default.PreC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.PreC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.PreC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && Set#Subset(_module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#3))))) ==> true);

procedure CheckWellformed$$_module.__default.PreC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 27 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.PreC(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType)
{
  var st#6: BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var paths#7: Set BoxType;
  var st#8: BoxType;
  var cmd#9: DatatypeType;
  var deps#10: DatatypeType;
  var exts#11: DatatypeType;
  var st#12: BoxType;
  var e#13: BoxType;
  var cmd#14: DatatypeType;
  var deps#15: DatatypeType;
  var ext#16: BoxType;
  var p#17: DatatypeType;
  var c#18: BoxType;
  var cmd#19: DatatypeType;
  var deps#20: DatatypeType;
  var ext#21: BoxType;

    assume {:captureState "CachedBuilds0.dfy(230,11): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        assume _module.StateC.S_q(stC#3);
        st#6 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)));
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        assume _module.StateC.S_q(stC#3);
        paths#7 := _module.Literal.paths(_module.Expression.lit(deps#1));
        st#8 := _module.StateC.st(stC#3);
        assert Set#Subset(paths#7, _module.__default.DomSt($Heap, this, st#8));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3));
        cmd#9 := cmd#0;
        deps#10 := deps#1;
        exts#11 := exts#2;
        st#12 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3));
        assert _module.Expression.exprLiteral_q(cmd#9) && _module.Literal.litString_q(_module.Expression.lit(cmd#9)) && _module.Expression.exprLiteral_q(deps#10) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#10)) && _module.Expression.exprLiteral_q(exts#11) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#11));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)));
        if (_module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))))
        {
            havoc e#13;
            assume GenericAlloc(e#13, $Heap);
            assert _module.Expression.exprLiteral_q(exts#2);
            assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
            if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#13])
            {
                cmd#14 := cmd#0;
                deps#15 := deps#1;
                ext#16 := e#13;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#13);
                p#17 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#13);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#13));
                assume _module.StateC.S_q(stC#3);
                c#18 := _module.StateC.c(stC#3);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3));
                if (_module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#13))])
                {
                    cmd#19 := cmd#0;
                    deps#20 := deps#1;
                    ext#21 := e#13;
                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                    assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#13);
                    assert _module.Expression.exprLiteral_q(deps#1);
                    assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
                }
            }
        }

        assume _module.__default.PreC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == (_module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#22: BoxType :: GenericAlloc(e#22, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#22] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#22))] ==> _module.Literal.paths(_module.Expression.lit(deps#1))[$Box(_module.__default.Loc($Heap, this, cmd#0, deps#1, e#22))]));
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)) && _module.__default.Pre#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (_module.__default.Pre($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> (forall e#22: BoxType :: GenericAlloc(e#22, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#22] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#22) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#22)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3)) && (_module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#22))] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#22))));
    }
}



// function declaration for _module._default.PostC
function _module.__default.PostC($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

function _module.__default.PostC#canCall($heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType) : bool;

// frame axiom for _module.__default.PostC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.PostC($h1, this, cmd#0, deps#1, exts#2, stC#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.PostC#canCall($h0, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h0) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h0) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h0) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h0) && DtType(stC#3) == class._module.StateC)) && (_module.__default.PostC#canCall($h1, this, cmd#0, deps#1, exts#2, stC#3) || (DtAlloc(cmd#0, $h1) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $h1) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $h1) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $h1) && DtType(stC#3) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.PostC($h0, this, cmd#0, deps#1, exts#2, stC#3) == _module.__default.PostC($h1, this, cmd#0, deps#1, exts#2, stC#3));

// consequence axiom for _module.__default.PostC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 28 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ((0 != $ModuleContextHeight || 28 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> true);

// definition axiom for _module.__default.PostC (intra-module)
axiom 0 == $ModuleContextHeight && 28 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || (28 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)) && _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (_module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#4) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3)))) && _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == (_module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#4: BoxType :: GenericAlloc(e#4, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#4] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#4))])));

// definition axiom for _module.__default.PostC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 28 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.PostC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.PostC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || (28 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && Set#Subset(_module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#3))))) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3))) && _module.__default.Post#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) && (_module.__default.Post($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) ==> (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.Loc#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), e#5) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(Lit(stC#3))))) && _module.__default.PostC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) == (_module.__default.Post($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.StateC.st(Lit(stC#3)))) && (forall e#5: BoxType :: GenericAlloc(e#5, $Heap) ==> _module.Literal.strs(_module.Expression.lit(Lit(exts#2)))[e#5] ==> _module.__default.DomC($Heap, this, _module.StateC.c(Lit(stC#3)))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, Lit(cmd#0), Lit(deps#1), e#5))])));

// definition axiom for _module.__default.PostC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: { _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC#3) } _module.__default.PostC#canCall($Heap, this, cmd#0, deps#1, exts#2, stC#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression && DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression && DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression && DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC && _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)))) ==> true);

// definition axiom for _module.__default.PostC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType :: {:weight 10} { _module.__default.PostC($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) } _module.__default.PostC#canCall($Heap, this, Lit(cmd#0), Lit(deps#1), Lit(exts#2), Lit(stC#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.Expression.exprLiteral_q(Lit(cmd#0)) && _module.Literal.litString_q(_module.Expression.lit(Lit(cmd#0))) && _module.Expression.exprLiteral_q(Lit(deps#1)) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(Lit(deps#1))) && _module.Expression.exprLiteral_q(Lit(exts#2)) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(Lit(exts#2))) && Set#Subset(_module.Literal.paths(_module.Expression.lit(Lit(deps#1))), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#3))))) ==> true);

procedure CheckWellformed$$_module.__default.PostC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, cmd#0: DatatypeType where DtAlloc(cmd#0, $Heap) && DtType(cmd#0) == class._module.Expression, deps#1: DatatypeType where DtAlloc(deps#1, $Heap) && DtType(deps#1) == class._module.Expression, exts#2: DatatypeType where DtAlloc(exts#2, $Heap) && DtType(exts#2) == class._module.Expression, stC#3: DatatypeType where DtAlloc(stC#3, $Heap) && DtType(stC#3) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 28 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.PostC(this: ref, cmd#0: DatatypeType, deps#1: DatatypeType, exts#2: DatatypeType, stC#3: DatatypeType)
{
  var st#6: BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var paths#7: Set BoxType;
  var st#8: BoxType;
  var cmd#9: DatatypeType;
  var deps#10: DatatypeType;
  var exts#11: DatatypeType;
  var st#12: BoxType;
  var e#13: BoxType;
  var cmd#14: DatatypeType;
  var deps#15: DatatypeType;
  var ext#16: BoxType;
  var p#17: DatatypeType;
  var c#18: BoxType;

    assume {:captureState "CachedBuilds0.dfy(243,11): initial state"} true;
    if (_module.Expression.exprLiteral_q(cmd#0))
    {
        assert _module.Expression.exprLiteral_q(cmd#0);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)))
    {
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2))
    {
        assert _module.Expression.exprLiteral_q(exts#2);
    }

    if (_module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)))
    {
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        assume _module.StateC.S_q(stC#3);
        st#6 := _module.StateC.st(stC#3);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#3));
    }

    assume _module.Expression.exprLiteral_q(cmd#0) && _module.Literal.litString_q(_module.Expression.lit(cmd#0)) && _module.Expression.exprLiteral_q(deps#1) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1)) && _module.Expression.exprLiteral_q(exts#2) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#3)));
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assert _module.Expression.exprLiteral_q(deps#1);
        assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#1));
        assume _module.StateC.S_q(stC#3);
        paths#7 := _module.Literal.paths(_module.Expression.lit(deps#1));
        st#8 := _module.StateC.st(stC#3);
        assert Set#Subset(paths#7, _module.__default.DomSt($Heap, this, st#8));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3));
        cmd#9 := cmd#0;
        deps#10 := deps#1;
        exts#11 := exts#2;
        st#12 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3));
        assert _module.Expression.exprLiteral_q(cmd#9) && _module.Literal.litString_q(_module.Expression.lit(cmd#9)) && _module.Expression.exprLiteral_q(deps#10) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#10)) && _module.Expression.exprLiteral_q(exts#11) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#11));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)));
        if (_module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))))
        {
            havoc e#13;
            assume GenericAlloc(e#13, $Heap);
            assert _module.Expression.exprLiteral_q(exts#2);
            assert _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#2));
            if (_module.Literal.strs(_module.Expression.lit(exts#2))[e#13])
            {
                cmd#14 := cmd#0;
                deps#15 := deps#1;
                ext#16 := e#13;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#13);
                p#17 := _module.__default.Loc($Heap, this, cmd#0, deps#1, e#13);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#13));
                assume _module.StateC.S_q(stC#3);
                c#18 := _module.StateC.c(stC#3);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3));
            }
        }

        assume _module.__default.PostC($Heap, this, cmd#0, deps#1, exts#2, stC#3) == (_module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (forall e#19: BoxType :: GenericAlloc(e#19, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#19] ==> _module.__default.DomC($Heap, this, _module.StateC.c(stC#3))[_module.__default.Hash($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#19))]));
        assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3)) && _module.__default.Post#canCall($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) && (_module.__default.Post($Heap, this, cmd#0, deps#1, exts#2, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#1)), _module.StateC.st(stC#3))) ==> (forall e#19: BoxType :: GenericAlloc(e#19, $Heap) ==> _module.Literal.strs(_module.Expression.lit(exts#2))[e#19] ==> _module.__default.Loc#canCall($Heap, this, cmd#0, deps#1, e#19) && _module.__default.Hash#canCall($Heap, this, _module.__default.Loc($Heap, this, cmd#0, deps#1, e#19)) && _module.__default.DomC#canCall($Heap, this, _module.StateC.c(stC#3))));
    }
}



// function declaration for _module._default.Hash
function _module.__default.Hash($heap: HeapType, this: ref, p#0: DatatypeType) : BoxType;

function _module.__default.Hash#canCall($heap: HeapType, this: ref, p#0: DatatypeType) : bool;

// frame axiom for _module.__default.Hash
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, p#0: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.Hash($h1, this, p#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Hash#canCall($h0, this, p#0) || (DtAlloc(p#0, $h0) && DtType(p#0) == class._module.Path)) && (_module.__default.Hash#canCall($h1, this, p#0) || (DtAlloc(p#0, $h1) && DtType(p#0) == class._module.Path)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Hash($h0, this, p#0) == _module.__default.Hash($h1, this, p#0));

// consequence axiom for _module.__default.Hash
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 8 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, p#0: DatatypeType :: { _module.__default.Hash($Heap, this, p#0) } _module.__default.Hash#canCall($Heap, this, p#0) || ((0 != $ModuleContextHeight || 8 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path) ==> GenericAlloc(_module.__default.Hash($Heap, this, p#0), $Heap));

procedure CheckWellformed$$_module.__default.Hash(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, p#0: DatatypeType where DtAlloc(p#0, $Heap) && DtType(p#0) == class._module.Path);
  free requires 0 == $ModuleContextHeight && 8 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Hash(this: ref, p#0: DatatypeType)
{
    assume {:captureState "CachedBuilds0.dfy(255,10): initial state"} true;
    if (*)
    {
        assume GenericAlloc(_module.__default.Hash($Heap, this, p#0), $Heap);
        assume false;
    }
    else
    {
        assume false;
    }
}



// function declaration for _module._default.Value
function _module.__default.Value($heap: HeapType, this: ref, expr#0: DatatypeType) : bool;

function _module.__default.Value#canCall($heap: HeapType, this: ref, expr#0: DatatypeType) : bool;

// frame axiom for _module.__default.Value
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.Value($h1, this, expr#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Value#canCall($h0, this, expr#0) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression)) && (_module.__default.Value#canCall($h1, this, expr#0) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Value($h0, this, expr#0) == _module.__default.Value($h1, this, expr#0));

// consequence axiom for _module.__default.Value
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 16 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, expr#0: DatatypeType :: { _module.__default.Value($Heap, this, expr#0) } _module.__default.Value#canCall($Heap, this, expr#0) || ((0 != $ModuleContextHeight || 16 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression) ==> true);

// definition axiom for _module.__default.Value (intra-module)
axiom 0 == $ModuleContextHeight && 16 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, expr#0: DatatypeType :: { _module.__default.Value($Heap, this, expr#0) } _module.__default.Value#canCall($Heap, this, expr#0) || (16 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression) ==> _module.__default.Value($Heap, this, expr#0) == _module.Expression.exprLiteral_q(expr#0));

// definition axiom for _module.__default.Value for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 16 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, expr#0: DatatypeType :: {:weight 10} { _module.__default.Value($Heap, this, Lit(expr#0)) } _module.__default.Value#canCall($Heap, this, Lit(expr#0)) || (16 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Value($Heap, this, Lit(expr#0)) == _module.Expression.exprLiteral_q(Lit(expr#0)));

// definition axiom for _module.__default.Value (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, expr#0: DatatypeType :: { _module.__default.Value($Heap, this, expr#0) } _module.__default.Value#canCall($Heap, this, expr#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression) ==> true);

// definition axiom for _module.__default.Value for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, expr#0: DatatypeType :: {:weight 10} { _module.__default.Value($Heap, this, Lit(expr#0)) } _module.__default.Value#canCall($Heap, this, Lit(expr#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.Value(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression);
  free requires 0 == $ModuleContextHeight && 16 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Value(this: ref, expr#0: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;

    assume {:captureState "CachedBuilds0.dfy(293,11): initial state"} true;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assume _module.__default.Value($Heap, this, expr#0) == _module.Expression.exprLiteral_q(expr#0);
        assume true;
    }
}



// function declaration for _module._default.build
function _module.__default.build($heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType) : DatatypeType;

function _module.__default.build#canCall($heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType) : bool;

// frame axiom for _module.__default.build
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: { $HeapSucc($h0, $h1), _module.__default.build($h1, this, prog#0, st#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.build#canCall($h0, this, prog#0, st#1) || (DtAlloc(prog#0, $h0) && DtType(prog#0) == class._module.Program && GenericAlloc(st#1, $h0))) && (_module.__default.build#canCall($h1, this, prog#0, st#1) || (DtAlloc(prog#0, $h1) && DtType(prog#0) == class._module.Program && GenericAlloc(st#1, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.build($h0, this, prog#0, st#1) == _module.__default.build($h1, this, prog#0, st#1));

// consequence axiom for _module.__default.build
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 36 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: { _module.__default.build($Heap, this, prog#0, st#1) } _module.__default.build#canCall($Heap, this, prog#0, st#1) || ((0 != $ModuleContextHeight || 36 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && GenericAlloc(st#1, $Heap) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> DtAlloc(_module.__default.build($Heap, this, prog#0, st#1), $Heap) && DtType(_module.__default.build($Heap, this, prog#0, st#1)) == class._module.Tuple);

// definition axiom for _module.__default.build (intra-module)
axiom 0 == $ModuleContextHeight && 36 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: { _module.__default.build($Heap, this, prog#0, st#1) } _module.__default.build#canCall($Heap, this, prog#0, st#1) || (36 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && GenericAlloc(st#1, $Heap) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.do#canCall($Heap, this, _module.Program.stmts(prog#0), st#1, _module.__default.EmptyEnv($Heap, this)) && _module.__default.build($Heap, this, prog#0, st#1) == _module.__default.do($LS($LZ), $Heap, this, _module.Program.stmts(prog#0), st#1, _module.__default.EmptyEnv($Heap, this)));

// definition axiom for _module.__default.build for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 36 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: {:weight 10} { _module.__default.build($Heap, this, Lit(prog#0), Lit(st#1)) } _module.__default.build#canCall($Heap, this, Lit(prog#0), Lit(st#1)) || (36 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, _module.Program.stmts(Lit(prog#0)))) ==> _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.do#canCall($Heap, this, _module.Program.stmts(Lit(prog#0)), Lit(st#1), _module.__default.EmptyEnv($Heap, this)) && _module.__default.build($Heap, this, Lit(prog#0), Lit(st#1)) == _module.__default.do($LS($LZ), $Heap, this, _module.Program.stmts(Lit(prog#0)), Lit(st#1), _module.__default.EmptyEnv($Heap, this)));

// definition axiom for _module.__default.build (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: { _module.__default.build($Heap, this, prog#0, st#1) } _module.__default.build#canCall($Heap, this, prog#0, st#1) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && GenericAlloc(st#1, $Heap) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> true);

// definition axiom for _module.__default.build for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, st#1: BoxType :: {:weight 10} { _module.__default.build($Heap, this, Lit(prog#0), Lit(st#1)) } _module.__default.build#canCall($Heap, this, Lit(prog#0), Lit(st#1)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, _module.Program.stmts(Lit(prog#0)))) ==> true);

procedure CheckWellformed$$_module.__default.build(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program, st#1: BoxType where GenericAlloc(st#1, $Heap));
  free requires 0 == $ModuleContextHeight && 36 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.build(this: ref, prog#0: DatatypeType, st#1: BoxType)
{
  var stmts#2: Seq BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#3: Seq BoxType;
  var st#4: BoxType;
  var env#5: BoxType;

    assume {:captureState "CachedBuilds0.dfy(301,10): initial state"} true;
    assume _module.Program.Program_q(prog#0);
    stmts#2 := _module.Program.stmts(prog#0);
    assume _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0));
    assume _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
    if (*)
    {
        assume DtAlloc(_module.__default.build($Heap, this, prog#0, st#1), $Heap) && DtType(_module.__default.build($Heap, this, prog#0, st#1)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assume _module.Program.Program_q(prog#0);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.EmptyEnv#canCall($Heap, this);
        stmts#3 := _module.Program.stmts(prog#0);
        st#4 := st#1;
        env#5 := _module.__default.EmptyEnv($Heap, this);
        assert _module.__default.Legal($Heap, this, stmts#3);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.do#canCall($Heap, this, _module.Program.stmts(prog#0), st#1, _module.__default.EmptyEnv($Heap, this));
        assume _module.__default.build($Heap, this, prog#0, st#1) == _module.__default.do($LS($LZ), $Heap, this, _module.Program.stmts(prog#0), st#1, _module.__default.EmptyEnv($Heap, this));
        assume _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.do#canCall($Heap, this, _module.Program.stmts(prog#0), st#1, _module.__default.EmptyEnv($Heap, this));
    }
}



// function declaration for _module._default.do
function _module.__default.do($ly: LayerType, $heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType) : DatatypeType;

function _module.__default.do#canCall($heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: { _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) } _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) == _module.__default.do($ly, $Heap, this, stmts#0, st#1, env#2));

// frame axiom for _module.__default.do
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.do($ly, $h1, this, stmts#0, st#1, env#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.do#canCall($h0, this, stmts#0, st#1, env#2) || ((forall $i#0: int :: { Seq#Index(stmts#0, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType) == class._module.Statement) && GenericAlloc(st#1, $h0) && GenericAlloc(env#2, $h0))) && (_module.__default.do#canCall($h1, this, stmts#0, st#1, env#2) || ((forall $i#1: int :: { Seq#Index(stmts#0, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#1)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(stmts#0, $i#1)): DatatypeType) == class._module.Statement) && GenericAlloc(st#1, $h1) && GenericAlloc(env#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.do($ly, $h0, this, stmts#0, st#1, env#2) == _module.__default.do($ly, $h1, this, stmts#0, st#1, env#2));

// consequence axiom for _module.__default.do
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 35 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: { _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) } _module.__default.do#canCall($Heap, this, stmts#0, st#1, env#2) || ((0 != $ModuleContextHeight || 35 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#2: int :: { Seq#Index(stmts#0, $i#2) } 0 <= $i#2 && $i#2 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#2)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#2)): DatatypeType) == class._module.Statement) && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> DtAlloc(_module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2), $Heap) && DtType(_module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2)) == class._module.Tuple);

// definition axiom for _module.__default.do (intra-module)
axiom 0 == $ModuleContextHeight && 35 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: { _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) } _module.__default.do#canCall($Heap, this, stmts#0, st#1, env#2) || (35 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#3: int :: { Seq#Index(stmts#0, $i#3) } 0 <= $i#3 && $i#3 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#3)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#3)): DatatypeType) == class._module.Statement) && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> (_module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) ==> _module.__default.eval#canCall($Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2) && _module.__default.Value#canCall($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType) && (_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType) ==> _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType, env#2) && _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1))) && (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) ==> _module.__default.do#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2)), _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType, env#2))) && (!_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) ==> true)) && (!_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType) ==> true)) && (!_module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) ==> _module.__default.eval#canCall($Heap, this, _module.Statement.ret($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2)) && _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) == (if _module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) then (if _module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType) then (if _module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) then _module.__default.do($ly, $Heap, this, Seq#Drop(stmts#0, Lit(1)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2)), _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType, env#2)) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2))): DatatypeType), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else _module.__default.eval($LS($LZ), $Heap, this, _module.Statement.ret($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), st#1, env#2)));

// definition axiom for _module.__default.do for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 35 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.do($ly, $Heap, this, Lit(stmts#0), Lit(st#1), Lit(env#2)) } _module.__default.do#canCall($Heap, this, Lit(stmts#0), Lit(st#1), Lit(env#2)) || (35 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, Lit(stmts#0))) ==> (_module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) ==> _module.__default.eval#canCall($Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)) && _module.__default.Value#canCall($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType) && (_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType) ==> _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType, Lit(env#2)) && _module.__default.Legal#canCall($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) && (_module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) ==> _module.__default.do#canCall($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2))), _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType, Lit(env#2)))) && (!_module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) ==> true)) && (!_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true)) && (!_module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) ==> _module.__default.eval#canCall($Heap, this, _module.Statement.ret($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2))) && _module.__default.do($ly, $Heap, this, Lit(stmts#0), Lit(st#1), Lit(env#2)) == (if _module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) then (if _module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType) then (if _module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) then _module.__default.do($ly, $Heap, this, Seq#Drop(Lit(stmts#0), Lit(1)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2))), _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType, Lit(env#2))) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2)))): DatatypeType), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2))))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1))) else _module.__default.eval($LS($LZ), $Heap, this, _module.Statement.ret($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(st#1), Lit(env#2))));

// definition axiom for _module.__default.do (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: { _module.__default.do($LS($ly), $Heap, this, stmts#0, st#1, env#2) } _module.__default.do#canCall($Heap, this, stmts#0, st#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#4: int :: { Seq#Index(stmts#0, $i#4) } 0 <= $i#4 && $i#4 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#4)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#4)): DatatypeType) == class._module.Statement) && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> true);

// definition axiom for _module.__default.do for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.do($ly, $Heap, this, Lit(stmts#0), Lit(st#1), Lit(env#2)) } _module.__default.do#canCall($Heap, this, Lit(stmts#0), Lit(st#1), Lit(env#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, Lit(stmts#0))) ==> true);

procedure CheckWellformed$$_module.__default.do(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#5: int :: { Seq#Index(stmts#0, $i#5) } 0 <= $i#5 && $i#5 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#5)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#5)): DatatypeType) == class._module.Statement), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 35 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.do(this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType)
{
  var stmts#3: Seq BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmt#4: DatatypeType;
  var result#5: DatatypeType;
  var expr#6: DatatypeType;
  var st#7: BoxType;
  var env#8: BoxType;
  var expr'#9: DatatypeType;
  var st'#10: BoxType;
  var expr#11: DatatypeType;
  var env'#12: BoxType;
  var id#13: BoxType;
  var expr#14: DatatypeType;
  var env#15: BoxType;
  var stmts#16: Seq BoxType;
  var stmts#17: Seq BoxType;
  var st#18: BoxType;
  var env#19: BoxType;
  var expr#20: DatatypeType;
  var st#21: BoxType;
  var env#22: BoxType;

    assume {:captureState "CachedBuilds0.dfy(308,10): initial state"} true;
    stmts#3 := stmts#0;
    assume _module.__default.Legal#canCall($Heap, this, stmts#0);
    assume _module.__default.Legal($Heap, this, stmts#0);
    if (*)
    {
        assume DtAlloc(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2), $Heap) && DtType(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assert 0 <= Lit(0) && Lit(0) < Seq#Length(stmts#0);
        assume stmt#4 == $Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType;
        assume true;
        if (_module.Statement.stmtVariable_q(stmt#4))
        {
            assert _module.Statement.stmtVariable_q(stmt#4);
            expr#6 := _module.Statement.expr(stmt#4);
            st#7 := st#1;
            env#8 := env#2;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.eval#canCall($Heap, this, _module.Statement.expr(stmt#4), st#1, env#2);
            assume result#5 == _module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr(stmt#4), st#1, env#2);
            assume _module.__default.eval#canCall($Heap, this, _module.Statement.expr(stmt#4), st#1, env#2);
            assume _module.Tuple.Pair_q(result#5);
            assume expr'#9 == $Unbox(_module.Tuple.fst(result#5)): DatatypeType;
            assume true;
            assume _module.Tuple.Pair_q(result#5);
            assume st'#10 == _module.Tuple.snd(result#5);
            assume true;
            expr#11 := expr'#9;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Value#canCall($Heap, this, expr'#9);
            if (_module.__default.Value($Heap, this, expr'#9))
            {
                assert _module.Statement.stmtVariable_q(stmt#4);
                id#13 := _module.Statement.id(stmt#4);
                expr#14 := expr'#9;
                env#15 := env#2;
                assert _module.__default.Value($Heap, this, expr#14);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assume env'#12 == _module.__default.SetEnv($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                stmts#16 := Seq#Drop(stmts#0, Lit(1));
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
                if (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))))
                {
                    assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                    stmts#17 := Seq#Drop(stmts#0, Lit(1));
                    st#18 := st'#10;
                    env#19 := env'#12;
                    assert _module.__default.Legal($Heap, this, stmts#17);
                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                    assert Seq#Rank(stmts#17) < Seq#Rank(stmts#0);
                    assume _module.__default.do#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), st'#10, env'#12);
                    assume _module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2) == _module.__default.do($LS($LZ), $Heap, this, Seq#Drop(stmts#0, Lit(1)), st'#10, env'#12);
                    assume _module.__default.do#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), st'#10, env'#12);
                }
                else
                {
                    assume _module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2) == #_module.Tuple.Pair($Box(expr'#9), st'#10);
                    assume true;
                }
            }
            else
            {
                assume _module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                assume true;
            }
        }
        else
        {
            // ----- assert statement ----- CachedBuilds0.dfy(325,5)
            if (!_module.Statement.stmtVariable_q(stmt#4))
            {
            }

            assume !_module.Statement.stmtVariable_q(stmt#4) ==> true;
            assert _module.Statement.stmtVariable_q(stmt#4) || _module.Statement.stmtReturn_q(stmt#4);
            assert _module.Statement.stmtReturn_q(stmt#4);
            expr#20 := _module.Statement.ret(stmt#4);
            st#21 := st#1;
            env#22 := env#2;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.eval#canCall($Heap, this, _module.Statement.ret(stmt#4), st#1, env#2);
            assume _module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Statement.ret(stmt#4), st#1, env#2);
            assume _module.__default.eval#canCall($Heap, this, _module.Statement.ret(stmt#4), st#1, env#2);
        }
    }
}



// function declaration for _module._default.Legal
function _module.__default.Legal($heap: HeapType, this: ref, stmts#0: Seq BoxType) : bool;

function _module.__default.Legal#canCall($heap: HeapType, this: ref, stmts#0: Seq BoxType) : bool;

// frame axiom for _module.__default.Legal
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, stmts#0: Seq BoxType :: { $HeapSucc($h0, $h1), _module.__default.Legal($h1, this, stmts#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Legal#canCall($h0, this, stmts#0) || (forall $i#6: int :: { Seq#Index(stmts#0, $i#6) } 0 <= $i#6 && $i#6 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#6)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(stmts#0, $i#6)): DatatypeType) == class._module.Statement)) && (_module.__default.Legal#canCall($h1, this, stmts#0) || (forall $i#7: int :: { Seq#Index(stmts#0, $i#7) } 0 <= $i#7 && $i#7 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#7)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(stmts#0, $i#7)): DatatypeType) == class._module.Statement)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Legal($h0, this, stmts#0) == _module.__default.Legal($h1, this, stmts#0));

// consequence axiom for _module.__default.Legal
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 30 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, stmts#0: Seq BoxType :: { _module.__default.Legal($Heap, this, stmts#0) } _module.__default.Legal#canCall($Heap, this, stmts#0) || ((0 != $ModuleContextHeight || 30 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#8: int :: { Seq#Index(stmts#0, $i#8) } 0 <= $i#8 && $i#8 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#8)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#8)): DatatypeType) == class._module.Statement)) ==> true);

// definition axiom for _module.__default.Legal (intra-module)
axiom 0 == $ModuleContextHeight && 30 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stmts#0: Seq BoxType :: { _module.__default.Legal($Heap, this, stmts#0) } _module.__default.Legal#canCall($Heap, this, stmts#0) || (30 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#9: int :: { Seq#Index(stmts#0, $i#9) } 0 <= $i#9 && $i#9 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#9)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#9)): DatatypeType) == class._module.Statement)) ==> _module.__default.Legal($Heap, this, stmts#0) == (Seq#Length(stmts#0) != 0));

// definition axiom for _module.__default.Legal for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 30 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, stmts#0: Seq BoxType :: {:weight 10} { _module.__default.Legal($Heap, this, Lit(stmts#0)) } _module.__default.Legal#canCall($Heap, this, Lit(stmts#0)) || (30 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Legal($Heap, this, Lit(stmts#0)) == (Seq#Length(Lit(stmts#0)) != 0));

// definition axiom for _module.__default.Legal (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stmts#0: Seq BoxType :: { _module.__default.Legal($Heap, this, stmts#0) } _module.__default.Legal#canCall($Heap, this, stmts#0) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#10: int :: { Seq#Index(stmts#0, $i#10) } 0 <= $i#10 && $i#10 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#10)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#10)): DatatypeType) == class._module.Statement)) ==> true);

// definition axiom for _module.__default.Legal for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, stmts#0: Seq BoxType :: {:weight 10} { _module.__default.Legal($Heap, this, Lit(stmts#0)) } _module.__default.Legal#canCall($Heap, this, Lit(stmts#0)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.Legal(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#11: int :: { Seq#Index(stmts#0, $i#11) } 0 <= $i#11 && $i#11 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#11)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#11)): DatatypeType) == class._module.Statement));
  free requires 0 == $ModuleContextHeight && 30 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Legal(this: ref, stmts#0: Seq BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;

    assume {:captureState "CachedBuilds0.dfy(329,11): initial state"} true;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assume _module.__default.Legal($Heap, this, stmts#0) == (Seq#Length(stmts#0) != 0);
        assume true;
    }
}



// function declaration for _module._default.eval
function _module.__default.eval($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType) : DatatypeType;

function _module.__default.eval#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: { _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) } _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($ly, $Heap, this, expr#0, st#1, env#2));

// frame axiom for _module.__default.eval
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.eval($ly, $h1, this, expr#0, st#1, env#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.eval#canCall($h0, this, expr#0, st#1, env#2) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && GenericAlloc(st#1, $h0) && GenericAlloc(env#2, $h0))) && (_module.__default.eval#canCall($h1, this, expr#0, st#1, env#2) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && GenericAlloc(st#1, $h1) && GenericAlloc(env#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.eval($ly, $h0, this, expr#0, st#1, env#2) == _module.__default.eval($ly, $h1, this, expr#0, st#1, env#2));

// consequence axiom for _module.__default.eval
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 34 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: { _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) } _module.__default.eval#canCall($Heap, this, expr#0, st#1, env#2) || ((0 != $ModuleContextHeight || 34 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap)) ==> DtAlloc(_module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2), $Heap) && DtType(_module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2)) == class._module.Tuple);

// definition axiom for _module.__default.eval (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: { _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) } _module.__default.eval#canCall($Heap, this, expr#0, st#1, env#2) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap)) ==> _module.__default.Value#canCall($Heap, this, expr#0) && (_module.__default.Value($Heap, this, expr#0) ==> true) && (!_module.__default.Value($Heap, this, expr#0) ==> (_module.Expression.exprIdentifier_q(expr#0) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2)) && (!_module.Expression.exprIdentifier_q(expr#0) ==> (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), st#1, env#2)) && (!(_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), st#1, env#2)) && (!(_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(expr#0) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.cond(expr#0), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(expr#0) ==> (_module.Expression.exprAnd_q(expr#0) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(expr#0), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj1(expr#0), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(expr#0) ==> (_module.Expression.exprOr_q(expr#0) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(expr#0), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj1(expr#0), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(expr#0) ==> (_module.Expression.exprInvocation_q(expr#0) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.fun(expr#0), st#1, env#2) && _module.__default.evalArgs#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2) && _module.__default.Compatible#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)) && (_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)) ==> _module.__default.Combine#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType))) ==> _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)))) ==> true)) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType))) ==> true)) && (!_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(expr#0) ==> true)))))))) && _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) == (if _module.__default.Value($Heap, this, expr#0) then #_module.Tuple.Pair($Box(expr#0), st#1) else (if _module.Expression.exprIdentifier_q(expr#0) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(expr#0), env#2)), st#1) else (if _module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(expr#0), st#1, env#2) else (if _module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(expr#0), st#1, env#2) else (if _module.Expression.exprIf_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(expr#0), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2)), env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(expr#0), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(expr#0), st#1, env#2)), env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprAnd_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.conj1(expr#0), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2)), env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprOr_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.disj1(expr#0), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2)), env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprInvocation_q(expr#0) then (if _module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType))) then _module.__default.exec($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(expr#0), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2))): Set BoxType))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))))))))));

// definition axiom for _module.__default.eval for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.eval($ly, $Heap, this, Lit(expr#0), st#1, env#2) } _module.__default.eval#canCall($Heap, this, Lit(expr#0), st#1, env#2) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Value#canCall($Heap, this, Lit(expr#0)) && (_module.__default.Value($Heap, this, Lit(expr#0)) ==> true) && (!_module.__default.Value($Heap, this, Lit(expr#0)) ==> (_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(Lit(expr#0)), env#2)) && (!_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), st#1, env#2)) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), st#1, env#2)) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(Lit(expr#0)) ==> (_module.Expression.exprAnd_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(Lit(expr#0)) ==> (_module.Expression.exprOr_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2)), env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(Lit(expr#0)) ==> (_module.Expression.exprInvocation_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2) && _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2) && _module.__default.Compatible#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)) && (_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)) ==> _module.__default.Combine#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType))) ==> _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)))) ==> true)) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType))) ==> true)) && (!_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(Lit(expr#0)) ==> true)))))))) && _module.__default.eval($ly, $Heap, this, Lit(expr#0), st#1, env#2) == (if _module.__default.Value($Heap, this, Lit(expr#0)) then #_module.Tuple.Pair($Box(Lit(expr#0)), st#1) else (if _module.Expression.exprIdentifier_q(Lit(expr#0)) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(Lit(expr#0)), env#2)), st#1) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), st#1, env#2) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), st#1, env#2) else (if _module.Expression.exprIf_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2)), env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), st#1, env#2)), env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprAnd_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.conj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2)), env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), st#1, env#2))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprOr_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.disj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), st#1, env#2)), env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))) else (if _module.Expression.exprInvocation_q(Lit(expr#0)) then (if _module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType))) then _module.__default.exec($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), st#1, env#2))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), st#1, env#2))): Set BoxType))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), st#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1))))))))));

// definition axiom for _module.__default.eval for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.eval($ly, $Heap, this, Lit(expr#0), Lit(st#1), Lit(env#2)) } _module.__default.eval#canCall($Heap, this, Lit(expr#0), Lit(st#1), Lit(env#2)) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Value#canCall($Heap, this, Lit(expr#0)) && (_module.__default.Value($Heap, this, Lit(expr#0)) ==> true) && (!_module.__default.Value($Heap, this, Lit(expr#0)) ==> (_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(Lit(expr#0)), Lit(env#2))) && (!_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), Lit(st#1), Lit(env#2))) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), Lit(st#1), Lit(env#2))) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(Lit(expr#0)) ==> (_module.Expression.exprAnd_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.conj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(Lit(expr#0)) ==> (_module.Expression.exprOr_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.eval#canCall($Heap, this, _module.Expression.disj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(Lit(expr#0)) ==> (_module.Expression.exprInvocation_q(Lit(expr#0)) ==> _module.__default.eval#canCall($Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)) && _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)) && _module.__default.Compatible#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)) && (_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)) ==> _module.__default.Combine#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType))) ==> _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)))) ==> true)) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType))) ==> true)) && (!_module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(Lit(expr#0)) ==> true)))))))) && _module.__default.eval($ly, $Heap, this, Lit(expr#0), Lit(st#1), Lit(env#2)) == (if _module.__default.Value($Heap, this, Lit(expr#0)) then #_module.Tuple.Pair($Box(Lit(expr#0)), Lit(st#1)) else (if _module.Expression.exprIdentifier_q(Lit(expr#0)) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(Lit(expr#0)), Lit(env#2))), Lit(st#1)) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), Lit(st#1), Lit(env#2)) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), Lit(st#1), Lit(env#2)) else (if _module.Expression.exprIf_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1)))) else (if _module.Expression.exprAnd_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.eval($ly, $Heap, this, _module.Expression.conj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1)))) else (if _module.Expression.exprOr_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.eval($ly, $Heap, this, _module.Expression.disj1(Lit(expr#0)), _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(st#1), Lit(env#2))), Lit(env#2)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1)))) else (if _module.Expression.exprInvocation_q(Lit(expr#0)) then (if _module.__default.Compatible($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType))) then _module.__default.exec($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.Combine($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(st#1), Lit(env#2)))), $Unbox(_module.Tuple.snd(_module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(st#1), Lit(env#2)))): Set BoxType))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), Lit(st#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), Lit(st#1)))))))))));

// definition axiom for _module.__default.eval (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: { _module.__default.eval($LS($ly), $Heap, this, expr#0, st#1, env#2) } _module.__default.eval#canCall($Heap, this, expr#0, st#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && GenericAlloc(st#1, $Heap) && GenericAlloc(env#2, $Heap)) ==> true);

// definition axiom for _module.__default.eval for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.eval($ly, $Heap, this, Lit(expr#0), st#1, env#2) } _module.__default.eval#canCall($Heap, this, Lit(expr#0), st#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

// definition axiom for _module.__default.eval for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType :: {:weight 10} { _module.__default.eval($ly, $Heap, this, Lit(expr#0), Lit(st#1), Lit(env#2)) } _module.__default.eval#canCall($Heap, this, Lit(expr#0), Lit(st#1), Lit(env#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.eval(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 34 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.eval(this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var expr#3: DatatypeType;
  var id#4: BoxType;
  var env#5: BoxType;
  var expr#6: DatatypeType;
  var st#7: BoxType;
  var env#8: BoxType;
  var expr#9: DatatypeType;
  var st#10: BoxType;
  var env#11: BoxType;
  var result#12: DatatypeType;
  var expr#13: DatatypeType;
  var st#14: BoxType;
  var env#15: BoxType;
  var cond'#16: DatatypeType;
  var st'#17: BoxType;
  var expr#18: DatatypeType;
  var st#19: BoxType;
  var env#20: BoxType;
  var expr#21: DatatypeType;
  var st#22: BoxType;
  var env#23: BoxType;
  var result#24: DatatypeType;
  var expr#25: DatatypeType;
  var st#26: BoxType;
  var env#27: BoxType;
  var conj0'#28: DatatypeType;
  var st'#29: BoxType;
  var expr#30: DatatypeType;
  var st#31: BoxType;
  var env#32: BoxType;
  var result#33: DatatypeType;
  var expr#34: DatatypeType;
  var st#35: BoxType;
  var env#36: BoxType;
  var disj0'#37: DatatypeType;
  var st'#38: BoxType;
  var expr#39: DatatypeType;
  var st#40: BoxType;
  var env#41: BoxType;
  var resultFun#42: DatatypeType;
  var expr#43: DatatypeType;
  var st#44: BoxType;
  var env#45: BoxType;
  var fun'#46: DatatypeType;
  var st'#47: BoxType;
  var resultArgs#48: DatatypeType;
  var expr#49: DatatypeType;
  var args#50: Seq BoxType;
  var st#51: BoxType;
  var env#52: BoxType;
  var args'#54: Seq BoxType;
  var sts'#55: Set BoxType;
  var sts''#56: Set BoxType;
  var sts#57: Set BoxType;
  var stCombined#58: BoxType;
  var sts#59: Set BoxType;
  var prim#60: DatatypeType;
  var prim#61: DatatypeType;
  var args#62: Seq BoxType;
  var st#63: BoxType;
  var cmd#64: DatatypeType;
  var deps#65: DatatypeType;
  var exts#66: DatatypeType;
  var st#67: BoxType;

    assume {:captureState "CachedBuilds0.dfy(335,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2), $Heap) && DtType(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        expr#3 := expr#0;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Value#canCall($Heap, this, expr#0);
        if (_module.__default.Value($Heap, this, expr#0))
        {
            assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(expr#0), st#1);
            assume true;
        }
        else
        {
            if (_module.Expression.exprIdentifier_q(expr#0))
            {
                assert _module.Expression.exprIdentifier_q(expr#0);
                id#4 := _module.Expression.id(expr#0);
                env#5 := env#2;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2);
                assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(expr#0), env#2)), st#1);
                assume _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2);
            }
            else
            {
                if (_module.Expression.exprIf_q(expr#0))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue())
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    expr#6 := _module.Expression.ifTrue(expr#0);
                    st#7 := st#1;
                    env#8 := env#2;
                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                    assert DtRank(expr#6) < DtRank(expr#0);
                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), st#1, env#2);
                    assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.ifTrue(expr#0), st#1, env#2);
                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), st#1, env#2);
                }
                else
                {
                    if (_module.Expression.exprIf_q(expr#0))
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                    }

                    if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                        assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                    }

                    if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse())
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                        expr#9 := _module.Expression.ifFalse(expr#0);
                        st#10 := st#1;
                        env#11 := env#2;
                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                        assert DtRank(expr#9) < DtRank(expr#0);
                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), st#1, env#2);
                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.ifFalse(expr#0), st#1, env#2);
                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), st#1, env#2);
                    }
                    else
                    {
                        if (_module.Expression.exprIf_q(expr#0))
                        {
                            assert _module.Expression.exprIf_q(expr#0);
                            expr#13 := _module.Expression.cond(expr#0);
                            st#14 := st#1;
                            env#15 := env#2;
                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                            assert DtRank(expr#13) < DtRank(expr#0);
                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                            assume result#12 == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                            assume _module.Tuple.Pair_q(result#12);
                            assume cond'#16 == $Unbox(_module.Tuple.fst(result#12)): DatatypeType;
                            assume true;
                            assume _module.Tuple.Pair_q(result#12);
                            assume st'#17 == _module.Tuple.snd(result#12);
                            assume true;
                            if (_module.Expression.exprLiteral_q(cond'#16))
                            {
                                assert _module.Expression.exprLiteral_q(cond'#16);
                            }

                            if (_module.Expression.exprLiteral_q(cond'#16) && _module.Expression.lit(cond'#16) == #_module.Literal.litTrue())
                            {
                                assert _module.Expression.exprIf_q(expr#0);
                                expr#18 := _module.Expression.ifTrue(expr#0);
                                st#19 := st'#17;
                                env#20 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr#18) < DtRank(expr#0);
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), st'#17, env#2);
                                assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.ifTrue(expr#0), st'#17, env#2);
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifTrue(expr#0), st'#17, env#2);
                            }
                            else
                            {
                                if (_module.Expression.exprLiteral_q(cond'#16))
                                {
                                    assert _module.Expression.exprLiteral_q(cond'#16);
                                }

                                if (_module.Expression.exprLiteral_q(cond'#16) && _module.Expression.lit(cond'#16) == #_module.Literal.litFalse())
                                {
                                    assert _module.Expression.exprIf_q(expr#0);
                                    expr#21 := _module.Expression.ifFalse(expr#0);
                                    st#22 := st'#17;
                                    env#23 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#21) < DtRank(expr#0);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), st'#17, env#2);
                                    assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.ifFalse(expr#0), st'#17, env#2);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.ifFalse(expr#0), st'#17, env#2);
                                }
                                else
                                {
                                    assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                    assume true;
                                }
                            }
                        }
                        else
                        {
                            if (_module.Expression.exprAnd_q(expr#0))
                            {
                                assert _module.Expression.exprAnd_q(expr#0);
                                expr#25 := _module.Expression.conj0(expr#0);
                                st#26 := st#1;
                                env#27 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr#25) < DtRank(expr#0);
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                                assume result#24 == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                                assume _module.Tuple.Pair_q(result#24);
                                assume conj0'#28 == $Unbox(_module.Tuple.fst(result#24)): DatatypeType;
                                assume true;
                                assume _module.Tuple.Pair_q(result#24);
                                assume st'#29 == _module.Tuple.snd(result#24);
                                assume true;
                                if (_module.Expression.exprLiteral_q(conj0'#28))
                                {
                                    assert _module.Expression.exprLiteral_q(conj0'#28);
                                }

                                if (_module.Expression.exprLiteral_q(conj0'#28) && _module.Expression.lit(conj0'#28) == #_module.Literal.litTrue())
                                {
                                    assert _module.Expression.exprAnd_q(expr#0);
                                    expr#30 := _module.Expression.conj1(expr#0);
                                    st#31 := st'#29;
                                    env#32 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#30) < DtRank(expr#0);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj1(expr#0), st'#29, env#2);
                                    assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj1(expr#0), st'#29, env#2);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj1(expr#0), st'#29, env#2);
                                }
                                else
                                {
                                    if (_module.Expression.exprLiteral_q(conj0'#28))
                                    {
                                        assert _module.Expression.exprLiteral_q(conj0'#28);
                                    }

                                    if (_module.Expression.exprLiteral_q(conj0'#28) && _module.Expression.lit(conj0'#28) == #_module.Literal.litFalse())
                                    {
                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), st'#29);
                                        assume true;
                                    }
                                    else
                                    {
                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                        assume true;
                                    }
                                }
                            }
                            else
                            {
                                if (_module.Expression.exprOr_q(expr#0))
                                {
                                    assert _module.Expression.exprOr_q(expr#0);
                                    expr#34 := _module.Expression.disj0(expr#0);
                                    st#35 := st#1;
                                    env#36 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#34) < DtRank(expr#0);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                    assume result#33 == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                    assume _module.Tuple.Pair_q(result#33);
                                    assume disj0'#37 == $Unbox(_module.Tuple.fst(result#33)): DatatypeType;
                                    assume true;
                                    assume _module.Tuple.Pair_q(result#33);
                                    assume st'#38 == _module.Tuple.snd(result#33);
                                    assume true;
                                    if (_module.Expression.exprLiteral_q(disj0'#37))
                                    {
                                        assert _module.Expression.exprLiteral_q(disj0'#37);
                                    }

                                    if (_module.Expression.exprLiteral_q(disj0'#37) && _module.Expression.lit(disj0'#37) == #_module.Literal.litTrue())
                                    {
                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), st'#38);
                                        assume true;
                                    }
                                    else
                                    {
                                        if (_module.Expression.exprLiteral_q(disj0'#37))
                                        {
                                            assert _module.Expression.exprLiteral_q(disj0'#37);
                                        }

                                        if (_module.Expression.exprLiteral_q(disj0'#37) && _module.Expression.lit(disj0'#37) == #_module.Literal.litFalse())
                                        {
                                            assert _module.Expression.exprOr_q(expr#0);
                                            expr#39 := _module.Expression.disj1(expr#0);
                                            st#40 := st'#38;
                                            env#41 := env#2;
                                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                            assert DtRank(expr#39) < DtRank(expr#0);
                                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj1(expr#0), st'#38, env#2);
                                            assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj1(expr#0), st'#38, env#2);
                                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj1(expr#0), st'#38, env#2);
                                        }
                                        else
                                        {
                                            assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                            assume true;
                                        }
                                    }
                                }
                                else
                                {
                                    if (_module.Expression.exprInvocation_q(expr#0))
                                    {
                                        assert _module.Expression.exprInvocation_q(expr#0);
                                        expr#43 := _module.Expression.fun(expr#0);
                                        st#44 := st#1;
                                        env#45 := env#2;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr#43) < DtRank(expr#0);
                                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                        assume resultFun#42 == _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                        assume _module.Tuple.Pair_q(resultFun#42);
                                        assume fun'#46 == $Unbox(_module.Tuple.fst(resultFun#42)): DatatypeType;
                                        assume true;
                                        assume _module.Tuple.Pair_q(resultFun#42);
                                        assume st'#47 == _module.Tuple.snd(resultFun#42);
                                        assume true;
                                        assert _module.Expression.exprInvocation_q(expr#0);
                                        expr#49 := expr#0;
                                        args#50 := _module.Expression.args(expr#0);
                                        st#51 := st#1;
                                        env#52 := env#2;
                                        assert (forall arg#53: DatatypeType :: DtAlloc(arg#53, $Heap) && DtType(arg#53) == class._module.Expression ==> Seq#Contains(args#50, $Box(arg#53)) ==> DtRank(arg#53) < DtRank(expr#49));
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr#49) <= DtRank(expr#0) && (DtRank(expr#49) == DtRank(expr#0) ==> true);
                                        assume _module.__default.evalArgs#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                        assume resultArgs#48 == _module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                        assume _module.__default.evalArgs#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                        assume _module.Tuple.Pair_q(resultArgs#48);
                                        assume args'#54 == $Unbox(_module.Tuple.fst(resultArgs#48)): Seq BoxType;
                                        assume true;
                                        assume _module.Tuple.Pair_q(resultArgs#48);
                                        assume sts'#55 == $Unbox(_module.Tuple.snd(resultArgs#48)): Set BoxType;
                                        assume true;
                                        assume sts''#56 == Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, st'#47), sts'#55);
                                        assume true;
                                        sts#57 := sts''#56;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assume _module.__default.Compatible#canCall($Heap, this, sts''#56);
                                        if (_module.__default.Compatible($Heap, this, sts''#56))
                                        {
                                            sts#59 := sts''#56;
                                            assert !Set#Equal(sts#59, Set#Empty(): Set BoxType);
                                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                            assume _module.__default.Combine#canCall($Heap, this, sts''#56);
                                            assume stCombined#58 == _module.__default.Combine($LS($LZ), $Heap, this, sts''#56);
                                            assume _module.__default.Combine#canCall($Heap, this, sts''#56);
                                            if (_module.Expression.exprLiteral_q(fun'#46))
                                            {
                                                assert _module.Expression.exprLiteral_q(fun'#46);
                                            }

                                            if (_module.Expression.exprLiteral_q(fun'#46) && _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#46)))
                                            {
                                                assert _module.Expression.exprLiteral_q(fun'#46);
                                                assert _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#46));
                                                if (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit(fun'#46))))
                                                {
                                                    prim#60 := #_module.Primitive.primExec();
                                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                    assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec());
                                                    if (Seq#Length(args'#54) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()))
                                                    {
                                                        prim#61 := #_module.Primitive.primExec();
                                                        args#62 := args'#54;
                                                        st#63 := stCombined#58;
                                                        assert _module.Primitive.primExec_q(prim#61) ==> Seq#Length(args#62) == 3;
                                                        assert _module.Primitive.primCreatePath_q(prim#61) ==> Seq#Length(args#62) == 1;
                                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                        assume _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), args'#54, stCombined#58);
                                                    }

                                                    if (Seq#Length(args'#54) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), args'#54, stCombined#58))
                                                    {
                                                        assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#54);
                                                        assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#54);
                                                        assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#54);
                                                        cmd#64 := $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType;
                                                        deps#65 := $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType;
                                                        exts#66 := $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType;
                                                        st#67 := stCombined#58;
                                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                        assume _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombined#58);
                                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == _module.__default.exec($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombined#58);
                                                        assume _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombined#58);
                                                    }
                                                    else
                                                    {
                                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                                        assume true;
                                                    }
                                                }
                                                else
                                                {
                                                    assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                                    assume true;
                                                }
                                            }
                                            else
                                            {
                                                assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                                assume true;
                                            }
                                        }
                                        else
                                        {
                                            assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), st#1);
                                            assume true;
                                        }
                                    }
                                    else
                                    {
                                        assume _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), st#1);
                                        assume true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



// function declaration for _module._default.evalArgs
function _module.__default.evalArgs($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType) : DatatypeType;

function _module.__default.evalArgs#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: { _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) } _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) == _module.__default.evalArgs($ly, $Heap, this, expr#0, args#1, st#2, env#3));

// frame axiom for _module.__default.evalArgs
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.evalArgs($ly, $h1, this, expr#0, args#1, st#2, env#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.evalArgs#canCall($h0, this, expr#0, args#1, st#2, env#3) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && (forall $i#12: int :: { Seq#Index(args#1, $i#12) } 0 <= $i#12 && $i#12 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#12)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#12)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h0) && GenericAlloc(env#3, $h0))) && (_module.__default.evalArgs#canCall($h1, this, expr#0, args#1, st#2, env#3) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && (forall $i#13: int :: { Seq#Index(args#1, $i#13) } 0 <= $i#13 && $i#13 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#13)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#13)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h1) && GenericAlloc(env#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.evalArgs($ly, $h0, this, expr#0, args#1, st#2, env#3) == _module.__default.evalArgs($ly, $h1, this, expr#0, args#1, st#2, env#3));

// consequence axiom for _module.__default.evalArgs
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 34 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: { _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) } _module.__default.evalArgs#canCall($Heap, this, expr#0, args#1, st#2, env#3) || ((0 != $ModuleContextHeight || 34 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#14: int :: { Seq#Index(args#1, $i#14) } 0 <= $i#14 && $i#14 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#14)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#14)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall arg#4: DatatypeType :: DtAlloc(arg#4, $Heap) && DtType(arg#4) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#4)) ==> DtRank(arg#4) < DtRank(expr#0))) ==> DtAlloc(_module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3), $Heap) && DtType(_module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3)) == class._module.Tuple);

// definition axiom for _module.__default.evalArgs (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: { _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) } _module.__default.evalArgs#canCall($Heap, this, expr#0, args#1, st#2, env#3) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#15: int :: { Seq#Index(args#1, $i#15) } 0 <= $i#15 && $i#15 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#15)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#15)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0))) ==> _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) == _module.__default.evalArgs_k($ly, $Heap, this, expr#0, args#1, st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgs for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3) } _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#6: DatatypeType :: DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#6)) ==> DtRank(arg#6) < DtRank(expr#0))) ==> _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3) == _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgs for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3)) } _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3)) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0))) ==> _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3)) == _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgs (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: { _module.__default.evalArgs($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3) } _module.__default.evalArgs#canCall($Heap, this, expr#0, args#1, st#2, env#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#16: int :: { Seq#Index(args#1, $i#16) } 0 <= $i#16 && $i#16 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#16)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#16)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall arg#8: DatatypeType :: DtAlloc(arg#8, $Heap) && DtType(arg#8) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#8)) ==> DtRank(arg#8) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgs for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3) } _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#9: DatatypeType :: DtAlloc(arg#9, $Heap) && DtType(arg#9) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#9)) ==> DtRank(arg#9) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgs for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgs($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3)) } _module.__default.evalArgs#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#10: DatatypeType :: DtAlloc(arg#10, $Heap) && DtType(arg#10) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#10)) ==> DtRank(arg#10) < DtRank(expr#0))) ==> true);

procedure CheckWellformed$$_module.__default.evalArgs(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, args#1: Seq BoxType where (forall $i#17: int :: { Seq#Index(args#1, $i#17) } 0 <= $i#17 && $i#17 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#17)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#17)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap));
  free requires 0 == $ModuleContextHeight && 34 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.evalArgs(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType)
{
  var arg#11: DatatypeType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var expr#13: DatatypeType;
  var args#14: Seq BoxType;
  var st#15: BoxType;
  var env#16: BoxType;
  var args'#17: Seq BoxType;
  var sts'#18: Set BoxType;

    assume {:captureState "CachedBuilds0.dfy(408,10): initial state"} true;
    havoc arg#11;
    assume DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#11)))
    {
    }

    assume (forall arg#12: DatatypeType :: DtAlloc(arg#12, $Heap) && DtType(arg#12) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#12)) ==> DtRank(arg#12) < DtRank(expr#0));
    if (*)
    {
        assume DtAlloc(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3), $Heap) && DtType(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        expr#13 := expr#0;
        args#14 := args#1;
        st#15 := st#2;
        env#16 := env#3;
        args'#17 := Seq#Empty(): Seq BoxType;
        sts'#18 := Set#Empty(): Set BoxType;
        assert (forall arg#19: DatatypeType :: DtAlloc(arg#19, $Heap) && DtType(arg#19) == class._module.Expression ==> Seq#Contains(args#14, $Box(arg#19)) ==> DtRank(arg#19) < DtRank(expr#13));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert 0 <= Seq#Length(args#1) + 1 || DtRank(expr#13) < DtRank(expr#0) || Seq#Length(args#14) == Seq#Length(args#1) + 1;
        assert DtRank(expr#13) < DtRank(expr#0) || (DtRank(expr#13) == DtRank(expr#0) && Seq#Length(args#14) < Seq#Length(args#1) + 1);
        assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
        assume _module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3) == _module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
        assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
    }
}



// function declaration for _module._default.evalArgs'
function _module.__default.evalArgs_k($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType) : DatatypeType;

function _module.__default.evalArgs_k#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: { _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) == _module.__default.evalArgs_k($ly, $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5));

// frame axiom for _module.__default.evalArgs_k
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.evalArgs_k($ly, $h1, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.evalArgs_k#canCall($h0, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && (forall $i#18: int :: { Seq#Index(args#1, $i#18) } 0 <= $i#18 && $i#18 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#18)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#18)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h0) && GenericAlloc(env#3, $h0) && (forall $i#20: int :: { Seq#Index(args'#4, $i#20) } 0 <= $i#20 && $i#20 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#20)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args'#4, $i#20)): DatatypeType) == class._module.Expression) && (forall $t#22: BoxType :: { sts'#5[$t#22] } sts'#5[$t#22] ==> GenericAlloc($t#22, $h0)))) && (_module.__default.evalArgs_k#canCall($h1, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && (forall $i#19: int :: { Seq#Index(args#1, $i#19) } 0 <= $i#19 && $i#19 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#19)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#19)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h1) && GenericAlloc(env#3, $h1) && (forall $i#21: int :: { Seq#Index(args'#4, $i#21) } 0 <= $i#21 && $i#21 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#21)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args'#4, $i#21)): DatatypeType) == class._module.Expression) && (forall $t#23: BoxType :: { sts'#5[$t#23] } sts'#5[$t#23] ==> GenericAlloc($t#23, $h1)))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.evalArgs_k($ly, $h0, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) == _module.__default.evalArgs_k($ly, $h1, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5));

// consequence axiom for _module.__default.evalArgs_k
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 34 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: { _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) || ((0 != $ModuleContextHeight || 34 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#24: int :: { Seq#Index(args#1, $i#24) } 0 <= $i#24 && $i#24 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#24)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#24)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall $i#25: int :: { Seq#Index(args'#4, $i#25) } 0 <= $i#25 && $i#25 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#25)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#25)): DatatypeType) == class._module.Expression) && (forall $t#26: BoxType :: { sts'#5[$t#26] } sts'#5[$t#26] ==> GenericAlloc($t#26, $Heap)) && (forall arg#6: DatatypeType :: DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#6)) ==> DtRank(arg#6) < DtRank(expr#0))) ==> DtAlloc(_module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5), $Heap) && DtType(_module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5)) == class._module.Tuple);

// definition axiom for _module.__default.evalArgs_k (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: { _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#27: int :: { Seq#Index(args#1, $i#27) } 0 <= $i#27 && $i#27 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#27)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#27)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall $i#28: int :: { Seq#Index(args'#4, $i#28) } 0 <= $i#28 && $i#28 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#28)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#28)): DatatypeType) == class._module.Expression) && (forall $t#29: BoxType :: { sts'#5[$t#29] } sts'#5[$t#29] ==> GenericAlloc($t#29, $Heap)) && (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.eval#canCall($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, st#2, env#3) && _module.__default.evalArgs_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, st#2, env#3))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, st#2, env#3)))))) && _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(args'#4), $Box(sts'#5)) else _module.__default.evalArgs_k($ly, $Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, st#2, env#3))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, st#2, env#3)))))));

// definition axiom for _module.__default.evalArgs_k for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, args'#4, sts'#5) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#8: DatatypeType :: DtAlloc(arg#8, $Heap) && DtType(arg#8) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#8)) ==> DtRank(arg#8) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.eval#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, st#2, env#3) && _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, st#2, env#3))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, st#2, env#3)))))) && _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, args'#4, sts'#5) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(args'#4), $Box(sts'#5)) else _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, st#2, env#3))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, st#2, env#3)))))));

// definition axiom for _module.__default.evalArgs_k for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 34 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Lit(args'#4), Lit(sts'#5)) } _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Lit(args'#4), Lit(sts'#5)) || (34 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#9: DatatypeType :: DtAlloc(arg#9, $Heap) && DtType(arg#9) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#9)) ==> DtRank(arg#9) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.eval#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(st#2), Lit(env#3)) && _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), Lit(st#2), Lit(env#3), Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(st#2), Lit(env#3)))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(st#2), Lit(env#3))))))) && _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Lit(args'#4), Lit(sts'#5)) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(Lit(args'#4)), $Box(Lit(sts'#5))) else _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), Lit(st#2), Lit(env#3), Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(st#2), Lit(env#3)))): DatatypeType))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, _module.Tuple.snd(_module.__default.eval($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(st#2), Lit(env#3))))))));

// definition axiom for _module.__default.evalArgs_k (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: { _module.__default.evalArgs_k($LS($ly), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#30: int :: { Seq#Index(args#1, $i#30) } 0 <= $i#30 && $i#30 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#30)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#30)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && GenericAlloc(env#3, $Heap) && (forall $i#31: int :: { Seq#Index(args'#4, $i#31) } 0 <= $i#31 && $i#31 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#31)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#31)): DatatypeType) == class._module.Expression) && (forall $t#32: BoxType :: { sts'#5[$t#32] } sts'#5[$t#32] ==> GenericAlloc($t#32, $Heap)) && (forall arg#10: DatatypeType :: DtAlloc(arg#10, $Heap) && DtType(arg#10) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#10)) ==> DtRank(arg#10) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgs_k for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, args'#4, sts'#5) } _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), st#2, env#3, args'#4, sts'#5) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#11: DatatypeType :: DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#11)) ==> DtRank(arg#11) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgs_k for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgs_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Lit(args'#4), Lit(sts'#5)) } _module.__default.evalArgs_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(st#2), Lit(env#3), Lit(args'#4), Lit(sts'#5)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#12: DatatypeType :: DtAlloc(arg#12, $Heap) && DtType(arg#12) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#12)) ==> DtRank(arg#12) < DtRank(expr#0))) ==> true);

procedure CheckWellformed$$_module.__default.evalArgs_k(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, args#1: Seq BoxType where (forall $i#33: int :: { Seq#Index(args#1, $i#33) } 0 <= $i#33 && $i#33 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#33)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#33)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#34: int :: { Seq#Index(args'#4, $i#34) } 0 <= $i#34 && $i#34 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#34)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#34)): DatatypeType) == class._module.Expression), sts'#5: Set BoxType where (forall $t#35: BoxType :: { sts'#5[$t#35] } sts'#5[$t#35] ==> GenericAlloc($t#35, $Heap)));
  free requires 0 == $ModuleContextHeight && 34 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.evalArgs_k(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType)
{
  var arg#13: DatatypeType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#15: DatatypeType;
  var result#16: DatatypeType;
  var expr#17: DatatypeType;
  var st#18: BoxType;
  var env#19: BoxType;
  var arg'#20: DatatypeType;
  var st'#21: BoxType;
  var expr#22: DatatypeType;
  var args#23: Seq BoxType;
  var st#24: BoxType;
  var env#25: BoxType;
  var args'#26: Seq BoxType;
  var sts'#27: Set BoxType;

    assume {:captureState "CachedBuilds0.dfy(417,10): initial state"} true;
    havoc arg#13;
    assume DtAlloc(arg#13, $Heap) && DtType(arg#13) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#13)))
    {
    }

    assume (forall arg#14: DatatypeType :: DtAlloc(arg#14, $Heap) && DtType(arg#14) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#14)) ==> DtRank(arg#14) < DtRank(expr#0));
    if (*)
    {
        assume DtAlloc(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5), $Heap) && DtType(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        if (Seq#Equal(args#1, Seq#Empty(): Seq BoxType))
        {
            assume _module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) == #_module.Tuple.Pair($Box(args'#4), $Box(sts'#5));
            assume true;
        }
        else
        {
            assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
            assume arg#15 == $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
            assume true;
            expr#17 := arg#15;
            st#18 := st#2;
            env#19 := env#3;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert DtRank(expr#17) < DtRank(expr#0);
            assume _module.__default.eval#canCall($Heap, this, arg#15, st#2, env#3);
            assume result#16 == _module.__default.eval($LS($LZ), $Heap, this, arg#15, st#2, env#3);
            assume _module.__default.eval#canCall($Heap, this, arg#15, st#2, env#3);
            assume _module.Tuple.Pair_q(result#16);
            assume arg'#20 == $Unbox(_module.Tuple.fst(result#16)): DatatypeType;
            assume true;
            assume _module.Tuple.Pair_q(result#16);
            assume st'#21 == _module.Tuple.snd(result#16);
            assume true;
            assert 0 <= Lit(1) && Lit(1) <= Seq#Length(args#1);
            expr#22 := expr#0;
            args#23 := Seq#Drop(args#1, Lit(1));
            st#24 := st#2;
            env#25 := env#3;
            args'#26 := Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20)));
            sts'#27 := Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, st'#21));
            assert (forall arg#28: DatatypeType :: DtAlloc(arg#28, $Heap) && DtType(arg#28) == class._module.Expression ==> Seq#Contains(args#23, $Box(arg#28)) ==> DtRank(arg#28) < DtRank(expr#22));
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert 0 <= Seq#Length(args#1) || DtRank(expr#22) < DtRank(expr#0) || Seq#Length(args#23) == Seq#Length(args#1);
            assert DtRank(expr#22) < DtRank(expr#0) || (DtRank(expr#22) == DtRank(expr#0) && Seq#Length(args#23) < Seq#Length(args#1));
            assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, st'#21)));
            assume _module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5) == _module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, st'#21)));
            assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), st#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, st'#21)));
        }
    }
}



// function declaration for _module._default.Arity
function _module.__default.Arity($heap: HeapType, this: ref, prim#0: DatatypeType) : int;

function _module.__default.Arity#canCall($heap: HeapType, this: ref, prim#0: DatatypeType) : bool;

// frame axiom for _module.__default.Arity
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, prim#0: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.Arity($h1, this, prim#0) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.Arity#canCall($h0, this, prim#0) || (DtAlloc(prim#0, $h0) && DtType(prim#0) == class._module.Primitive)) && (_module.__default.Arity#canCall($h1, this, prim#0) || (DtAlloc(prim#0, $h1) && DtType(prim#0) == class._module.Primitive)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.Arity($h0, this, prim#0) == _module.__default.Arity($h1, this, prim#0));

// consequence axiom for _module.__default.Arity
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 32 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, prim#0: DatatypeType :: { _module.__default.Arity($Heap, this, prim#0) } _module.__default.Arity#canCall($Heap, this, prim#0) || ((0 != $ModuleContextHeight || 32 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive) ==> 0 <= _module.__default.Arity($Heap, this, prim#0));

// definition axiom for _module.__default.Arity (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 32 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref :: { _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primCreatePath()) || (32 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) == Lit(1));

// definition axiom for _module.__default.Arity for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 32 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref :: {:weight 10} { _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primCreatePath()) || (32 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) == Lit(1));

// definition axiom for _module.__default.Arity (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 32 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref :: { _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) || (32 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) == Lit(3));

// definition axiom for _module.__default.Arity for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 32 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref :: {:weight 10} { _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) || (32 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) == Lit(3));

// definition axiom for _module.__default.Arity (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref :: { _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primCreatePath()) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

// definition axiom for _module.__default.Arity for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref :: {:weight 10} { _module.__default.Arity($Heap, this, #_module.Primitive.primCreatePath()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primCreatePath()) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

// definition axiom for _module.__default.Arity (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref :: { _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

// definition axiom for _module.__default.Arity for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref :: {:weight 10} { _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) } _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.Arity(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prim#0: DatatypeType where DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive);
  free requires 0 == $ModuleContextHeight && 32 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.Arity(this: ref, prim#0: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;

    assume {:captureState "CachedBuilds0.dfy(432,10): initial state"} true;
    if (*)
    {
        assume 0 <= _module.__default.Arity($Heap, this, prim#0);
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        if (prim#0 == #_module.Primitive.primCreatePath())
        {
            assert 0 <= Lit(1);
            assume _module.__default.Arity($Heap, this, prim#0) == Lit(1);
            assume true;
        }
        else if (prim#0 == #_module.Primitive.primExec())
        {
            assert 0 <= Lit(3);
            assume _module.__default.Arity($Heap, this, prim#0) == Lit(3);
            assume true;
        }
        else
        {
            assume false;
        }
    }
}



// function declaration for _module._default.ValidArgs
function _module.__default.ValidArgs($heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType) : bool;

function _module.__default.ValidArgs#canCall($heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType) : bool;

// frame axiom for _module.__default.ValidArgs
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.ValidArgs($h1, this, prim#0, args#1, st#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.ValidArgs#canCall($h0, this, prim#0, args#1, st#2) || (DtAlloc(prim#0, $h0) && DtType(prim#0) == class._module.Primitive && (forall $i#36: int :: { Seq#Index(args#1, $i#36) } 0 <= $i#36 && $i#36 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#36)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#36)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h0))) && (_module.__default.ValidArgs#canCall($h1, this, prim#0, args#1, st#2) || (DtAlloc(prim#0, $h1) && DtType(prim#0) == class._module.Primitive && (forall $i#37: int :: { Seq#Index(args#1, $i#37) } 0 <= $i#37 && $i#37 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#37)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#37)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.ValidArgs($h0, this, prim#0, args#1, st#2) == _module.__default.ValidArgs($h1, this, prim#0, args#1, st#2));

// consequence axiom for _module.__default.ValidArgs
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 33 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType :: { _module.__default.ValidArgs($Heap, this, prim#0, args#1, st#2) } _module.__default.ValidArgs#canCall($Heap, this, prim#0, args#1, st#2) || ((0 != $ModuleContextHeight || 33 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive && (forall $i#38: int :: { Seq#Index(args#1, $i#38) } 0 <= $i#38 && $i#38 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#38)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#38)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && (_module.Primitive.primExec_q(prim#0) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(prim#0) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgs (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 33 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), args#1, st#2) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primCreatePath(), args#1, st#2) || (33 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#39: int :: { Seq#Index(args#1, $i#39) } 0 <= $i#39 && $i#39 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#39)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#39)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 1)) ==> _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), args#1, st#2) == Lit(false));

// definition axiom for _module.__default.ValidArgs for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 33 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: {:weight 10} { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(st#2)) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(st#2)) || (33 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 1)) ==> _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(st#2)) == Lit(false));

// definition axiom for _module.__default.ValidArgs (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 33 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), args#1, st#2) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), args#1, st#2) || (33 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#40: int :: { Seq#Index(args#1, $i#40) } 0 <= $i#40 && $i#40 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#40)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#40)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 1)) ==> (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) ==> _module.__default.DomSt#canCall($Heap, this, st#2)) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, st#2)) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), st#2) && _module.__default.Pre#canCall($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), st#2))) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), args#1, st#2) == (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, st#2)) && _module.__default.Pre($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), st#2))));

// definition axiom for _module.__default.ValidArgs for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 33 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: {:weight 10} { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(st#2)) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(st#2)) || (33 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 1)) ==> (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) ==> _module.__default.DomSt#canCall($Heap, this, Lit(st#2))) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, Lit(st#2))) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), Lit(st#2)) && _module.__default.Pre#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), Lit(st#2)))) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(st#2)) == (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, Lit(st#2))) && _module.__default.Pre($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), Lit(st#2)))));

// definition axiom for _module.__default.ValidArgs (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), args#1, st#2) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primCreatePath(), args#1, st#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#41: int :: { Seq#Index(args#1, $i#41) } 0 <= $i#41 && $i#41 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#41)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#41)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgs for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: {:weight 10} { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(st#2)) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(st#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgs (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), args#1, st#2) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), args#1, st#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#42: int :: { Seq#Index(args#1, $i#42) } 0 <= $i#42 && $i#42 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#42)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#42)): DatatypeType) == class._module.Expression) && GenericAlloc(st#2, $Heap) && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgs for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, st#2: BoxType :: {:weight 10} { _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(st#2)) } _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(st#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 1)) ==> true);

procedure CheckWellformed$$_module.__default.ValidArgs(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prim#0: DatatypeType where DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive, args#1: Seq BoxType where (forall $i#43: int :: { Seq#Index(args#1, $i#43) } 0 <= $i#43 && $i#43 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#43)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#43)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap));
  free requires 0 == $ModuleContextHeight && 33 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.ValidArgs(this: ref, prim#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var cmd#3: DatatypeType;
  var deps#4: DatatypeType;
  var exts#5: DatatypeType;
  var st#6: BoxType;
  var paths#7: Set BoxType;
  var st#8: BoxType;
  var cmd#9: DatatypeType;
  var deps#10: DatatypeType;
  var exts#11: DatatypeType;
  var st#12: BoxType;

    assume {:captureState "CachedBuilds0.dfy(439,11): initial state"} true;
    if (_module.Primitive.primExec_q(prim#0))
    {
    }

    assume _module.Primitive.primExec_q(prim#0) ==> Seq#Length(args#1) == 3;
    if (_module.Primitive.primCreatePath_q(prim#0))
    {
    }

    assume _module.Primitive.primCreatePath_q(prim#0) ==> Seq#Length(args#1) == 1;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        if (prim#0 == #_module.Primitive.primCreatePath())
        {
            assume _module.__default.ValidArgs($Heap, this, prim#0, args#1, st#2) == Lit(false);
            assume true;
        }
        else if (prim#0 == #_module.Primitive.primExec())
        {
            assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
            assume cmd#3 == $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
            assume true;
            assert 0 <= Lit(1) && Lit(1) < Seq#Length(args#1);
            assume deps#4 == $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType;
            assume true;
            assert 0 <= Lit(2) && Lit(2) < Seq#Length(args#1);
            assume exts#5 == $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType;
            assume true;
            if (_module.Expression.exprLiteral_q(cmd#3))
            {
                assert _module.Expression.exprLiteral_q(cmd#3);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)))
            {
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4))
            {
                assert _module.Expression.exprLiteral_q(deps#4);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)))
            {
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5))
            {
                assert _module.Expression.exprLiteral_q(exts#5);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)))
            {
                assert _module.Expression.exprLiteral_q(deps#4);
                assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4));
                st#6 := st#2;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.DomSt#canCall($Heap, this, st#2);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, st#2)))
            {
                assert _module.Expression.exprLiteral_q(deps#4);
                assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4));
                paths#7 := _module.Literal.paths(_module.Expression.lit(deps#4));
                st#8 := st#2;
                assert Set#Subset(paths#7, _module.__default.DomSt($Heap, this, st#8));
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2);
                cmd#9 := cmd#3;
                deps#10 := deps#4;
                exts#11 := exts#5;
                st#12 := _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2);
                assert _module.Expression.exprLiteral_q(cmd#9) && _module.Literal.litString_q(_module.Expression.lit(cmd#9)) && _module.Expression.exprLiteral_q(deps#10) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#10)) && _module.Expression.exprLiteral_q(exts#11) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#11));
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Pre#canCall($Heap, this, cmd#3, deps#4, exts#5, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2));
            }

            assume _module.__default.ValidArgs($Heap, this, prim#0, args#1, st#2) == (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, st#2)) && _module.__default.Pre($Heap, this, cmd#3, deps#4, exts#5, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2)));
            assume (_module.Expression.exprLiteral_q(cmd#3) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) ==> _module.__default.DomSt#canCall($Heap, this, st#2)) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, st#2)) ==> _module.__default.Restrict#canCall($Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2) && _module.__default.Pre#canCall($Heap, this, cmd#3, deps#4, exts#5, _module.__default.Restrict($LS($LZ), $Heap, this, _module.Literal.paths(_module.Expression.lit(deps#4)), st#2)));
        }
        else
        {
            assume false;
        }
    }
}



// function declaration for _module._default.buildC
function _module.__default.buildC($heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType) : DatatypeType;

function _module.__default.buildC#canCall($heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType) : bool;

// frame axiom for _module.__default.buildC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.buildC($h1, this, prog#0, stC#1) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.buildC#canCall($h0, this, prog#0, stC#1) || (DtAlloc(prog#0, $h0) && DtType(prog#0) == class._module.Program && DtAlloc(stC#1, $h0) && DtType(stC#1) == class._module.StateC)) && (_module.__default.buildC#canCall($h1, this, prog#0, stC#1) || (DtAlloc(prog#0, $h1) && DtType(prog#0) == class._module.Program && DtAlloc(stC#1, $h1) && DtType(stC#1) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.buildC($h0, this, prog#0, stC#1) == _module.__default.buildC($h1, this, prog#0, stC#1));

// consequence axiom for _module.__default.buildC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 40 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: { _module.__default.buildC($Heap, this, prog#0, stC#1) } _module.__default.buildC#canCall($Heap, this, prog#0, stC#1) || ((0 != $ModuleContextHeight || 40 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> DtAlloc(_module.__default.buildC($Heap, this, prog#0, stC#1), $Heap) && DtType(_module.__default.buildC($Heap, this, prog#0, stC#1)) == class._module.Tuple);

// definition axiom for _module.__default.buildC (intra-module)
axiom 0 == $ModuleContextHeight && 40 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: { _module.__default.buildC($Heap, this, prog#0, stC#1) } _module.__default.buildC#canCall($Heap, this, prog#0, stC#1) || (40 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.doC#canCall($Heap, this, _module.Program.stmts(prog#0), stC#1, _module.__default.EmptyEnv($Heap, this)) && _module.__default.buildC($Heap, this, prog#0, stC#1) == _module.__default.doC($LS($LZ), $Heap, this, _module.Program.stmts(prog#0), stC#1, _module.__default.EmptyEnv($Heap, this)));

// definition axiom for _module.__default.buildC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 40 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: {:weight 10} { _module.__default.buildC($Heap, this, Lit(prog#0), Lit(stC#1)) } _module.__default.buildC#canCall($Heap, this, Lit(prog#0), Lit(stC#1)) || (40 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, _module.Program.stmts(Lit(prog#0)))) ==> _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.doC#canCall($Heap, this, _module.Program.stmts(Lit(prog#0)), Lit(stC#1), _module.__default.EmptyEnv($Heap, this)) && _module.__default.buildC($Heap, this, Lit(prog#0), Lit(stC#1)) == _module.__default.doC($LS($LZ), $Heap, this, _module.Program.stmts(Lit(prog#0)), Lit(stC#1), _module.__default.EmptyEnv($Heap, this)));

// definition axiom for _module.__default.buildC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: { _module.__default.buildC($Heap, this, prog#0, stC#1) } _module.__default.buildC#canCall($Heap, this, prog#0, stC#1) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0))) ==> true);

// definition axiom for _module.__default.buildC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, prog#0: DatatypeType, stC#1: DatatypeType :: {:weight 10} { _module.__default.buildC($Heap, this, Lit(prog#0), Lit(stC#1)) } _module.__default.buildC#canCall($Heap, this, Lit(prog#0), Lit(stC#1)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, _module.Program.stmts(Lit(prog#0)))) ==> true);

procedure CheckWellformed$$_module.__default.buildC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program, stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 40 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.buildC(this: ref, prog#0: DatatypeType, stC#1: DatatypeType)
{
  var stmts#2: Seq BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#3: Seq BoxType;
  var stC#4: DatatypeType;
  var env#5: BoxType;

    assume {:captureState "CachedBuilds0.dfy(455,10): initial state"} true;
    assume _module.Program.Program_q(prog#0);
    stmts#2 := _module.Program.stmts(prog#0);
    assume _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0));
    assume _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
    if (*)
    {
        assume DtAlloc(_module.__default.buildC($Heap, this, prog#0, stC#1), $Heap) && DtType(_module.__default.buildC($Heap, this, prog#0, stC#1)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assume _module.Program.Program_q(prog#0);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.EmptyEnv#canCall($Heap, this);
        stmts#3 := _module.Program.stmts(prog#0);
        stC#4 := stC#1;
        env#5 := _module.__default.EmptyEnv($Heap, this);
        assert _module.__default.Legal($Heap, this, stmts#3);
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.doC#canCall($Heap, this, _module.Program.stmts(prog#0), stC#1, _module.__default.EmptyEnv($Heap, this));
        assume _module.__default.buildC($Heap, this, prog#0, stC#1) == _module.__default.doC($LS($LZ), $Heap, this, _module.Program.stmts(prog#0), stC#1, _module.__default.EmptyEnv($Heap, this));
        assume _module.__default.EmptyEnv#canCall($Heap, this) && _module.__default.doC#canCall($Heap, this, _module.Program.stmts(prog#0), stC#1, _module.__default.EmptyEnv($Heap, this));
    }
}



// function declaration for _module._default.doC
function _module.__default.doC($ly: LayerType, $heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType) : DatatypeType;

function _module.__default.doC#canCall($heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) } _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) == _module.__default.doC($ly, $Heap, this, stmts#0, stC#1, env#2));

// frame axiom for _module.__default.doC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.doC($ly, $h1, this, stmts#0, stC#1, env#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.doC#canCall($h0, this, stmts#0, stC#1, env#2) || ((forall $i#44: int :: { Seq#Index(stmts#0, $i#44) } 0 <= $i#44 && $i#44 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#44)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(stmts#0, $i#44)): DatatypeType) == class._module.Statement) && DtAlloc(stC#1, $h0) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $h0))) && (_module.__default.doC#canCall($h1, this, stmts#0, stC#1, env#2) || ((forall $i#45: int :: { Seq#Index(stmts#0, $i#45) } 0 <= $i#45 && $i#45 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#45)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(stmts#0, $i#45)): DatatypeType) == class._module.Statement) && DtAlloc(stC#1, $h1) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.doC($ly, $h0, this, stmts#0, stC#1, env#2) == _module.__default.doC($ly, $h1, this, stmts#0, stC#1, env#2));

// consequence axiom for _module.__default.doC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 39 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) } _module.__default.doC#canCall($Heap, this, stmts#0, stC#1, env#2) || ((0 != $ModuleContextHeight || 39 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#46: int :: { Seq#Index(stmts#0, $i#46) } 0 <= $i#46 && $i#46 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#46)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#46)): DatatypeType) == class._module.Statement) && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> DtAlloc(_module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2), $Heap) && DtType(_module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2)) == class._module.Tuple);

// definition axiom for _module.__default.doC (intra-module)
axiom 0 == $ModuleContextHeight && 39 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) } _module.__default.doC#canCall($Heap, this, stmts#0, stC#1, env#2) || (39 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#47: int :: { Seq#Index(stmts#0, $i#47) } 0 <= $i#47 && $i#47 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#47)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#47)): DatatypeType) == class._module.Statement) && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> (_module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) ==> _module.__default.evalC#canCall($Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2) && _module.__default.Value#canCall($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType) && (_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType) ==> _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType, env#2) && _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1))) && (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) ==> _module.__default.doC#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType, _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType, env#2))) && (!_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) ==> true)) && (!_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType) ==> true)) && (!_module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) ==> _module.__default.evalC#canCall($Heap, this, _module.Statement.ret($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2)) && _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) == (if _module.Statement.stmtVariable_q($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType) then (if _module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType) then (if _module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))) then _module.__default.doC($ly, $Heap, this, Seq#Drop(stmts#0, Lit(1)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType, _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType, env#2)) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2))): DatatypeType))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1))) else _module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.ret($Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType), stC#1, env#2)));

// definition axiom for _module.__default.doC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 39 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.doC($ly, $Heap, this, Lit(stmts#0), Lit(stC#1), Lit(env#2)) } _module.__default.doC#canCall($Heap, this, Lit(stmts#0), Lit(stC#1), Lit(env#2)) || (39 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, Lit(stmts#0))) ==> (_module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) ==> _module.__default.evalC#canCall($Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)) && _module.__default.Value#canCall($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType) && (_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)) && _module.__default.Legal#canCall($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) && (_module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) ==> _module.__default.doC#canCall($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType, _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)))) && (!_module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) ==> true)) && (!_module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true)) && (!_module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) ==> _module.__default.evalC#canCall($Heap, this, _module.Statement.ret($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2))) && _module.__default.doC($ly, $Heap, this, Lit(stmts#0), Lit(stC#1), Lit(env#2)) == (if _module.Statement.stmtVariable_q($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType) then (if _module.__default.Value($Heap, this, $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType) then (if _module.__default.Legal($Heap, this, Seq#Drop(Lit(stmts#0), Lit(1))) then _module.__default.doC($ly, $Heap, this, Seq#Drop(Lit(stmts#0), Lit(1)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType, _module.__default.SetEnv($Heap, this, _module.Statement.id($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), $Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2))) else #_module.Tuple.Pair($Box($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2)))): DatatypeType))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1)))) else _module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.ret($Unbox(Seq#Index(Lit(stmts#0), Lit(0))): DatatypeType), Lit(stC#1), Lit(env#2))));

// definition axiom for _module.__default.doC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.doC($LS($ly), $Heap, this, stmts#0, stC#1, env#2) } _module.__default.doC#canCall($Heap, this, stmts#0, stC#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#48: int :: { Seq#Index(stmts#0, $i#48) } 0 <= $i#48 && $i#48 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#48)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#48)): DatatypeType) == class._module.Statement) && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap) && _module.__default.Legal($Heap, this, stmts#0)) ==> true);

// definition axiom for _module.__default.doC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.doC($ly, $Heap, this, Lit(stmts#0), Lit(stC#1), Lit(env#2)) } _module.__default.doC#canCall($Heap, this, Lit(stmts#0), Lit(stC#1), Lit(env#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && _module.__default.Legal($Heap, this, Lit(stmts#0))) ==> true);

procedure CheckWellformed$$_module.__default.doC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#49: int :: { Seq#Index(stmts#0, $i#49) } 0 <= $i#49 && $i#49 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#49)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#49)): DatatypeType) == class._module.Statement), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC, env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 39 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.doC(this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType)
{
  var stmts#3: Seq BoxType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmt#4: DatatypeType;
  var result#5: DatatypeType;
  var expr#6: DatatypeType;
  var stC#7: DatatypeType;
  var env#8: BoxType;
  var expr'#9: DatatypeType;
  var stC'#10: DatatypeType;
  var expr#11: DatatypeType;
  var env'#12: BoxType;
  var id#13: BoxType;
  var expr#14: DatatypeType;
  var env#15: BoxType;
  var stmts#16: Seq BoxType;
  var stmts#17: Seq BoxType;
  var stC#18: DatatypeType;
  var env#19: BoxType;
  var expr#20: DatatypeType;
  var stC#21: DatatypeType;
  var env#22: BoxType;

    assume {:captureState "CachedBuilds0.dfy(462,10): initial state"} true;
    stmts#3 := stmts#0;
    assume _module.__default.Legal#canCall($Heap, this, stmts#0);
    assume _module.__default.Legal($Heap, this, stmts#0);
    if (*)
    {
        assume DtAlloc(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2), $Heap) && DtType(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        assert 0 <= Lit(0) && Lit(0) < Seq#Length(stmts#0);
        assume stmt#4 == $Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType;
        assume true;
        if (_module.Statement.stmtVariable_q(stmt#4))
        {
            assert _module.Statement.stmtVariable_q(stmt#4);
            expr#6 := _module.Statement.expr(stmt#4);
            stC#7 := stC#1;
            env#8 := env#2;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.evalC#canCall($Heap, this, _module.Statement.expr(stmt#4), stC#1, env#2);
            assume result#5 == _module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr(stmt#4), stC#1, env#2);
            assume _module.__default.evalC#canCall($Heap, this, _module.Statement.expr(stmt#4), stC#1, env#2);
            assume _module.Tuple.Pair_q(result#5);
            assume expr'#9 == $Unbox(_module.Tuple.fst(result#5)): DatatypeType;
            assume true;
            assume _module.Tuple.Pair_q(result#5);
            assume stC'#10 == $Unbox(_module.Tuple.snd(result#5)): DatatypeType;
            assume true;
            expr#11 := expr'#9;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.Value#canCall($Heap, this, expr'#9);
            if (_module.__default.Value($Heap, this, expr'#9))
            {
                assert _module.Statement.stmtVariable_q(stmt#4);
                id#13 := _module.Statement.id(stmt#4);
                expr#14 := expr'#9;
                env#15 := env#2;
                assert _module.__default.Value($Heap, this, expr#14);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assume env'#12 == _module.__default.SetEnv($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#4), expr'#9, env#2);
                assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                stmts#16 := Seq#Drop(stmts#0, Lit(1));
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
                if (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))))
                {
                    assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                    stmts#17 := Seq#Drop(stmts#0, Lit(1));
                    stC#18 := stC'#10;
                    env#19 := env'#12;
                    assert _module.__default.Legal($Heap, this, stmts#17);
                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                    assert Seq#Rank(stmts#17) < Seq#Rank(stmts#0) || (Seq#Rank(stmts#17) == Seq#Rank(stmts#0) && DtRank(stC#18) < DtRank(stC#1));
                    assume _module.__default.doC#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), stC'#10, env'#12);
                    assume _module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2) == _module.__default.doC($LS($LZ), $Heap, this, Seq#Drop(stmts#0, Lit(1)), stC'#10, env'#12);
                    assume _module.__default.doC#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)), stC'#10, env'#12);
                }
                else
                {
                    assume _module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2) == #_module.Tuple.Pair($Box(expr'#9), $Box(stC'#10));
                    assume true;
                }
            }
            else
            {
                assume _module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                assume true;
            }
        }
        else
        {
            // ----- assert statement ----- CachedBuilds0.dfy(479,5)
            if (!_module.Statement.stmtVariable_q(stmt#4))
            {
            }

            assume !_module.Statement.stmtVariable_q(stmt#4) ==> true;
            assert _module.Statement.stmtVariable_q(stmt#4) || _module.Statement.stmtReturn_q(stmt#4);
            assert _module.Statement.stmtReturn_q(stmt#4);
            expr#20 := _module.Statement.ret(stmt#4);
            stC#21 := stC#1;
            env#22 := env#2;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assume _module.__default.evalC#canCall($Heap, this, _module.Statement.ret(stmt#4), stC#1, env#2);
            assume _module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.ret(stmt#4), stC#1, env#2);
            assume _module.__default.evalC#canCall($Heap, this, _module.Statement.ret(stmt#4), stC#1, env#2);
        }
    }
}



// function declaration for _module._default.evalC
function _module.__default.evalC($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType) : DatatypeType;

function _module.__default.evalC#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) } _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($ly, $Heap, this, expr#0, stC#1, env#2));

// frame axiom for _module.__default.evalC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: { $HeapSucc($h0, $h1), _module.__default.evalC($ly, $h1, this, expr#0, stC#1, env#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.evalC#canCall($h0, this, expr#0, stC#1, env#2) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && DtAlloc(stC#1, $h0) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $h0))) && (_module.__default.evalC#canCall($h1, this, expr#0, stC#1, env#2) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && DtAlloc(stC#1, $h1) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.evalC($ly, $h0, this, expr#0, stC#1, env#2) == _module.__default.evalC($ly, $h1, this, expr#0, stC#1, env#2));

// consequence axiom for _module.__default.evalC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 38 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) } _module.__default.evalC#canCall($Heap, this, expr#0, stC#1, env#2) || ((0 != $ModuleContextHeight || 38 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap)) ==> DtAlloc(_module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2), $Heap) && DtType(_module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2)) == class._module.Tuple);

// definition axiom for _module.__default.evalC (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) } _module.__default.evalC#canCall($Heap, this, expr#0, stC#1, env#2) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap)) ==> _module.__default.Value#canCall($Heap, this, expr#0) && (_module.__default.Value($Heap, this, expr#0) ==> true) && (!_module.__default.Value($Heap, this, expr#0) ==> (_module.Expression.exprIdentifier_q(expr#0) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2)) && (!_module.Expression.exprIdentifier_q(expr#0) ==> (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), stC#1, env#2)) && (!(_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), stC#1, env#2)) && (!(_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(expr#0) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(expr#0), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(expr#0) ==> (_module.Expression.exprAnd_q(expr#0) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj1(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(expr#0) ==> (_module.Expression.exprOr_q(expr#0) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj1(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(expr#0) ==> (_module.Expression.exprInvocation_q(expr#0) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(expr#0), stC#1, env#2) && _module.__default.evalArgsC#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2) && _module.__default.CompatibleC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)) && (_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)) ==> _module.__default.CombineC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) ==> _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)))) ==> _module.__default.ConsistentCache#canCall($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) && (_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) ==> true) && (!_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) ==> true))) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType))) ==> true)) && (!_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(expr#0) ==> true)))))))) && _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) == (if _module.__default.Value($Heap, this, expr#0) then #_module.Tuple.Pair($Box(expr#0), $Box(stC#1)) else (if _module.Expression.exprIdentifier_q(expr#0) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(expr#0), env#2)), $Box(stC#1)) else (if _module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(expr#0), stC#1, env#2) else (if _module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(expr#0), stC#1, env#2) else (if _module.Expression.exprIf_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType, env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2))): DatatypeType, env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprAnd_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.conj1(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType, env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2))): DatatypeType)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprOr_q(expr#0) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.disj1(expr#0), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2))): DatatypeType, env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprInvocation_q(expr#0) then (if _module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) then _module.__default.execC($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) else (if _module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2))): Set BoxType))) then #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rInconsistentCache())), $Box(stC#1)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))))))))));

// definition axiom for _module.__default.evalC for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.evalC($ly, $Heap, this, Lit(expr#0), stC#1, env#2) } _module.__default.evalC#canCall($Heap, this, Lit(expr#0), stC#1, env#2) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Value#canCall($Heap, this, Lit(expr#0)) && (_module.__default.Value($Heap, this, Lit(expr#0)) ==> true) && (!_module.__default.Value($Heap, this, Lit(expr#0)) ==> (_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(Lit(expr#0)), env#2)) && (!_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), stC#1, env#2)) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), stC#1, env#2)) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(Lit(expr#0)) ==> (_module.Expression.exprAnd_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(Lit(expr#0)) ==> (_module.Expression.exprOr_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(Lit(expr#0)) ==> (_module.Expression.exprInvocation_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2) && _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2) && _module.__default.CompatibleC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)) && (_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)) ==> _module.__default.CombineC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) ==> _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)))) ==> _module.__default.ConsistentCache#canCall($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) && (_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) ==> true) && (!_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) ==> true))) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType))) ==> true)) && (!_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(Lit(expr#0)) ==> true)))))))) && _module.__default.evalC($ly, $Heap, this, Lit(expr#0), stC#1, env#2) == (if _module.__default.Value($Heap, this, Lit(expr#0)) then #_module.Tuple.Pair($Box(Lit(expr#0)), $Box(stC#1)) else (if _module.Expression.exprIdentifier_q(Lit(expr#0)) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(Lit(expr#0)), env#2)), $Box(stC#1)) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), stC#1, env#2) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), stC#1, env#2) else (if _module.Expression.exprIf_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprAnd_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.conj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), stC#1, env#2))): DatatypeType)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprOr_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.disj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), stC#1, env#2))): DatatypeType, env#2) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))) else (if _module.Expression.exprInvocation_q(Lit(expr#0)) then (if _module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) then _module.__default.execC($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) else (if _module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), stC#1, env#2))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), stC#1, env#2))): Set BoxType))) then #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rInconsistentCache())), $Box(stC#1)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), $Box(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1)))))))))));

// definition axiom for _module.__default.evalC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.evalC($ly, $Heap, this, Lit(expr#0), Lit(stC#1), Lit(env#2)) } _module.__default.evalC#canCall($Heap, this, Lit(expr#0), Lit(stC#1), Lit(env#2)) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> _module.__default.Value#canCall($Heap, this, Lit(expr#0)) && (_module.__default.Value($Heap, this, Lit(expr#0)) ==> true) && (!_module.__default.Value($Heap, this, Lit(expr#0)) ==> (_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(Lit(expr#0)), Lit(env#2))) && (!_module.Expression.exprIdentifier_q(Lit(expr#0)) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), Lit(stC#1), Lit(env#2))) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) ==> true) && (_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), Lit(stC#1), Lit(env#2))) && (!(_module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse()) ==> (_module.Expression.exprIf_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprIf_q(Lit(expr#0)) ==> (_module.Expression.exprAnd_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.conj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprAnd_q(Lit(expr#0)) ==> (_module.Expression.exprOr_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() ==> true) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue()) ==> (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.disj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2))) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse()) ==> true))) && (!_module.Expression.exprOr_q(Lit(expr#0)) ==> (_module.Expression.exprInvocation_q(Lit(expr#0)) ==> _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)) && _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)) && _module.__default.CompatibleC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)) && (_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)) ==> _module.__default.CombineC#canCall($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)) ==> (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType))) ==> _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)))) && (Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) ==> _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)))) && (!(Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)))) ==> _module.__default.ConsistentCache#canCall($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) && (_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) ==> true) && (!_module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) ==> true))) && (!_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType))) ==> true)) && (!(_module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType))) ==> true)) && (!_module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)) ==> true)) && (!_module.Expression.exprInvocation_q(Lit(expr#0)) ==> true)))))))) && _module.__default.evalC($ly, $Heap, this, Lit(expr#0), Lit(stC#1), Lit(env#2)) == (if _module.__default.Value($Heap, this, Lit(expr#0)) then #_module.Tuple.Pair($Box(Lit(expr#0)), $Box(Lit(stC#1))) else (if _module.Expression.exprIdentifier_q(Lit(expr#0)) then #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(Lit(expr#0)), Lit(env#2))), $Box(Lit(stC#1))) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), Lit(stC#1), Lit(env#2)) else (if _module.Expression.exprIf_q(Lit(expr#0)) && _module.Expression.exprLiteral_q(_module.Expression.cond(Lit(expr#0))) && _module.Expression.lit(_module.Expression.cond(Lit(expr#0))) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), Lit(stC#1), Lit(env#2)) else (if _module.Expression.exprIf_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifTrue(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.ifFalse(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.cond(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1))))) else (if _module.Expression.exprAnd_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then _module.__default.evalC($ly, $Heap, this, _module.Expression.conj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.conj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1))))) else (if _module.Expression.exprOr_q(Lit(expr#0)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litTrue() then #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)) else (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) == #_module.Literal.litFalse() then _module.__default.evalC($ly, $Heap, this, _module.Expression.disj1(Lit(expr#0)), $Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.disj0(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType, Lit(env#2)) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1))))) else (if _module.Expression.exprInvocation_q(Lit(expr#0)) then (if _module.__default.CompatibleC($Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType)) then (if _module.Expression.exprLiteral_q($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType) && _module.Literal.litPrimitive_q(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)) then (if _module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType))) then (if Seq#Length($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), $Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) then _module.__default.execC($Heap, this, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(0))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(1))): DatatypeType, $Unbox(Seq#Index($Unbox(_module.Tuple.fst(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Seq BoxType, Lit(2))): DatatypeType, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) else (if _module.__default.ConsistentCache($Heap, this, _module.__default.CombineC($LS($LZ), $Heap, this, Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, _module.Expression.fun(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): DatatypeType)), $Unbox(_module.Tuple.snd(_module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), _module.Expression.args(Lit(expr#0)), Lit(stC#1), Lit(env#2)))): Set BoxType))) then #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rInconsistentCache())), $Box(Lit(stC#1))))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), $Box(Lit(stC#1)))) else #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(Lit(stC#1))))))))))));

// definition axiom for _module.__default.evalC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: { _module.__default.evalC($LS($ly), $Heap, this, expr#0, stC#1, env#2) } _module.__default.evalC#canCall($Heap, this, expr#0, stC#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && GenericAlloc(env#2, $Heap)) ==> true);

// definition axiom for _module.__default.evalC for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.evalC($ly, $Heap, this, Lit(expr#0), stC#1, env#2) } _module.__default.evalC#canCall($Heap, this, Lit(expr#0), stC#1, env#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

// definition axiom for _module.__default.evalC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType :: {:weight 10} { _module.__default.evalC($ly, $Heap, this, Lit(expr#0), Lit(stC#1), Lit(env#2)) } _module.__default.evalC#canCall($Heap, this, Lit(expr#0), Lit(stC#1), Lit(env#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default) ==> true);

procedure CheckWellformed$$_module.__default.evalC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC, env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 38 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.evalC(this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var expr#3: DatatypeType;
  var id#4: BoxType;
  var env#5: BoxType;
  var expr#6: DatatypeType;
  var stC#7: DatatypeType;
  var env#8: BoxType;
  var expr#9: DatatypeType;
  var stC#10: DatatypeType;
  var env#11: BoxType;
  var result#12: DatatypeType;
  var expr#13: DatatypeType;
  var stC#14: DatatypeType;
  var env#15: BoxType;
  var cond'#16: DatatypeType;
  var stC'#17: DatatypeType;
  var expr#18: DatatypeType;
  var stC#19: DatatypeType;
  var env#20: BoxType;
  var expr#21: DatatypeType;
  var stC#22: DatatypeType;
  var env#23: BoxType;
  var result#24: DatatypeType;
  var expr#25: DatatypeType;
  var stC#26: DatatypeType;
  var env#27: BoxType;
  var conj0'#28: DatatypeType;
  var stC'#29: DatatypeType;
  var expr#30: DatatypeType;
  var stC#31: DatatypeType;
  var env#32: BoxType;
  var result#33: DatatypeType;
  var expr#34: DatatypeType;
  var stC#35: DatatypeType;
  var env#36: BoxType;
  var disj0'#37: DatatypeType;
  var stC'#38: DatatypeType;
  var expr#39: DatatypeType;
  var stC#40: DatatypeType;
  var env#41: BoxType;
  var resultFun#42: DatatypeType;
  var expr#43: DatatypeType;
  var stC#44: DatatypeType;
  var env#45: BoxType;
  var fun'#46: DatatypeType;
  var stC'#47: DatatypeType;
  var resultArgs#48: DatatypeType;
  var expr#49: DatatypeType;
  var args#50: Seq BoxType;
  var stC#51: DatatypeType;
  var env#52: BoxType;
  var args'#54: Seq BoxType;
  var stsC'#55: Set BoxType;
  var stsC''#56: Set BoxType;
  var stsC#57: Set BoxType;
  var stCombinedC#58: DatatypeType;
  var stsC#59: Set BoxType;
  var prim#60: DatatypeType;
  var prim#61: DatatypeType;
  var args#62: Seq BoxType;
  var stC#63: DatatypeType;
  var cmd#64: DatatypeType;
  var deps#65: DatatypeType;
  var exts#66: DatatypeType;
  var stC#67: DatatypeType;
  var stC#68: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(484,10): initial state"} true;
    if (*)
    {
        assume DtAlloc(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2), $Heap) && DtType(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        expr#3 := expr#0;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assume _module.__default.Value#canCall($Heap, this, expr#0);
        if (_module.__default.Value($Heap, this, expr#0))
        {
            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(expr#0), $Box(stC#1));
            assume true;
        }
        else
        {
            if (_module.Expression.exprIdentifier_q(expr#0))
            {
                assert _module.Expression.exprIdentifier_q(expr#0);
                id#4 := _module.Expression.id(expr#0);
                env#5 := env#2;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2);
                assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(_module.__default.GetEnv($LS($LZ), $Heap, this, _module.Expression.id(expr#0), env#2)), $Box(stC#1));
                assume _module.__default.GetEnv#canCall($Heap, this, _module.Expression.id(expr#0), env#2);
            }
            else
            {
                if (_module.Expression.exprIf_q(expr#0))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue())
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    expr#6 := _module.Expression.ifTrue(expr#0);
                    stC#7 := stC#1;
                    env#8 := env#2;
                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                    assert DtRank(expr#6) < DtRank(expr#0);
                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), stC#1, env#2);
                    assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.ifTrue(expr#0), stC#1, env#2);
                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), stC#1, env#2);
                }
                else
                {
                    if (_module.Expression.exprIf_q(expr#0))
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                    }

                    if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                        assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                    }

                    if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse())
                    {
                        assert _module.Expression.exprIf_q(expr#0);
                        expr#9 := _module.Expression.ifFalse(expr#0);
                        stC#10 := stC#1;
                        env#11 := env#2;
                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                        assert DtRank(expr#9) < DtRank(expr#0);
                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), stC#1, env#2);
                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.ifFalse(expr#0), stC#1, env#2);
                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), stC#1, env#2);
                    }
                    else
                    {
                        if (_module.Expression.exprIf_q(expr#0))
                        {
                            assert _module.Expression.exprIf_q(expr#0);
                            expr#13 := _module.Expression.cond(expr#0);
                            stC#14 := stC#1;
                            env#15 := env#2;
                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                            assert DtRank(expr#13) < DtRank(expr#0);
                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                            assume result#12 == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                            assume _module.Tuple.Pair_q(result#12);
                            assume cond'#16 == $Unbox(_module.Tuple.fst(result#12)): DatatypeType;
                            assume true;
                            assume _module.Tuple.Pair_q(result#12);
                            assume stC'#17 == $Unbox(_module.Tuple.snd(result#12)): DatatypeType;
                            assume true;
                            if (_module.Expression.exprLiteral_q(cond'#16))
                            {
                                assert _module.Expression.exprLiteral_q(cond'#16);
                            }

                            if (_module.Expression.exprLiteral_q(cond'#16) && _module.Expression.lit(cond'#16) == #_module.Literal.litTrue())
                            {
                                assert _module.Expression.exprIf_q(expr#0);
                                expr#18 := _module.Expression.ifTrue(expr#0);
                                stC#19 := stC'#17;
                                env#20 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr#18) < DtRank(expr#0);
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), stC'#17, env#2);
                                assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.ifTrue(expr#0), stC'#17, env#2);
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifTrue(expr#0), stC'#17, env#2);
                            }
                            else
                            {
                                if (_module.Expression.exprLiteral_q(cond'#16))
                                {
                                    assert _module.Expression.exprLiteral_q(cond'#16);
                                }

                                if (_module.Expression.exprLiteral_q(cond'#16) && _module.Expression.lit(cond'#16) == #_module.Literal.litFalse())
                                {
                                    assert _module.Expression.exprIf_q(expr#0);
                                    expr#21 := _module.Expression.ifFalse(expr#0);
                                    stC#22 := stC'#17;
                                    env#23 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#21) < DtRank(expr#0);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), stC'#17, env#2);
                                    assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.ifFalse(expr#0), stC'#17, env#2);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.ifFalse(expr#0), stC'#17, env#2);
                                }
                                else
                                {
                                    assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                    assume true;
                                }
                            }
                        }
                        else
                        {
                            if (_module.Expression.exprAnd_q(expr#0))
                            {
                                assert _module.Expression.exprAnd_q(expr#0);
                                expr#25 := _module.Expression.conj0(expr#0);
                                stC#26 := stC#1;
                                env#27 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr#25) < DtRank(expr#0);
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                                assume result#24 == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                                assume _module.Tuple.Pair_q(result#24);
                                assume conj0'#28 == $Unbox(_module.Tuple.fst(result#24)): DatatypeType;
                                assume true;
                                assume _module.Tuple.Pair_q(result#24);
                                assume stC'#29 == $Unbox(_module.Tuple.snd(result#24)): DatatypeType;
                                assume true;
                                if (_module.Expression.exprLiteral_q(conj0'#28))
                                {
                                    assert _module.Expression.exprLiteral_q(conj0'#28);
                                }

                                if (_module.Expression.exprLiteral_q(conj0'#28) && _module.Expression.lit(conj0'#28) == #_module.Literal.litTrue())
                                {
                                    assert _module.Expression.exprAnd_q(expr#0);
                                    expr#30 := _module.Expression.conj1(expr#0);
                                    stC#31 := stC'#29;
                                    env#32 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#30) < DtRank(expr#0);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj1(expr#0), stC'#29, env#2);
                                    assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj1(expr#0), stC'#29, env#2);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj1(expr#0), stC'#29, env#2);
                                }
                                else
                                {
                                    if (_module.Expression.exprLiteral_q(conj0'#28))
                                    {
                                        assert _module.Expression.exprLiteral_q(conj0'#28);
                                    }

                                    if (_module.Expression.exprLiteral_q(conj0'#28) && _module.Expression.lit(conj0'#28) == #_module.Literal.litFalse())
                                    {
                                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litFalse())), $Box(stC'#29));
                                        assume true;
                                    }
                                    else
                                    {
                                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                        assume true;
                                    }
                                }
                            }
                            else
                            {
                                if (_module.Expression.exprOr_q(expr#0))
                                {
                                    assert _module.Expression.exprOr_q(expr#0);
                                    expr#34 := _module.Expression.disj0(expr#0);
                                    stC#35 := stC#1;
                                    env#36 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr#34) < DtRank(expr#0);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                    assume result#33 == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                    assume _module.Tuple.Pair_q(result#33);
                                    assume disj0'#37 == $Unbox(_module.Tuple.fst(result#33)): DatatypeType;
                                    assume true;
                                    assume _module.Tuple.Pair_q(result#33);
                                    assume stC'#38 == $Unbox(_module.Tuple.snd(result#33)): DatatypeType;
                                    assume true;
                                    if (_module.Expression.exprLiteral_q(disj0'#37))
                                    {
                                        assert _module.Expression.exprLiteral_q(disj0'#37);
                                    }

                                    if (_module.Expression.exprLiteral_q(disj0'#37) && _module.Expression.lit(disj0'#37) == #_module.Literal.litTrue())
                                    {
                                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprLiteral(#_module.Literal.litTrue())), $Box(stC'#38));
                                        assume true;
                                    }
                                    else
                                    {
                                        if (_module.Expression.exprLiteral_q(disj0'#37))
                                        {
                                            assert _module.Expression.exprLiteral_q(disj0'#37);
                                        }

                                        if (_module.Expression.exprLiteral_q(disj0'#37) && _module.Expression.lit(disj0'#37) == #_module.Literal.litFalse())
                                        {
                                            assert _module.Expression.exprOr_q(expr#0);
                                            expr#39 := _module.Expression.disj1(expr#0);
                                            stC#40 := stC'#38;
                                            env#41 := env#2;
                                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                            assert DtRank(expr#39) < DtRank(expr#0);
                                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj1(expr#0), stC'#38, env#2);
                                            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj1(expr#0), stC'#38, env#2);
                                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj1(expr#0), stC'#38, env#2);
                                        }
                                        else
                                        {
                                            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                            assume true;
                                        }
                                    }
                                }
                                else
                                {
                                    if (_module.Expression.exprInvocation_q(expr#0))
                                    {
                                        assert _module.Expression.exprInvocation_q(expr#0);
                                        expr#43 := _module.Expression.fun(expr#0);
                                        stC#44 := stC#1;
                                        env#45 := env#2;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr#43) < DtRank(expr#0);
                                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                        assume resultFun#42 == _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                        assume _module.Tuple.Pair_q(resultFun#42);
                                        assume fun'#46 == $Unbox(_module.Tuple.fst(resultFun#42)): DatatypeType;
                                        assume true;
                                        assume _module.Tuple.Pair_q(resultFun#42);
                                        assume stC'#47 == $Unbox(_module.Tuple.snd(resultFun#42)): DatatypeType;
                                        assume true;
                                        assert _module.Expression.exprInvocation_q(expr#0);
                                        expr#49 := expr#0;
                                        args#50 := _module.Expression.args(expr#0);
                                        stC#51 := stC#1;
                                        env#52 := env#2;
                                        assert (forall arg#53: DatatypeType :: DtAlloc(arg#53, $Heap) && DtType(arg#53) == class._module.Expression ==> Seq#Contains(args#50, $Box(arg#53)) ==> DtRank(arg#53) < DtRank(expr#49));
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr#49) <= DtRank(expr#0) && (DtRank(expr#49) == DtRank(expr#0) ==> true);
                                        assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                        assume resultArgs#48 == _module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                        assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                        assume _module.Tuple.Pair_q(resultArgs#48);
                                        assume args'#54 == $Unbox(_module.Tuple.fst(resultArgs#48)): Seq BoxType;
                                        assume true;
                                        assume _module.Tuple.Pair_q(resultArgs#48);
                                        assume stsC'#55 == $Unbox(_module.Tuple.snd(resultArgs#48)): Set BoxType;
                                        assume true;
                                        assume stsC''#56 == Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#47)), stsC'#55);
                                        assume true;
                                        stsC#57 := stsC''#56;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assume _module.__default.CompatibleC#canCall($Heap, this, stsC''#56);
                                        if (_module.__default.CompatibleC($Heap, this, stsC''#56))
                                        {
                                            stsC#59 := stsC''#56;
                                            assert !Set#Equal(stsC#59, Set#Empty(): Set BoxType);
                                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                            assume _module.__default.CombineC#canCall($Heap, this, stsC''#56);
                                            assume stCombinedC#58 == _module.__default.CombineC($LS($LZ), $Heap, this, stsC''#56);
                                            assume _module.__default.CombineC#canCall($Heap, this, stsC''#56);
                                            if (_module.Expression.exprLiteral_q(fun'#46))
                                            {
                                                assert _module.Expression.exprLiteral_q(fun'#46);
                                            }

                                            if (_module.Expression.exprLiteral_q(fun'#46) && _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#46)))
                                            {
                                                assert _module.Expression.exprLiteral_q(fun'#46);
                                                assert _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#46));
                                                if (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit(fun'#46))))
                                                {
                                                    prim#60 := #_module.Primitive.primExec();
                                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                    assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec());
                                                    if (Seq#Length(args'#54) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()))
                                                    {
                                                        prim#61 := #_module.Primitive.primExec();
                                                        args#62 := args'#54;
                                                        stC#63 := stCombinedC#58;
                                                        assert _module.Primitive.primExec_q(prim#61) ==> Seq#Length(args#62) == 3;
                                                        assert _module.Primitive.primCreatePath_q(prim#61) ==> Seq#Length(args#62) == 1;
                                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                        assume _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), args'#54, stCombinedC#58);
                                                    }

                                                    if (Seq#Length(args'#54) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), args'#54, stCombinedC#58))
                                                    {
                                                        assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#54);
                                                        assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#54);
                                                        assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#54);
                                                        cmd#64 := $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType;
                                                        deps#65 := $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType;
                                                        exts#66 := $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType;
                                                        stC#67 := stCombinedC#58;
                                                        assert _module.Expression.exprLiteral_q(cmd#64) && _module.Literal.litString_q(_module.Expression.lit(cmd#64)) && _module.Expression.exprLiteral_q(deps#65) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#65)) && _module.Expression.exprLiteral_q(exts#66) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#66));
                                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                        assume _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombinedC#58);
                                                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == _module.__default.execC($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombinedC#58);
                                                        assume _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index(args'#54, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#54, Lit(2))): DatatypeType, stCombinedC#58);
                                                    }
                                                    else
                                                    {
                                                        stC#68 := stCombinedC#58;
                                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                        assume _module.__default.ConsistentCache#canCall($Heap, this, stCombinedC#58);
                                                        if (_module.__default.ConsistentCache($Heap, this, stCombinedC#58))
                                                        {
                                                            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                                            assume true;
                                                        }
                                                        else
                                                        {
                                                            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rInconsistentCache())), $Box(stC#1));
                                                            assume true;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                                    assume true;
                                                }
                                            }
                                            else
                                            {
                                                assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                                assume true;
                                            }
                                        }
                                        else
                                        {
                                            assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rCompatibility())), $Box(stC#1));
                                            assume true;
                                        }
                                    }
                                    else
                                    {
                                        assume _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2) == #_module.Tuple.Pair($Box(#_module.Expression.exprError(#_module.Reason.rValidity())), $Box(stC#1));
                                        assume true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



// function declaration for _module._default.evalArgsC
function _module.__default.evalArgsC($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType) : DatatypeType;

function _module.__default.evalArgsC#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: { _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) } _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) == _module.__default.evalArgsC($ly, $Heap, this, expr#0, args#1, stC#2, env#3));

// frame axiom for _module.__default.evalArgsC
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: { $HeapSucc($h0, $h1), _module.__default.evalArgsC($ly, $h1, this, expr#0, args#1, stC#2, env#3) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.evalArgsC#canCall($h0, this, expr#0, args#1, stC#2, env#3) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && (forall $i#50: int :: { Seq#Index(args#1, $i#50) } 0 <= $i#50 && $i#50 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#50)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#50)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h0) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $h0))) && (_module.__default.evalArgsC#canCall($h1, this, expr#0, args#1, stC#2, env#3) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && (forall $i#51: int :: { Seq#Index(args#1, $i#51) } 0 <= $i#51 && $i#51 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#51)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#51)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h1) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $h1))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.evalArgsC($ly, $h0, this, expr#0, args#1, stC#2, env#3) == _module.__default.evalArgsC($ly, $h1, this, expr#0, args#1, stC#2, env#3));

// consequence axiom for _module.__default.evalArgsC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 38 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: { _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) } _module.__default.evalArgsC#canCall($Heap, this, expr#0, args#1, stC#2, env#3) || ((0 != $ModuleContextHeight || 38 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#52: int :: { Seq#Index(args#1, $i#52) } 0 <= $i#52 && $i#52 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#52)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#52)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall arg#4: DatatypeType :: DtAlloc(arg#4, $Heap) && DtType(arg#4) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#4)) ==> DtRank(arg#4) < DtRank(expr#0))) ==> DtAlloc(_module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3), $Heap) && DtType(_module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3)) == class._module.Tuple);

// definition axiom for _module.__default.evalArgsC (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: { _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) } _module.__default.evalArgsC#canCall($Heap, this, expr#0, args#1, stC#2, env#3) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#53: int :: { Seq#Index(args#1, $i#53) } 0 <= $i#53 && $i#53 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#53)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#53)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0))) ==> _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) == _module.__default.evalArgsC_k($ly, $Heap, this, expr#0, args#1, stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgsC for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3) } _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#6: DatatypeType :: DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#6)) ==> DtRank(arg#6) < DtRank(expr#0))) ==> _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3) == _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgsC for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3)) } _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3)) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0))) ==> _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType) && _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3)) == _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType));

// definition axiom for _module.__default.evalArgsC (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: { _module.__default.evalArgsC($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3) } _module.__default.evalArgsC#canCall($Heap, this, expr#0, args#1, stC#2, env#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#54: int :: { Seq#Index(args#1, $i#54) } 0 <= $i#54 && $i#54 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#54)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#54)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall arg#8: DatatypeType :: DtAlloc(arg#8, $Heap) && DtType(arg#8) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#8)) ==> DtRank(arg#8) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgsC for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3) } _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#9: DatatypeType :: DtAlloc(arg#9, $Heap) && DtType(arg#9) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#9)) ==> DtRank(arg#9) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgsC for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType :: {:weight 10} { _module.__default.evalArgsC($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3)) } _module.__default.evalArgsC#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#10: DatatypeType :: DtAlloc(arg#10, $Heap) && DtType(arg#10) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#10)) ==> DtRank(arg#10) < DtRank(expr#0))) ==> true);

procedure CheckWellformed$$_module.__default.evalArgsC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, args#1: Seq BoxType where (forall $i#55: int :: { Seq#Index(args#1, $i#55) } 0 <= $i#55 && $i#55 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#55)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#55)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC, env#3: BoxType where GenericAlloc(env#3, $Heap));
  free requires 0 == $ModuleContextHeight && 38 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.evalArgsC(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType)
{
  var arg#11: DatatypeType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var expr#13: DatatypeType;
  var args#14: Seq BoxType;
  var stC#15: DatatypeType;
  var env#16: BoxType;
  var args'#17: Seq BoxType;
  var stsC'#18: Set BoxType;

    assume {:captureState "CachedBuilds0.dfy(560,10): initial state"} true;
    havoc arg#11;
    assume DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#11)))
    {
    }

    assume (forall arg#12: DatatypeType :: DtAlloc(arg#12, $Heap) && DtType(arg#12) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#12)) ==> DtRank(arg#12) < DtRank(expr#0));
    if (*)
    {
        assume DtAlloc(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3), $Heap) && DtType(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        expr#13 := expr#0;
        args#14 := args#1;
        stC#15 := stC#2;
        env#16 := env#3;
        args'#17 := Seq#Empty(): Seq BoxType;
        stsC'#18 := Set#Empty(): Set BoxType;
        assert (forall arg#19: DatatypeType :: DtAlloc(arg#19, $Heap) && DtType(arg#19) == class._module.Expression ==> Seq#Contains(args#14, $Box(arg#19)) ==> DtRank(arg#19) < DtRank(expr#13));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert 0 <= Seq#Length(args#1) + 1 || DtRank(expr#13) < DtRank(expr#0) || Seq#Length(args#14) == Seq#Length(args#1) + 1;
        assert DtRank(expr#13) < DtRank(expr#0) || (DtRank(expr#13) == DtRank(expr#0) && Seq#Length(args#14) < Seq#Length(args#1) + 1);
        assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
        assume _module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3) == _module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
        assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, Seq#Empty(): Seq BoxType, Set#Empty(): Set BoxType);
    }
}



// function declaration for _module._default.evalArgsC'
function _module.__default.evalArgsC_k($ly: LayerType, $heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType) : DatatypeType;

function _module.__default.evalArgsC_k#canCall($heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType) : bool;

// layer synonym axiom
axiom (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: { _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) == _module.__default.evalArgsC_k($ly, $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5));

// frame axiom for _module.__default.evalArgsC_k
axiom (forall $ly: LayerType, $h0: HeapType, $h1: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: { $HeapSucc($h0, $h1), _module.__default.evalArgsC_k($ly, $h1, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.evalArgsC_k#canCall($h0, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) || (DtAlloc(expr#0, $h0) && DtType(expr#0) == class._module.Expression && (forall $i#56: int :: { Seq#Index(args#1, $i#56) } 0 <= $i#56 && $i#56 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#56)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#56)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h0) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $h0) && (forall $i#58: int :: { Seq#Index(args'#4, $i#58) } 0 <= $i#58 && $i#58 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#58)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args'#4, $i#58)): DatatypeType) == class._module.Expression) && (forall $t#60: BoxType :: { stsC'#5[$t#60] } stsC'#5[$t#60] ==> DtAlloc($Unbox($t#60): DatatypeType, $h0) && DtType($Unbox($t#60): DatatypeType) == class._module.StateC))) && (_module.__default.evalArgsC_k#canCall($h1, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) || (DtAlloc(expr#0, $h1) && DtType(expr#0) == class._module.Expression && (forall $i#57: int :: { Seq#Index(args#1, $i#57) } 0 <= $i#57 && $i#57 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#57)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#57)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h1) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $h1) && (forall $i#59: int :: { Seq#Index(args'#4, $i#59) } 0 <= $i#59 && $i#59 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#59)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args'#4, $i#59)): DatatypeType) == class._module.Expression) && (forall $t#61: BoxType :: { stsC'#5[$t#61] } stsC'#5[$t#61] ==> DtAlloc($Unbox($t#61): DatatypeType, $h1) && DtType($Unbox($t#61): DatatypeType) == class._module.StateC))) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.evalArgsC_k($ly, $h0, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) == _module.__default.evalArgsC_k($ly, $h1, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5));

// consequence axiom for _module.__default.evalArgsC_k
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 38 <= $FunctionContextHeight) ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: { _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) || ((0 != $ModuleContextHeight || 38 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#62: int :: { Seq#Index(args#1, $i#62) } 0 <= $i#62 && $i#62 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#62)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#62)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall $i#63: int :: { Seq#Index(args'#4, $i#63) } 0 <= $i#63 && $i#63 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#63)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#63)): DatatypeType) == class._module.Expression) && (forall $t#64: BoxType :: { stsC'#5[$t#64] } stsC'#5[$t#64] ==> DtAlloc($Unbox($t#64): DatatypeType, $Heap) && DtType($Unbox($t#64): DatatypeType) == class._module.StateC) && (forall arg#6: DatatypeType :: DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#6)) ==> DtRank(arg#6) < DtRank(expr#0))) ==> DtAlloc(_module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5), $Heap) && DtType(_module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5)) == class._module.Tuple);

// definition axiom for _module.__default.evalArgsC_k (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: { _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#65: int :: { Seq#Index(args#1, $i#65) } 0 <= $i#65 && $i#65 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#65)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#65)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall $i#66: int :: { Seq#Index(args'#4, $i#66) } 0 <= $i#66 && $i#66 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#66)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#66)): DatatypeType) == class._module.Expression) && (forall $t#67: BoxType :: { stsC'#5[$t#67] } stsC'#5[$t#67] ==> DtAlloc($Unbox($t#67): DatatypeType, $Heap) && DtType($Unbox($t#67): DatatypeType) == class._module.StateC) && (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.evalC#canCall($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, stC#2, env#3) && _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))))) && _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(args'#4), $Box(stsC'#5)) else _module.__default.evalArgsC_k($ly, $Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))))));

// definition axiom for _module.__default.evalArgsC_k for decreasing-related literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, args'#4, stsC'#5) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#8: DatatypeType :: DtAlloc(arg#8, $Heap) && DtType(arg#8) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#8)) ==> DtRank(arg#8) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.evalC#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, stC#2, env#3) && _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))))) && _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, args'#4, stsC'#5) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(args'#4), $Box(stsC'#5)) else _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, stC#2, env#3))): DatatypeType))))));

// definition axiom for _module.__default.evalArgsC_k for all literals (intra-module)
axiom 0 == $ModuleContextHeight && 38 <= $FunctionContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Lit(args'#4), Lit(stsC'#5)) } _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Lit(args'#4), Lit(stsC'#5)) || (38 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#9: DatatypeType :: DtAlloc(arg#9, $Heap) && DtType(arg#9) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#9)) ==> DtRank(arg#9) < DtRank(expr#0))) ==> (Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> true) && (!Seq#Equal(args#1, Seq#Empty(): Seq BoxType) ==> _module.__default.evalC#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(stC#2), Lit(env#3)) && _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), Lit(stC#2), Lit(env#3), Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(stC#2), Lit(env#3)))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(stC#2), Lit(env#3)))): DatatypeType))))) && _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Lit(args'#4), Lit(stsC'#5)) == (if Seq#Equal(args#1, Seq#Empty(): Seq BoxType) then #_module.Tuple.Pair($Box(Lit(args'#4)), $Box(Lit(stsC'#5))) else _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Seq#Drop(Lit(args#1), Lit(1)), Lit(stC#2), Lit(env#3), Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box($Unbox(_module.Tuple.fst(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(stC#2), Lit(env#3)))): DatatypeType))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box($Unbox(_module.Tuple.snd(_module.__default.evalC($ly, $Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, Lit(stC#2), Lit(env#3)))): DatatypeType))))));

// definition axiom for _module.__default.evalArgsC_k (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: { _module.__default.evalArgsC_k($LS($ly), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && (forall $i#68: int :: { Seq#Index(args#1, $i#68) } 0 <= $i#68 && $i#68 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#68)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#68)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && GenericAlloc(env#3, $Heap) && (forall $i#69: int :: { Seq#Index(args'#4, $i#69) } 0 <= $i#69 && $i#69 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#69)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#69)): DatatypeType) == class._module.Expression) && (forall $t#70: BoxType :: { stsC'#5[$t#70] } stsC'#5[$t#70] ==> DtAlloc($Unbox($t#70): DatatypeType, $Heap) && DtType($Unbox($t#70): DatatypeType) == class._module.StateC) && (forall arg#10: DatatypeType :: DtAlloc(arg#10, $Heap) && DtType(arg#10) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#10)) ==> DtRank(arg#10) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgsC_k for decreasing-related literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, args'#4, stsC'#5) } _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), stC#2, env#3, args'#4, stsC'#5) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#11: DatatypeType :: DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#11)) ==> DtRank(arg#11) < DtRank(expr#0))) ==> true);

// definition axiom for _module.__default.evalArgsC_k for all literals (foreign modules)
axiom 0 < $ModuleContextHeight ==> (forall $ly: LayerType, $Heap: HeapType, this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType :: {:weight 10} { _module.__default.evalArgsC_k($ly, $Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Lit(args'#4), Lit(stsC'#5)) } _module.__default.evalArgsC_k#canCall($Heap, this, Lit(expr#0), Lit(args#1), Lit(stC#2), Lit(env#3), Lit(args'#4), Lit(stsC'#5)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall arg#12: DatatypeType :: DtAlloc(arg#12, $Heap) && DtType(arg#12) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#12)) ==> DtRank(arg#12) < DtRank(expr#0))) ==> true);

procedure CheckWellformed$$_module.__default.evalArgsC_k(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression, args#1: Seq BoxType where (forall $i#71: int :: { Seq#Index(args#1, $i#71) } 0 <= $i#71 && $i#71 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#71)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#71)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC, env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#72: int :: { Seq#Index(args'#4, $i#72) } 0 <= $i#72 && $i#72 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#72)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#72)): DatatypeType) == class._module.Expression), stsC'#5: Set BoxType where (forall $t#73: BoxType :: { stsC'#5[$t#73] } stsC'#5[$t#73] ==> DtAlloc($Unbox($t#73): DatatypeType, $Heap) && DtType($Unbox($t#73): DatatypeType) == class._module.StateC));
  free requires 0 == $ModuleContextHeight && 38 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.evalArgsC_k(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType)
{
  var arg#13: DatatypeType;
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#15: DatatypeType;
  var result#16: DatatypeType;
  var expr#17: DatatypeType;
  var stC#18: DatatypeType;
  var env#19: BoxType;
  var arg'#20: DatatypeType;
  var stC'#21: DatatypeType;
  var expr#22: DatatypeType;
  var args#23: Seq BoxType;
  var stC#24: DatatypeType;
  var env#25: BoxType;
  var args'#26: Seq BoxType;
  var stsC'#27: Set BoxType;

    assume {:captureState "CachedBuilds0.dfy(569,10): initial state"} true;
    havoc arg#13;
    assume DtAlloc(arg#13, $Heap) && DtType(arg#13) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#13)))
    {
    }

    assume (forall arg#14: DatatypeType :: DtAlloc(arg#14, $Heap) && DtType(arg#14) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#14)) ==> DtRank(arg#14) < DtRank(expr#0));
    if (*)
    {
        assume DtAlloc(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5), $Heap) && DtType(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5)) == class._module.Tuple;
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        if (Seq#Equal(args#1, Seq#Empty(): Seq BoxType))
        {
            assume _module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) == #_module.Tuple.Pair($Box(args'#4), $Box(stsC'#5));
            assume true;
        }
        else
        {
            assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
            assume arg#15 == $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
            assume true;
            expr#17 := arg#15;
            stC#18 := stC#2;
            env#19 := env#3;
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert DtRank(expr#17) < DtRank(expr#0);
            assume _module.__default.evalC#canCall($Heap, this, arg#15, stC#2, env#3);
            assume result#16 == _module.__default.evalC($LS($LZ), $Heap, this, arg#15, stC#2, env#3);
            assume _module.__default.evalC#canCall($Heap, this, arg#15, stC#2, env#3);
            assume _module.Tuple.Pair_q(result#16);
            assume arg'#20 == $Unbox(_module.Tuple.fst(result#16)): DatatypeType;
            assume true;
            assume _module.Tuple.Pair_q(result#16);
            assume stC'#21 == $Unbox(_module.Tuple.snd(result#16)): DatatypeType;
            assume true;
            assert 0 <= Lit(1) && Lit(1) <= Seq#Length(args#1);
            expr#22 := expr#0;
            args#23 := Seq#Drop(args#1, Lit(1));
            stC#24 := stC#2;
            env#25 := env#3;
            args'#26 := Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20)));
            stsC'#27 := Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#21)));
            assert (forall arg#28: DatatypeType :: DtAlloc(arg#28, $Heap) && DtType(arg#28) == class._module.Expression ==> Seq#Contains(args#23, $Box(arg#28)) ==> DtRank(arg#28) < DtRank(expr#22));
            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
            assert 0 <= Seq#Length(args#1) || DtRank(expr#22) < DtRank(expr#0) || Seq#Length(args#23) == Seq#Length(args#1);
            assert DtRank(expr#22) < DtRank(expr#0) || (DtRank(expr#22) == DtRank(expr#0) && Seq#Length(args#23) < Seq#Length(args#1));
            assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#21))));
            assume _module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5) == _module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#21))));
            assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, Seq#Drop(args#1, Lit(1)), stC#2, env#3, Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#20))), Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#21))));
        }
    }
}



// function declaration for _module._default.ValidArgsC
function _module.__default.ValidArgsC($heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType) : bool;

function _module.__default.ValidArgsC#canCall($heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType) : bool;

// frame axiom for _module.__default.ValidArgsC
axiom (forall $h0: HeapType, $h1: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType :: { $HeapSucc($h0, $h1), _module.__default.ValidArgsC($h1, this, prim#0, args#1, stC#2) } $IsGoodHeap($h0) && $IsGoodHeap($h1) && this != null && read($h0, this, alloc) && dtype(this) == class._module.__default && read($h1, this, alloc) && dtype(this) == class._module.__default && (_module.__default.ValidArgsC#canCall($h0, this, prim#0, args#1, stC#2) || (DtAlloc(prim#0, $h0) && DtType(prim#0) == class._module.Primitive && (forall $i#74: int :: { Seq#Index(args#1, $i#74) } 0 <= $i#74 && $i#74 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#74)): DatatypeType, $h0) && DtType($Unbox(Seq#Index(args#1, $i#74)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h0) && DtType(stC#2) == class._module.StateC)) && (_module.__default.ValidArgsC#canCall($h1, this, prim#0, args#1, stC#2) || (DtAlloc(prim#0, $h1) && DtType(prim#0) == class._module.Primitive && (forall $i#75: int :: { Seq#Index(args#1, $i#75) } 0 <= $i#75 && $i#75 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#75)): DatatypeType, $h1) && DtType($Unbox(Seq#Index(args#1, $i#75)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $h1) && DtType(stC#2) == class._module.StateC)) && $HeapSucc($h0, $h1) ==> (forall<alpha> $o: ref, $f: Field alpha :: false ==> read($h0, $o, $f) == read($h1, $o, $f)) ==> _module.__default.ValidArgsC($h0, this, prim#0, args#1, stC#2) == _module.__default.ValidArgsC($h1, this, prim#0, args#1, stC#2));

// consequence axiom for _module.__default.ValidArgsC
axiom 0 < $ModuleContextHeight || (0 == $ModuleContextHeight && 37 <= $FunctionContextHeight) ==> (forall $Heap: HeapType, this: ref, prim#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType :: { _module.__default.ValidArgsC($Heap, this, prim#0, args#1, stC#2) } _module.__default.ValidArgsC#canCall($Heap, this, prim#0, args#1, stC#2) || ((0 != $ModuleContextHeight || 37 != $FunctionContextHeight) && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive && (forall $i#76: int :: { Seq#Index(args#1, $i#76) } 0 <= $i#76 && $i#76 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#76)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#76)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && (_module.Primitive.primExec_q(prim#0) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(prim#0) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgsC (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 37 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), args#1, stC#2) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primCreatePath(), args#1, stC#2) || (37 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#77: int :: { Seq#Index(args#1, $i#77) } 0 <= $i#77 && $i#77 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#77)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#77)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 1)) ==> _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), args#1, stC#2) == Lit(false));

// definition axiom for _module.__default.ValidArgsC for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 37 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: {:weight 10} { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(stC#2)) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(stC#2)) || (37 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 1)) ==> _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(stC#2)) == Lit(false));

// definition axiom for _module.__default.ValidArgsC (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 37 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), args#1, stC#2) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), args#1, stC#2) || (37 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#78: int :: { Seq#Index(args#1, $i#78) } 0 <= $i#78 && $i#78 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#78)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#78)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 1)) ==> (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2))) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))) ==> _module.__default.PreC#canCall($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType, stC#2)) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), args#1, stC#2) == (_module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(args#1, Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))) && _module.__default.PreC($Heap, this, $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType, $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType, stC#2)));

// definition axiom for _module.__default.ValidArgsC for all literals (intra-module), specialized for 'prim'
axiom 0 == $ModuleContextHeight && 37 <= $FunctionContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: {:weight 10} { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(stC#2)) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(stC#2)) || (37 != $FunctionContextHeight && $IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 1)) ==> (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) ==> true) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(Lit(stC#2)))) && (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#2)))) ==> _module.__default.PreC#canCall($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType, Lit(stC#2))) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(stC#2)) == (_module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType) && _module.Literal.litString_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType) && _module.Literal.litArrOfPaths_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)) && _module.Expression.exprLiteral_q($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType) && _module.Literal.litArrOfStrings_q(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType)) && Set#Subset(_module.Literal.paths(_module.Expression.lit($Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType)), _module.__default.DomSt($Heap, this, _module.StateC.st(Lit(stC#2)))) && _module.__default.PreC($Heap, this, $Unbox(Seq#Index(Lit(args#1), Lit(0))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(1))): DatatypeType, $Unbox(Seq#Index(Lit(args#1), Lit(2))): DatatypeType, Lit(stC#2))));

// definition axiom for _module.__default.ValidArgsC (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), args#1, stC#2) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primCreatePath(), args#1, stC#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#79: int :: { Seq#Index(args#1, $i#79) } 0 <= $i#79 && $i#79 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#79)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#79)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgsC for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: {:weight 10} { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(stC#2)) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primCreatePath(), Lit(args#1), Lit(stC#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primCreatePath()) ==> Seq#Length(Lit(args#1)) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgsC (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), args#1, stC#2) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), args#1, stC#2) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (forall $i#80: int :: { Seq#Index(args#1, $i#80) } 0 <= $i#80 && $i#80 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#80)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#80)): DatatypeType) == class._module.Expression) && DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(args#1) == 1)) ==> true);

// definition axiom for _module.__default.ValidArgsC for all literals (foreign modules), specialized for 'prim'
axiom 0 < $ModuleContextHeight ==> (forall $Heap: HeapType, this: ref, args#1: Seq BoxType, stC#2: DatatypeType :: {:weight 10} { _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(stC#2)) } _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), Lit(args#1), Lit(stC#2)) || ($IsGoodHeap($Heap) && this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default && (_module.Primitive.primExec_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 3) && (_module.Primitive.primCreatePath_q(#_module.Primitive.primExec()) ==> Seq#Length(Lit(args#1)) == 1)) ==> true);

procedure CheckWellformed$$_module.__default.ValidArgsC(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prim#0: DatatypeType where DtAlloc(prim#0, $Heap) && DtType(prim#0) == class._module.Primitive, args#1: Seq BoxType where (forall $i#81: int :: { Seq#Index(args#1, $i#81) } 0 <= $i#81 && $i#81 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#81)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#81)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC);
  free requires 0 == $ModuleContextHeight && 37 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.ValidArgsC(this: ref, prim#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var cmd#3: DatatypeType;
  var deps#4: DatatypeType;
  var exts#5: DatatypeType;
  var st#6: BoxType;
  var cmd#7: DatatypeType;
  var deps#8: DatatypeType;
  var exts#9: DatatypeType;
  var stC#10: DatatypeType;

    assume {:captureState "CachedBuilds0.dfy(584,11): initial state"} true;
    if (_module.Primitive.primExec_q(prim#0))
    {
    }

    assume _module.Primitive.primExec_q(prim#0) ==> Seq#Length(args#1) == 3;
    if (_module.Primitive.primCreatePath_q(prim#0))
    {
    }

    assume _module.Primitive.primCreatePath_q(prim#0) ==> Seq#Length(args#1) == 1;
    if (*)
    {
        assume false;
    }
    else
    {
        $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
        if (prim#0 == #_module.Primitive.primCreatePath())
        {
            assume _module.__default.ValidArgsC($Heap, this, prim#0, args#1, stC#2) == Lit(false);
            assume true;
        }
        else if (prim#0 == #_module.Primitive.primExec())
        {
            assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
            assume cmd#3 == $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
            assume true;
            assert 0 <= Lit(1) && Lit(1) < Seq#Length(args#1);
            assume deps#4 == $Unbox(Seq#Index(args#1, Lit(1))): DatatypeType;
            assume true;
            assert 0 <= Lit(2) && Lit(2) < Seq#Length(args#1);
            assume exts#5 == $Unbox(Seq#Index(args#1, Lit(2))): DatatypeType;
            assume true;
            if (_module.Expression.exprLiteral_q(cmd#3))
            {
                assert _module.Expression.exprLiteral_q(cmd#3);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)))
            {
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4))
            {
                assert _module.Expression.exprLiteral_q(deps#4);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)))
            {
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5))
            {
                assert _module.Expression.exprLiteral_q(exts#5);
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)))
            {
                assert _module.Expression.exprLiteral_q(deps#4);
                assert _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4));
                assume _module.StateC.S_q(stC#2);
                st#6 := _module.StateC.st(stC#2);
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
            }

            if (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))))
            {
                cmd#7 := cmd#3;
                deps#8 := deps#4;
                exts#9 := exts#5;
                stC#10 := stC#2;
                assert _module.Expression.exprLiteral_q(cmd#7) && _module.Literal.litString_q(_module.Expression.lit(cmd#7)) && _module.Expression.exprLiteral_q(deps#8) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#8)) && _module.Expression.exprLiteral_q(exts#9) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#9)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#8)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#10)));
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assume _module.__default.PreC#canCall($Heap, this, cmd#3, deps#4, exts#5, stC#2);
            }

            assume _module.__default.ValidArgsC($Heap, this, prim#0, args#1, stC#2) == (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))) && _module.__default.PreC($Heap, this, cmd#3, deps#4, exts#5, stC#2));
            assume (_module.Expression.exprLiteral_q(cmd#3) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) ==> true) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2))) && (_module.Expression.exprLiteral_q(cmd#3) && _module.Literal.litString_q(_module.Expression.lit(cmd#3)) && _module.Expression.exprLiteral_q(deps#4) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#4)) && _module.Expression.exprLiteral_q(exts#5) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#5)) && Set#Subset(_module.Literal.paths(_module.Expression.lit(deps#4)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))) ==> _module.__default.PreC#canCall($Heap, this, cmd#3, deps#4, exts#5, stC#2));
        }
        else
        {
            assume false;
        }
    }
}



procedure CheckWellformed$$_module.__default.CachedBuildsTheorem(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2));
  free requires 0 == $ModuleContextHeight && 47 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.CachedBuildsTheorem(this: ref, prog#0: DatatypeType, st#1: BoxType, stC#2: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#3: Seq BoxType;
  var st#4: BoxType;
  var st#5: BoxType;
  var st#6: BoxType;
  var paths#7: Set BoxType;
  var st#8: BoxType;
  var result#9: DatatypeType;
  var prog#10: DatatypeType;
  var st#11: BoxType;
  var st'#12: BoxType;
  var resultC#13: DatatypeType;
  var prog#14: DatatypeType;
  var stC#15: DatatypeType;
  var stC'#16: DatatypeType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var p#19: DatatypeType;
  var st#20: BoxType;
  var p#21: DatatypeType;
  var st#22: BoxType;
  var st#23: BoxType;
  var st#24: BoxType;
  var st#26: BoxType;
  var paths#27: Set BoxType;
  var st#28: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(600,14): initial state"} true;
    assume _module.Program.Program_q(prog#0);
    stmts#3 := _module.Program.stmts(prog#0);
    assume _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0));
    assume _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
    st#4 := st#1;
    assume _module.__default.DomSt#canCall($Heap, this, st#1);
    assume _module.StateC.S_q(stC#2);
    st#5 := _module.StateC.st(stC#2);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))))
    {
        st#6 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        assume _module.StateC.S_q(stC#2);
        paths#7 := _module.__default.DomSt($Heap, this, st#1);
        st#8 := _module.StateC.st(stC#2);
        assert Set#Subset(paths#7, _module.__default.DomSt($Heap, this, st#8));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, st#1), _module.StateC.st(stC#2));
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))) && st#1 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st#1), _module.StateC.st(stC#2));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(604,5): post-state"} true;
    prog#10 := prog#0;
    st#11 := st#1;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#10));
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    assume result#9 == _module.__default.build($Heap, this, prog#0, st#1);
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    assume _module.Tuple.Pair_q(result#9);
    assume st'#12 == _module.Tuple.snd(result#9);
    assume true;
    prog#14 := prog#0;
    stC#15 := stC#2;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#14));
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#2);
    assume resultC#13 == _module.__default.buildC($Heap, this, prog#0, stC#2);
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#2);
    assume _module.Tuple.Pair_q(resultC#13);
    assume stC'#16 == $Unbox(_module.Tuple.snd(resultC#13)): DatatypeType;
    assume true;
    havoc p#17;
    assume DtAlloc(p#17, $Heap) && DtType(p#17) == class._module.Path;
    st#18 := st'#12;
    assume _module.__default.DomSt#canCall($Heap, this, st'#12);
    if (_module.__default.DomSt($Heap, this, st'#12)[$Box(p#17)])
    {
        p#19 := p#17;
        st#20 := st'#12;
        assume _module.__default.GetSt#canCall($Heap, this, p#17, st'#12);
        assume _module.StateC.S_q(stC'#16);
        p#21 := p#17;
        st#22 := _module.StateC.st(stC'#16);
        assume _module.__default.GetSt#canCall($Heap, this, p#17, _module.StateC.st(stC'#16));
    }

    if ((forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st'#12)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st'#12) == _module.__default.GetSt($Heap, this, p#25, _module.StateC.st(stC'#16))))
    {
        st#23 := st'#12;
        assume _module.__default.DomSt#canCall($Heap, this, st'#12);
        assume _module.StateC.S_q(stC'#16);
        st#24 := _module.StateC.st(stC'#16);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#16));
    }

    if ((forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st'#12)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st'#12) == _module.__default.GetSt($Heap, this, p#25, _module.StateC.st(stC'#16))) && Set#Subset(_module.__default.DomSt($Heap, this, st'#12), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#16))))
    {
        st#26 := st'#12;
        assume _module.__default.DomSt#canCall($Heap, this, st'#12);
        assume _module.StateC.S_q(stC'#16);
        paths#27 := _module.__default.DomSt($Heap, this, st'#12);
        st#28 := _module.StateC.st(stC'#16);
        assert Set#Subset(paths#27, _module.__default.DomSt($Heap, this, st#28));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, st'#12), _module.StateC.st(stC'#16));
    }

    assume (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#29)] ==> _module.__default.GetSt($Heap, this, p#29, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#29, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType))) && Set#Subset(_module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType))) && _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType));
}



procedure InterModuleCall$$_module.__default.CachedBuildsTheorem(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2));
  // user-defined preconditions
  requires _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
  requires Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)));
  requires st#1 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st#1), _module.StateC.st(stC#2));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall p#30: DatatypeType :: DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#30)] ==> _module.__default.GetSt($Heap, this, p#30, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#30, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.CachedBuildsTheorem(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2));
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)));
  requires st#1 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st#1), _module.StateC.st(stC#2));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall p#31: DatatypeType :: DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#31)] ==> _module.__default.GetSt($Heap, this, p#31, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#31, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.CachedBuildsTheorem(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 47 == $FunctionContextHeight;
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)));
  requires st#1 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st#1), _module.StateC.st(stC#2));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall p#32: DatatypeType :: DtAlloc(p#32, $Heap) && DtType(p#32) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#32)] ==> _module.__default.GetSt($Heap, this, p#32, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#32, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType)));
  ensures _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))), _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#2))): DatatypeType));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.CachedBuildsTheorem(this: ref, prog#0: DatatypeType, st#1: BoxType, stC#2: DatatypeType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var prog##33: DatatypeType;
  var st##34: BoxType;
  var result#35: DatatypeType where DtAlloc(result#35, $Heap) && DtType(result#35) == class._module.Tuple;
  var prog#36: DatatypeType;
  var st#37: BoxType;
  var st'#38: BoxType where GenericAlloc(st'#38, $Heap);
  var prog##39: DatatypeType;
  var stC##40: DatatypeType;
  var resultC#41: DatatypeType where DtAlloc(resultC#41, $Heap) && DtType(resultC#41) == class._module.Tuple;
  var prog#42: DatatypeType;
  var stC#43: DatatypeType;
  var stC'#44: DatatypeType where DtAlloc(stC'#44, $Heap) && DtType(stC'#44) == class._module.StateC;
  var p#45: DatatypeType;
  var st#46: BoxType;
  var p#47: DatatypeType;
  var st#48: BoxType;
  var p#49: DatatypeType;
  var st#50: BoxType;
  var st#52: BoxType;
  var st#53: BoxType;
  var st#54: BoxType;
  var paths#55: Set BoxType;
  var st#56: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(600,14): initial state"} true;
    $_reverifyPost := false;
    // ----- call statement ----- CachedBuilds0.dfy(611,3)
    assume true;
    prog##33 := prog#0;
    assume true;
    st##34 := st#1;
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    call IntraModuleCall$$_module.__default.BuildLemma(this, prog##33, st##34);
    assume {:captureState "CachedBuilds0.dfy(611,3)"} true;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(612,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(612,14)
    assume true;
    prog#36 := prog#0;
    st#37 := st#1;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#36));
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    result#35 := _module.__default.build($Heap, this, prog#0, st#1);
    assume {:captureState "CachedBuilds0.dfy(612,14)"} true;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(613,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(613,11)
    assume true;
    assume _module.Tuple.Pair_q(result#35);
    assume true;
    st'#38 := _module.Tuple.snd(result#35);
    assume {:captureState "CachedBuilds0.dfy(613,11)"} true;
    // ----- call statement ----- CachedBuilds0.dfy(614,3)
    assume true;
    prog##39 := prog#0;
    assume true;
    stC##40 := stC#2;
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    call IntraModuleCall$$_module.__default.BuildCLemma(this, prog##39, stC##40);
    assume {:captureState "CachedBuilds0.dfy(614,3)"} true;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(615,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(615,15)
    assume true;
    prog#42 := prog#0;
    stC#43 := stC#2;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#42));
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#2);
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#2);
    resultC#41 := _module.__default.buildC($Heap, this, prog#0, stC#2);
    assume {:captureState "CachedBuilds0.dfy(615,15)"} true;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(616,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(616,12)
    assume true;
    assume _module.Tuple.Pair_q(resultC#41);
    assume true;
    stC'#44 := $Unbox(_module.Tuple.snd(resultC#41)): DatatypeType;
    assume {:captureState "CachedBuilds0.dfy(616,12)"} true;
    // ----- assert statement ----- CachedBuilds0.dfy(618,3)
    havoc p#45;
    assume DtAlloc(p#45, $Heap) && DtType(p#45) == class._module.Path;
    st#46 := st'#38;
    assume _module.__default.DomSt#canCall($Heap, this, st'#38);
    if (_module.__default.DomSt($Heap, this, st'#38)[$Box(p#45)])
    {
        p#47 := p#45;
        st#48 := st'#38;
        assume _module.__default.GetSt#canCall($Heap, this, p#45, st'#38);
        assume _module.StateC.S_q(stC'#44);
        p#49 := p#45;
        st#50 := _module.StateC.st(stC'#44);
        assume _module.__default.GetSt#canCall($Heap, this, p#45, _module.StateC.st(stC'#44));
    }

    assume (forall p#51: DatatypeType :: DtAlloc(p#51, $Heap) && DtType(p#51) == class._module.Path ==> _module.__default.DomSt#canCall($Heap, this, st'#38) && (_module.__default.DomSt($Heap, this, st'#38)[$Box(p#51)] ==> _module.__default.GetSt#canCall($Heap, this, p#51, st'#38) && _module.__default.GetSt#canCall($Heap, this, p#51, _module.StateC.st(stC'#44))));
    assert (forall p#51: DatatypeType :: DtAlloc(p#51, $Heap) && DtType(p#51) == class._module.Path ==> _module.__default.DomSt($Heap, this, st'#38)[$Box(p#51)] ==> _module.__default.GetSt($Heap, this, p#51, st'#38) == _module.__default.GetSt($Heap, this, p#51, _module.StateC.st(stC'#44)));
    // ----- assert statement ----- CachedBuilds0.dfy(619,3)
    st#52 := st'#38;
    assume _module.__default.DomSt#canCall($Heap, this, st'#38);
    assume _module.StateC.S_q(stC'#44);
    st#53 := _module.StateC.st(stC'#44);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#44));
    if (Set#Subset(_module.__default.DomSt($Heap, this, st'#38), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#44))))
    {
        st#54 := st'#38;
        assume _module.__default.DomSt#canCall($Heap, this, st'#38);
        assume _module.StateC.S_q(stC'#44);
        paths#55 := _module.__default.DomSt($Heap, this, st'#38);
        st#56 := _module.StateC.st(stC'#44);
        assert {:subsumption 0} Set#Subset(paths#55, _module.__default.DomSt($Heap, this, st#56));
        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, st'#38), _module.StateC.st(stC'#44));
    }

    assume _module.__default.DomSt#canCall($Heap, this, st'#38) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#44)) && (Set#Subset(_module.__default.DomSt($Heap, this, st'#38), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#44))) ==> _module.__default.DomSt#canCall($Heap, this, st'#38) && _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, st'#38), _module.StateC.st(stC'#44)));
    assert {:subsumption 0} Set#Subset(_module.__default.DomSt($Heap, this, st'#38), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#44)));
    assert {:subsumption 0} st'#38 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, st'#38), _module.StateC.st(stC'#44));
    assume Set#Subset(_module.__default.DomSt($Heap, this, st'#38), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#44))) && st'#38 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, st'#38), _module.StateC.st(stC'#44));
}



procedure CheckWellformed$$_module.__default.BuildLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap));
  free requires 0 == $ModuleContextHeight && 43 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.BuildLemma(this: ref, prog#0: DatatypeType, st#1: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#2: Seq BoxType;
  var result#3: DatatypeType;
  var prog#4: DatatypeType;
  var st#5: BoxType;
  var st'#6: BoxType;
  var st#7: BoxType;
  var st#8: BoxType;
  var p#9: DatatypeType;
  var st#10: BoxType;
  var st#11: BoxType;
  var p#12: DatatypeType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var st#18: BoxType;
  var p#19: DatatypeType;
  var st#20: BoxType;
  var p#21: DatatypeType;
  var st#22: BoxType;
  var p#24: DatatypeType;
  var st#25: BoxType;
  var st#26: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(622,14): initial state"} true;
    assume _module.Program.Program_q(prog#0);
    stmts#2 := _module.Program.stmts(prog#0);
    assume _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0));
    assume _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(625,5): post-state"} true;
    prog#4 := prog#0;
    st#5 := st#1;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#4));
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    assume result#3 == _module.__default.build($Heap, this, prog#0, st#1);
    assume _module.__default.build#canCall($Heap, this, prog#0, st#1);
    assume _module.Tuple.Pair_q(result#3);
    assume st'#6 == _module.Tuple.snd(result#3);
    assume true;
    st#7 := st#1;
    assume _module.__default.DomSt#canCall($Heap, this, st#1);
    st#8 := st'#6;
    assume _module.__default.DomSt#canCall($Heap, this, st'#6);
    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#6)))
    {
        havoc p#9;
        assume DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path;
        st#10 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#9)])
        {
            st#11 := st'#6;
            assume _module.__default.DomSt#canCall($Heap, this, st'#6);
        }

        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#9)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#9)])
        {
            p#12 := p#9;
            st#13 := st#1;
            assume _module.__default.GetSt#canCall($Heap, this, p#9, st#1);
            p#14 := p#9;
            st#15 := st'#6;
            assume _module.__default.GetSt#canCall($Heap, this, p#9, st'#6);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#6)) && (forall p#23: DatatypeType :: DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#23)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#23)] ==> _module.__default.GetSt($Heap, this, p#23, st#1) == _module.__default.GetSt($Heap, this, p#23, st'#6)))
    {
        havoc p#16;
        assume DtAlloc(p#16, $Heap) && DtType(p#16) == class._module.Path;
        st#17 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#16)])
        {
            st#18 := st'#6;
            assume _module.__default.DomSt#canCall($Heap, this, st'#6);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#16)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#16)])
        {
            p#19 := p#16;
            st#20 := st'#6;
            assume _module.__default.Res_k#canCall($Heap, this, p#16, st'#6);
            p#21 := p#16;
            st#22 := st'#6;
            assume _module.__default.GetSt#canCall($Heap, this, p#16, st'#6);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#6)) && (forall p#23: DatatypeType :: DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#23)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#23)] ==> _module.__default.GetSt($Heap, this, p#23, st#1) == _module.__default.GetSt($Heap, this, p#23, st'#6)) && (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#27)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#27)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#27, st'#6) == _module.__default.GetSt($Heap, this, p#27, st'#6)))
    {
        havoc p#24;
        assume DtAlloc(p#24, $Heap) && DtType(p#24) == class._module.Path;
        st#25 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#24)])
        {
            st#26 := st'#6;
            assume _module.__default.DomSt#canCall($Heap, this, st'#6);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#24)] && _module.__default.DomSt($Heap, this, st'#6)[$Box(p#24)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && (forall p#28: DatatypeType :: DtAlloc(p#28, $Heap) && DtType(p#28) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#28)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#28)] ==> _module.__default.GetSt($Heap, this, p#28, st#1) == _module.__default.GetSt($Heap, this, p#28, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#29)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#29)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#29, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#29, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && (forall p#30: DatatypeType :: DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#30)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#30)] ==> _module.Path.OpaquePath_q(p#30));
}



procedure InterModuleCall$$_module.__default.BuildLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap));
  // user-defined preconditions
  requires _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#31: DatatypeType :: DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#31)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#31)] ==> _module.__default.GetSt($Heap, this, p#31, st#1) == _module.__default.GetSt($Heap, this, p#31, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path && (forall p$ih#0#32: DatatypeType :: DtAlloc(p$ih#0#32, $Heap) && DtType(p$ih#0#32) == class._module.Path ==> DtRank(p$ih#0#32) < DtRank(p#33) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#0#32)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#0#32)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#0#32, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#0#32, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#1: int :: #_module.Path.OpaquePath(a0#1) == p#33) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#33)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path && (forall p$ih#0#32: DatatypeType :: DtAlloc(p$ih#0#32, $Heap) && DtType(p$ih#0#32) == class._module.Path ==> DtRank(p$ih#0#32) < DtRank(p#33) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#0#32)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#0#32)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#0#32, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#0#32, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#2: int :: #_module.Path.TransparentPath(a0#2) == p#33) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#33)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  free ensures (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#33)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#33, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#34: DatatypeType :: DtAlloc(p#34, $Heap) && DtType(p#34) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#34)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#34)] ==> _module.Path.OpaquePath_q(p#34));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.BuildLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap));
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#35)] ==> _module.__default.GetSt($Heap, this, p#35, st#1) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path && (forall p$ih#3#36: DatatypeType :: DtAlloc(p$ih#3#36, $Heap) && DtType(p$ih#3#36) == class._module.Path ==> DtRank(p$ih#3#36) < DtRank(p#37) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#3#36)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#3#36)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#36, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#3#36, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#4: int :: #_module.Path.OpaquePath(a0#4) == p#37) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#37)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path && (forall p$ih#3#36: DatatypeType :: DtAlloc(p$ih#3#36, $Heap) && DtType(p$ih#3#36) == class._module.Path ==> DtRank(p$ih#3#36) < DtRank(p#37) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#3#36)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#3#36)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#36, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#3#36, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#5: int :: #_module.Path.TransparentPath(a0#5) == p#37) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#37)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  free ensures (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#37)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#37, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#38: DatatypeType :: DtAlloc(p#38, $Heap) && DtType(p#38) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#38)] ==> _module.Path.OpaquePath_q(p#38));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.BuildLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), st#1: BoxType where GenericAlloc(st#1, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 43 == $FunctionContextHeight;
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#39)] ==> _module.__default.GetSt($Heap, this, p#39, st#1) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#41: DatatypeType :: DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path && (forall p$ih#6#40: DatatypeType :: DtAlloc(p$ih#6#40, $Heap) && DtType(p$ih#6#40) == class._module.Path ==> DtRank(p$ih#6#40) < DtRank(p#41) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#6#40)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#6#40)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#40, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#6#40, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#7: int :: #_module.Path.OpaquePath(a0#7) == p#41) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#41)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#41: DatatypeType :: DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path && (forall p$ih#6#40: DatatypeType :: DtAlloc(p$ih#6#40, $Heap) && DtType(p$ih#6#40) == class._module.Path ==> DtRank(p$ih#6#40) < DtRank(p#41) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#6#40)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p$ih#6#40)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#40, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p$ih#6#40, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))) && true && (exists a0#8: int :: #_module.Path.TransparentPath(a0#8) == p#41) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#41)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  free ensures (forall p#41: DatatypeType :: DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#41)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))) == _module.__default.GetSt($Heap, this, p#41, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1))));
  ensures (forall p#42: DatatypeType :: DtAlloc(p#42, $Heap) && DtType(p#42) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#42)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.build($Heap, this, prog#0, st#1)))[$Box(p#42)] ==> _module.Path.OpaquePath_q(p#42));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.BuildLemma(this: ref, prog#0: DatatypeType, st#1: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts##43: Seq BoxType;
  var st##44: BoxType;
  var env##45: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(622,14): initial state"} true;
    $_reverifyPost := false;
    // ----- call statement ----- CachedBuilds0.dfy(632,3)
    assume _module.Program.Program_q(prog#0);
    assume true;
    stmts##43 := _module.Program.stmts(prog#0);
    assume true;
    st##44 := st#1;
    assume _module.__default.EmptyEnv#canCall($Heap, this);
    assume _module.__default.EmptyEnv#canCall($Heap, this);
    env##45 := _module.__default.EmptyEnv($Heap, this);
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    call IntraModuleCall$$_module.__default.DoLemma(this, stmts##43, st##44, env##45);
    assume {:captureState "CachedBuilds0.dfy(632,3)"} true;
}



procedure CheckWellformed$$_module.__default.DoLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#0: int :: { Seq#Index(stmts#0, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType) == class._module.Statement), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 42 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.DoLemma(this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#3: Seq BoxType;
  var result#4: DatatypeType;
  var stmts#5: Seq BoxType;
  var st#6: BoxType;
  var env#7: BoxType;
  var st'#8: BoxType;
  var st#9: BoxType;
  var st#10: BoxType;
  var p#11: DatatypeType;
  var st#12: BoxType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var st#20: BoxType;
  var p#21: DatatypeType;
  var st#22: BoxType;
  var p#23: DatatypeType;
  var st#24: BoxType;
  var p#26: DatatypeType;
  var st#27: BoxType;
  var st#28: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(635,14): initial state"} true;
    stmts#3 := stmts#0;
    assume _module.__default.Legal#canCall($Heap, this, stmts#0);
    assume _module.__default.Legal($Heap, this, stmts#0);
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(638,5): post-state"} true;
    stmts#5 := stmts#0;
    st#6 := st#1;
    env#7 := env#2;
    assert _module.__default.Legal($Heap, this, stmts#5);
    assume _module.__default.do#canCall($Heap, this, stmts#0, st#1, env#2);
    assume result#4 == _module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2);
    assume _module.__default.do#canCall($Heap, this, stmts#0, st#1, env#2);
    assume _module.Tuple.Pair_q(result#4);
    assume st'#8 == _module.Tuple.snd(result#4);
    assume true;
    st#9 := st#1;
    assume _module.__default.DomSt#canCall($Heap, this, st#1);
    st#10 := st'#8;
    assume _module.__default.DomSt#canCall($Heap, this, st'#8);
    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)))
    {
        havoc p#11;
        assume DtAlloc(p#11, $Heap) && DtType(p#11) == class._module.Path;
        st#12 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#11)])
        {
            st#13 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#11)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#11)])
        {
            p#14 := p#11;
            st#15 := st#1;
            assume _module.__default.GetSt#canCall($Heap, this, p#11, st#1);
            p#16 := p#11;
            st#17 := st'#8;
            assume _module.__default.GetSt#canCall($Heap, this, p#11, st'#8);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)) && (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#25)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st#1) == _module.__default.GetSt($Heap, this, p#25, st'#8)))
    {
        havoc p#18;
        assume DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path;
        st#19 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#18)])
        {
            st#20 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#18)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#18)])
        {
            p#21 := p#18;
            st#22 := st'#8;
            assume _module.__default.Res_k#canCall($Heap, this, p#18, st'#8);
            p#23 := p#18;
            st#24 := st'#8;
            assume _module.__default.GetSt#canCall($Heap, this, p#18, st'#8);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)) && (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#25)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st#1) == _module.__default.GetSt($Heap, this, p#25, st'#8)) && (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#29)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#29)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#29, st'#8) == _module.__default.GetSt($Heap, this, p#29, st'#8)))
    {
        havoc p#26;
        assume DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path;
        st#27 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#26)])
        {
            st#28 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#26)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#26)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && (forall p#30: DatatypeType :: DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#30)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#30)] ==> _module.__default.GetSt($Heap, this, p#30, st#1) == _module.__default.GetSt($Heap, this, p#30, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && (forall p#31: DatatypeType :: DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#31)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#31, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && (forall p#32: DatatypeType :: DtAlloc(p#32, $Heap) && DtType(p#32) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#32)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#32)] ==> _module.Path.OpaquePath_q(p#32));
}



procedure InterModuleCall$$_module.__default.DoLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#0: int :: { Seq#Index(stmts#0, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType) == class._module.Statement), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  // user-defined preconditions
  requires _module.__default.Legal($Heap, this, stmts#0);
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#33)] ==> _module.__default.GetSt($Heap, this, p#33, st#1) == _module.__default.GetSt($Heap, this, p#33, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path && (forall p$ih#1#34: DatatypeType :: DtAlloc(p$ih#1#34, $Heap) && DtType(p$ih#1#34) == class._module.Path ==> DtRank(p$ih#1#34) < DtRank(p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#1#34)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#1#34)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#1#34, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#1#34, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#2: int :: #_module.Path.OpaquePath(a0#2) == p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path && (forall p$ih#1#34: DatatypeType :: DtAlloc(p$ih#1#34, $Heap) && DtType(p$ih#1#34) == class._module.Path ==> DtRank(p$ih#1#34) < DtRank(p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#1#34)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#1#34)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#1#34, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#1#34, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#3: int :: #_module.Path.TransparentPath(a0#3) == p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  free ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#36: DatatypeType :: DtAlloc(p#36, $Heap) && DtType(p#36) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#36)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#36)] ==> _module.Path.OpaquePath_q(p#36));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.DoLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#4: int :: { Seq#Index(stmts#0, $i#4) } 0 <= $i#4 && $i#4 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#4)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#4)): DatatypeType) == class._module.Statement), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, stmts#0) && _module.__default.Legal($Heap, this, stmts#0) && Seq#Length(stmts#0) != 0;
  requires _module.__default.Legal#canCall($Heap, this, stmts#0) ==> _module.__default.Legal($Heap, this, stmts#0) || Seq#Length(stmts#0) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#37)] ==> _module.__default.GetSt($Heap, this, p#37, st#1) == _module.__default.GetSt($Heap, this, p#37, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path && (forall p$ih#5#38: DatatypeType :: DtAlloc(p$ih#5#38, $Heap) && DtType(p$ih#5#38) == class._module.Path ==> DtRank(p$ih#5#38) < DtRank(p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#5#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#5#38)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#5#38, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#5#38, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#6: int :: #_module.Path.OpaquePath(a0#6) == p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path && (forall p$ih#5#38: DatatypeType :: DtAlloc(p$ih#5#38, $Heap) && DtType(p$ih#5#38) == class._module.Path ==> DtRank(p$ih#5#38) < DtRank(p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#5#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#5#38)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#5#38, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#5#38, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#7: int :: #_module.Path.TransparentPath(a0#7) == p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  free ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#40: DatatypeType :: DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#40)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#40)] ==> _module.Path.OpaquePath_q(p#40));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.DoLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#8: int :: { Seq#Index(stmts#0, $i#8) } 0 <= $i#8 && $i#8 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#8)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#8)): DatatypeType) == class._module.Statement), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 42 == $FunctionContextHeight;
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, stmts#0) && _module.__default.Legal($Heap, this, stmts#0) && Seq#Length(stmts#0) != 0;
  requires _module.__default.Legal#canCall($Heap, this, stmts#0) ==> _module.__default.Legal($Heap, this, stmts#0) || Seq#Length(stmts#0) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#41: DatatypeType :: DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#41)] ==> _module.__default.GetSt($Heap, this, p#41, st#1) == _module.__default.GetSt($Heap, this, p#41, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path && (forall p$ih#9#42: DatatypeType :: DtAlloc(p$ih#9#42, $Heap) && DtType(p$ih#9#42) == class._module.Path ==> DtRank(p$ih#9#42) < DtRank(p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#9#42)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#9#42)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#9#42, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#9#42, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#10: int :: #_module.Path.OpaquePath(a0#10) == p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path && (forall p$ih#9#42: DatatypeType :: DtAlloc(p$ih#9#42, $Heap) && DtType(p$ih#9#42) == class._module.Path ==> DtRank(p$ih#9#42) < DtRank(p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#9#42)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p$ih#9#42)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#9#42, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#9#42, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))) && true && (exists a0#11: int :: #_module.Path.TransparentPath(a0#11) == p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  free ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2))));
  ensures (forall p#44: DatatypeType :: DtAlloc(p#44, $Heap) && DtType(p#44) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#44)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, stmts#0, st#1, env#2)))[$Box(p#44)] ==> _module.Path.OpaquePath_q(p#44));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.DoLemma(this: ref, stmts#0: Seq BoxType, st#1: BoxType, env#2: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#13: HeapType;
  var stmt#49: DatatypeType where DtAlloc(stmt#49, $Heap) && DtType(stmt#49) == class._module.Statement;
  var expr##50: DatatypeType;
  var st##51: BoxType;
  var env##52: BoxType;
  var result#53: DatatypeType where DtAlloc(result#53, $Heap) && DtType(result#53) == class._module.Tuple;
  var expr#54: DatatypeType;
  var st#55: BoxType;
  var env#56: BoxType;
  var expr'#57: DatatypeType where DtAlloc(expr'#57, $Heap) && DtType(expr'#57) == class._module.Expression;
  var st'#58: BoxType where GenericAlloc(st'#58, $Heap);
  var $rhs#15: DatatypeType;
  var $rhs#16: BoxType;
  var expr#59: DatatypeType;
  var env'#60: BoxType where GenericAlloc(env'#60, $Heap);
  var id#61: BoxType;
  var expr#62: DatatypeType;
  var env#63: BoxType;
  var stmts#64: Seq BoxType;
  var stmts##65: Seq BoxType;
  var st##66: BoxType;
  var env##67: BoxType;
  var expr##68: DatatypeType;
  var st##69: BoxType;
  var env##70: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(635,14): initial state"} true;
    $initHeapForallStmt#13 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#13 == $Heap;
    assume (forall $ih#stmts12#45: Seq BoxType :: (forall $i#14: int :: { Seq#Index($ih#stmts12#45, $i#14) } 0 <= $i#14 && $i#14 < Seq#Length($ih#stmts12#45) ==> DtAlloc($Unbox(Seq#Index($ih#stmts12#45, $i#14)): DatatypeType, $initHeapForallStmt#13) && DtType($Unbox(Seq#Index($ih#stmts12#45, $i#14)): DatatypeType) == class._module.Statement) && _module.__default.Legal($initHeapForallStmt#13, this, $ih#stmts12#45) && Seq#Rank($ih#stmts12#45) < Seq#Rank(stmts#0) ==> Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))) && (forall p#46: DatatypeType :: DtAlloc(p#46, $Heap) && DtType(p#46) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#46)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))[$Box(p#46)] ==> _module.__default.GetSt($Heap, this, p#46, st#1) == _module.__default.GetSt($Heap, this, p#46, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))) && (forall p#47: DatatypeType :: DtAlloc(p#47, $Heap) && DtType(p#47) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#47)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))[$Box(p#47)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#47, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#47, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))) && (forall p#48: DatatypeType :: DtAlloc(p#48, $Heap) && DtType(p#48) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#48)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.do($LS($LZ), $Heap, this, $ih#stmts12#45, st#1, env#2)))[$Box(p#48)] ==> _module.Path.OpaquePath_q(p#48)));
    $_reverifyPost := false;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(645,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(645,12)
    assume true;
    assert 0 <= Lit(0) && Lit(0) < Seq#Length(stmts#0);
    assume true;
    stmt#49 := $Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType;
    assume {:captureState "CachedBuilds0.dfy(645,12)"} true;
    // ----- if statement ----- CachedBuilds0.dfy(646,3)
    assume true;
    if (_module.Statement.stmtVariable_q(stmt#49))
    {
        // ----- call statement ----- CachedBuilds0.dfy(647,5)
        assert _module.Statement.stmtVariable_q(stmt#49);
        assume true;
        expr##50 := _module.Statement.expr(stmt#49);
        assume true;
        st##51 := st#1;
        assume true;
        env##52 := env#2;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.EvalLemma(this, expr##50, st##51, env##52);
        assume {:captureState "CachedBuilds0.dfy(647,5)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(648,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(648,16)
        assume true;
        assert _module.Statement.stmtVariable_q(stmt#49);
        expr#54 := _module.Statement.expr(stmt#49);
        st#55 := st#1;
        env#56 := env#2;
        assume _module.__default.eval#canCall($Heap, this, _module.Statement.expr(stmt#49), st#1, env#2);
        assume _module.__default.eval#canCall($Heap, this, _module.Statement.expr(stmt#49), st#1, env#2);
        result#53 := _module.__default.eval($LS($LZ), $Heap, this, _module.Statement.expr(stmt#49), st#1, env#2);
        assume {:captureState "CachedBuilds0.dfy(648,16)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(649,9)
        // ----- var-declaration statement ----- CachedBuilds0.dfy(649,16)
        // ----- update statement ----- CachedBuilds0.dfy(649,20)
        assume true;
        assume true;
        assume _module.Tuple.Pair_q(result#53);
        assume true;
        $rhs#15 := $Unbox(_module.Tuple.fst(result#53)): DatatypeType;
        assume _module.Tuple.Pair_q(result#53);
        assume true;
        $rhs#16 := _module.Tuple.snd(result#53);
        expr'#57 := $rhs#15;
        st'#58 := $rhs#16;
        assume {:captureState "CachedBuilds0.dfy(649,20)"} true;
        // ----- if statement ----- CachedBuilds0.dfy(650,5)
        expr#59 := expr'#57;
        assume _module.__default.Value#canCall($Heap, this, expr'#57);
        assume _module.__default.Value#canCall($Heap, this, expr'#57);
        if (_module.__default.Value($Heap, this, expr'#57))
        {
            // ----- var-declaration statement ----- CachedBuilds0.dfy(651,11)
            // ----- assignment statement ----- CachedBuilds0.dfy(651,16)
            assume true;
            assert _module.Statement.stmtVariable_q(stmt#49);
            id#61 := _module.Statement.id(stmt#49);
            expr#62 := expr'#57;
            env#63 := env#2;
            assert _module.__default.Value($Heap, this, expr#62);
            assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#49), expr'#57, env#2);
            assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#49), expr'#57, env#2);
            env'#60 := _module.__default.SetEnv($Heap, this, _module.Statement.id(stmt#49), expr'#57, env#2);
            assume {:captureState "CachedBuilds0.dfy(651,16)"} true;
            // ----- if statement ----- CachedBuilds0.dfy(652,7)
            assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
            stmts#64 := Seq#Drop(stmts#0, Lit(1));
            assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
            assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
            if (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))))
            {
                // ----- call statement ----- CachedBuilds0.dfy(653,9)
                assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                assume true;
                stmts##65 := Seq#Drop(stmts#0, Lit(1));
                assume true;
                st##66 := st'#58;
                assume true;
                env##67 := env'#60;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assert Seq#Rank(stmts##65) < Seq#Rank(stmts#0);
                call IntraModuleCall$$_module.__default.DoLemma(this, stmts##65, st##66, env##67);
                assume {:captureState "CachedBuilds0.dfy(653,9)"} true;
            }
            else
            {
            }
        }
        else
        {
        }
    }
    else
    {
        // ----- assert statement ----- CachedBuilds0.dfy(658,5)
        if (!_module.Statement.stmtVariable_q(stmt#49))
        {
        }

        assume !_module.Statement.stmtVariable_q(stmt#49) ==> true;
        assert _module.Statement.stmtVariable_q(stmt#49) || _module.Statement.stmtReturn_q(stmt#49);
        // ----- call statement ----- CachedBuilds0.dfy(659,5)
        assert _module.Statement.stmtReturn_q(stmt#49);
        assume true;
        expr##68 := _module.Statement.ret(stmt#49);
        assume true;
        st##69 := st#1;
        assume true;
        env##70 := env#2;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.EvalLemma(this, expr##68, st##69, env##70);
        assume {:captureState "CachedBuilds0.dfy(659,5)"} true;
    }
}



procedure CheckWellformed$$_module.__default.EvalLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation {:induction expr#0} {:timeLimit 200} CheckWellformed$$_module.__default.EvalLemma(this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var result#3: DatatypeType;
  var expr#4: DatatypeType;
  var st#5: BoxType;
  var env#6: BoxType;
  var expr'#7: DatatypeType;
  var st'#8: BoxType;
  var st#9: BoxType;
  var st#10: BoxType;
  var p#11: DatatypeType;
  var st#12: BoxType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var st#20: BoxType;
  var p#21: DatatypeType;
  var st#22: BoxType;
  var p#23: DatatypeType;
  var st#24: BoxType;
  var p#26: DatatypeType;
  var st#27: BoxType;
  var st#28: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(663,49): initial state"} true;
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(665,5): post-state"} true;
    expr#4 := expr#0;
    st#5 := st#1;
    env#6 := env#2;
    assume _module.__default.eval#canCall($Heap, this, expr#0, st#1, env#2);
    assume result#3 == _module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2);
    assume _module.__default.eval#canCall($Heap, this, expr#0, st#1, env#2);
    assume _module.Tuple.Pair_q(result#3);
    assume expr'#7 == $Unbox(_module.Tuple.fst(result#3)): DatatypeType;
    assume true;
    assume _module.Tuple.Pair_q(result#3);
    assume st'#8 == _module.Tuple.snd(result#3);
    assume true;
    st#9 := st#1;
    assume _module.__default.DomSt#canCall($Heap, this, st#1);
    st#10 := st'#8;
    assume _module.__default.DomSt#canCall($Heap, this, st'#8);
    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)))
    {
        havoc p#11;
        assume DtAlloc(p#11, $Heap) && DtType(p#11) == class._module.Path;
        st#12 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#11)])
        {
            st#13 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (_module.__default.DomSt($Heap, this, st#1)[$Box(p#11)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#11)])
        {
            p#14 := p#11;
            st#15 := st#1;
            assume _module.__default.GetSt#canCall($Heap, this, p#11, st#1);
            p#16 := p#11;
            st#17 := st'#8;
            assume _module.__default.GetSt#canCall($Heap, this, p#11, st'#8);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)) && (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#25)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st#1) == _module.__default.GetSt($Heap, this, p#25, st'#8)))
    {
        havoc p#18;
        assume DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path;
        st#19 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#18)])
        {
            st#20 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#18)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#18)])
        {
            p#21 := p#18;
            st#22 := st'#8;
            assume _module.__default.Res_k#canCall($Heap, this, p#18, st'#8);
            p#23 := p#18;
            st#24 := st'#8;
            assume _module.__default.GetSt#canCall($Heap, this, p#18, st'#8);
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, st'#8)) && (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#25)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#25)] ==> _module.__default.GetSt($Heap, this, p#25, st#1) == _module.__default.GetSt($Heap, this, p#25, st'#8)) && (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#29)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#29)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#29, st'#8) == _module.__default.GetSt($Heap, this, p#29, st'#8)))
    {
        havoc p#26;
        assume DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path;
        st#27 := st#1;
        assume _module.__default.DomSt#canCall($Heap, this, st#1);
        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#26)])
        {
            st#28 := st'#8;
            assume _module.__default.DomSt#canCall($Heap, this, st'#8);
        }

        if (!_module.__default.DomSt($Heap, this, st#1)[$Box(p#26)] && _module.__default.DomSt($Heap, this, st'#8)[$Box(p#26)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && (forall p#30: DatatypeType :: DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#30)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#30)] ==> _module.__default.GetSt($Heap, this, p#30, st#1) == _module.__default.GetSt($Heap, this, p#30, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && (forall p#31: DatatypeType :: DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#31)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#31, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && (forall p#32: DatatypeType :: DtAlloc(p#32, $Heap) && DtType(p#32) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#32)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#32)] ==> _module.Path.OpaquePath_q(p#32));
}



procedure InterModuleCall$$_module.__default.EvalLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#33)] ==> _module.__default.GetSt($Heap, this, p#33, st#1) == _module.__default.GetSt($Heap, this, p#33, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path && (forall p$ih#0#34: DatatypeType :: DtAlloc(p$ih#0#34, $Heap) && DtType(p$ih#0#34) == class._module.Path ==> DtRank(p$ih#0#34) < DtRank(p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#0#34)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#0#34)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#0#34, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#0#34, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#1: int :: #_module.Path.OpaquePath(a0#1) == p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path && (forall p$ih#0#34: DatatypeType :: DtAlloc(p$ih#0#34, $Heap) && DtType(p$ih#0#34) == class._module.Path ==> DtRank(p$ih#0#34) < DtRank(p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#0#34)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#0#34)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#0#34, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#0#34, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#2: int :: #_module.Path.TransparentPath(a0#2) == p#35) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  free ensures (forall p#35: DatatypeType :: DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#35)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#35, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#36: DatatypeType :: DtAlloc(p#36, $Heap) && DtType(p#36) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#36)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#36)] ==> _module.Path.OpaquePath_q(p#36));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#37: DatatypeType :: DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#37)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#37)] ==> _module.__default.GetSt($Heap, this, p#37, st#1) == _module.__default.GetSt($Heap, this, p#37, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path && (forall p$ih#3#38: DatatypeType :: DtAlloc(p$ih#3#38, $Heap) && DtType(p$ih#3#38) == class._module.Path ==> DtRank(p$ih#3#38) < DtRank(p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#3#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#3#38)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#38, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#3#38, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#4: int :: #_module.Path.OpaquePath(a0#4) == p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path && (forall p$ih#3#38: DatatypeType :: DtAlloc(p$ih#3#38, $Heap) && DtType(p$ih#3#38) == class._module.Path ==> DtRank(p$ih#3#38) < DtRank(p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#3#38)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#3#38)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#38, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#3#38, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#5: int :: #_module.Path.TransparentPath(a0#5) == p#39) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  free ensures (forall p#39: DatatypeType :: DtAlloc(p#39, $Heap) && DtType(p#39) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#39)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#39)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#39, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#40: DatatypeType :: DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#40)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#40)] ==> _module.Path.OpaquePath_q(p#40));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), st#1: BoxType where GenericAlloc(st#1, $Heap), env#2: BoxType where GenericAlloc(env#2, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#41: DatatypeType :: DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#41)] ==> _module.__default.GetSt($Heap, this, p#41, st#1) == _module.__default.GetSt($Heap, this, p#41, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path && (forall p$ih#6#42: DatatypeType :: DtAlloc(p$ih#6#42, $Heap) && DtType(p$ih#6#42) == class._module.Path ==> DtRank(p$ih#6#42) < DtRank(p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#6#42)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#6#42)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#42, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#6#42, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#7: int :: #_module.Path.OpaquePath(a0#7) == p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path && (forall p$ih#6#42: DatatypeType :: DtAlloc(p$ih#6#42, $Heap) && DtType(p$ih#6#42) == class._module.Path ==> DtRank(p$ih#6#42) < DtRank(p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p$ih#6#42)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p$ih#6#42)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#42, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p$ih#6#42, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))) && true && (exists a0#8: int :: #_module.Path.TransparentPath(a0#8) == p#43) ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  free ensures (forall p#43: DatatypeType :: DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#43)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#43, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2))));
  ensures (forall p#44: DatatypeType :: DtAlloc(p#44, $Heap) && DtType(p#44) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#44)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, expr#0, st#1, env#2)))[$Box(p#44)] ==> _module.Path.OpaquePath_q(p#44));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation {:induction expr#0} {:timeLimit 200} Impl$$_module.__default.EvalLemma(this: ref, expr#0: DatatypeType, st#1: BoxType, env#2: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#10: HeapType;
  var expr#49: DatatypeType;
  var result#50: DatatypeType where DtAlloc(result#50, $Heap) && DtType(result#50) == class._module.Tuple;
  var expr#51: DatatypeType;
  var st#52: BoxType;
  var env#53: BoxType;
  var cond'#54: DatatypeType where DtAlloc(cond'#54, $Heap) && DtType(cond'#54) == class._module.Expression;
  var st'#55: BoxType where GenericAlloc(st'#55, $Heap);
  var $rhs#11: DatatypeType;
  var $rhs#12: BoxType;
  var expr##56: DatatypeType;
  var st##57: BoxType;
  var env##58: BoxType;
  var expr##59: DatatypeType;
  var st##60: BoxType;
  var env##61: BoxType;
  var result#62: DatatypeType where DtAlloc(result#62, $Heap) && DtType(result#62) == class._module.Tuple;
  var expr#63: DatatypeType;
  var st#64: BoxType;
  var env#65: BoxType;
  var conj0'#66: DatatypeType where DtAlloc(conj0'#66, $Heap) && DtType(conj0'#66) == class._module.Expression;
  var st'#67: BoxType where GenericAlloc(st'#67, $Heap);
  var $rhs#13: DatatypeType;
  var $rhs#14: BoxType;
  var expr##68: DatatypeType;
  var st##69: BoxType;
  var env##70: BoxType;
  var result#71: DatatypeType where DtAlloc(result#71, $Heap) && DtType(result#71) == class._module.Tuple;
  var expr#72: DatatypeType;
  var st#73: BoxType;
  var env#74: BoxType;
  var disj0'#75: DatatypeType where DtAlloc(disj0'#75, $Heap) && DtType(disj0'#75) == class._module.Expression;
  var st'#76: BoxType where GenericAlloc(st'#76, $Heap);
  var $rhs#15: DatatypeType;
  var $rhs#16: BoxType;
  var expr##77: DatatypeType;
  var st##78: BoxType;
  var env##79: BoxType;
  var expr##80: DatatypeType;
  var st##81: BoxType;
  var env##82: BoxType;
  var resultFun#83: DatatypeType where DtAlloc(resultFun#83, $Heap) && DtType(resultFun#83) == class._module.Tuple;
  var expr#84: DatatypeType;
  var st#85: BoxType;
  var env#86: BoxType;
  var fun'#87: DatatypeType where DtAlloc(fun'#87, $Heap) && DtType(fun'#87) == class._module.Expression;
  var st'#88: BoxType where GenericAlloc(st'#88, $Heap);
  var $rhs#17: DatatypeType;
  var $rhs#18: BoxType;
  var expr##89: DatatypeType;
  var args##90: Seq BoxType;
  var st##91: BoxType;
  var env##92: BoxType;
  var resultArgs#93: DatatypeType where DtAlloc(resultArgs#93, $Heap) && DtType(resultArgs#93) == class._module.Tuple;
  var expr#94: DatatypeType;
  var args#95: Seq BoxType;
  var st#96: BoxType;
  var env#97: BoxType;
  var args'#99: Seq BoxType where (forall $i#19: int :: { Seq#Index(args'#99, $i#19) } 0 <= $i#19 && $i#19 < Seq#Length(args'#99) ==> DtAlloc($Unbox(Seq#Index(args'#99, $i#19)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#99, $i#19)): DatatypeType) == class._module.Expression);
  var sts'#100: Set BoxType where (forall $t#20: BoxType :: { sts'#100[$t#20] } sts'#100[$t#20] ==> GenericAlloc($t#20, $Heap));
  var $rhs#21: Seq BoxType;
  var $rhs#22: Set BoxType;
  var sts''#101: Set BoxType where (forall $t#23: BoxType :: { sts''#101[$t#23] } sts''#101[$t#23] ==> GenericAlloc($t#23, $Heap));
  var st0#102: BoxType;
  var st1#103: BoxType;
  var p#104: DatatypeType;
  var st#105: BoxType;
  var st#106: BoxType;
  var p#107: DatatypeType;
  var st#108: BoxType;
  var p#109: DatatypeType;
  var st#110: BoxType;
  var $initHeapForallStmt#24: HeapType;
  var sts#114: Set BoxType;
  var stCombined#115: BoxType where GenericAlloc(stCombined#115, $Heap);
  var sts#116: Set BoxType;
  var prim#117: DatatypeType;
  var prim#118: DatatypeType;
  var args#119: Seq BoxType;
  var st#120: BoxType;
  var cmd##121: DatatypeType;
  var deps##122: DatatypeType;
  var exts##123: DatatypeType;
  var st##124: BoxType;
  var resultExec#125: DatatypeType where DtAlloc(resultExec#125, $Heap) && DtType(resultExec#125) == class._module.Tuple;
  var cmd#126: DatatypeType;
  var deps#127: DatatypeType;
  var exts#128: DatatypeType;
  var st#129: BoxType;
  var stExec#130: BoxType where GenericAlloc(stExec#130, $Heap);
  var p#131: DatatypeType;
  var st#132: BoxType;
  var st#133: BoxType;
  var st#134: BoxType;
  var st#135: BoxType;
  var st#136: BoxType;
  var paths#137: Set BoxType;
  var st#138: BoxType;
  var p#139: DatatypeType;
  var st#140: BoxType;
  var p#141: DatatypeType;
  var st#142: BoxType;
  var $initHeapForallStmt#25: HeapType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(663,49): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    $initHeapForallStmt#10 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#10 == $Heap;
    assume (forall $ih#expr9#45: DatatypeType :: DtAlloc($ih#expr9#45, $initHeapForallStmt#10) && DtType($ih#expr9#45) == class._module.Expression && Lit(true) && DtRank($ih#expr9#45) < DtRank(expr#0) ==> Set#Subset(_module.__default.DomSt($Heap, this, st#1), _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))) && (forall p#46: DatatypeType :: DtAlloc(p#46, $Heap) && DtType(p#46) == class._module.Path ==> _module.__default.DomSt($Heap, this, st#1)[$Box(p#46)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))[$Box(p#46)] ==> _module.__default.GetSt($Heap, this, p#46, st#1) == _module.__default.GetSt($Heap, this, p#46, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))) && (forall p#47: DatatypeType :: DtAlloc(p#47, $Heap) && DtType(p#47) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#47)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))[$Box(p#47)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#47, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2))) == _module.__default.GetSt($Heap, this, p#47, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))) && (forall p#48: DatatypeType :: DtAlloc(p#48, $Heap) && DtType(p#48) == class._module.Path ==> !_module.__default.DomSt($Heap, this, st#1)[$Box(p#48)] && _module.__default.DomSt($Heap, this, _module.Tuple.snd(_module.__default.eval($LS($LZ), $Heap, this, $ih#expr9#45, st#1, env#2)))[$Box(p#48)] ==> _module.Path.OpaquePath_q(p#48)));
    $_reverifyPost := false;
    // ----- if statement ----- CachedBuilds0.dfy(673,3)
    expr#49 := expr#0;
    assume _module.__default.Value#canCall($Heap, this, expr#0);
    assume _module.__default.Value#canCall($Heap, this, expr#0);
    if (_module.__default.Value($Heap, this, expr#0))
    {
    }
    else
    {
        // ----- if statement ----- CachedBuilds0.dfy(674,10)
        assume true;
        if (_module.Expression.exprIdentifier_q(expr#0))
        {
        }
        else
        {
            // ----- if statement ----- CachedBuilds0.dfy(675,10)
            if (_module.Expression.exprIf_q(expr#0))
            {
                assert _module.Expression.exprIf_q(expr#0);
            }

            if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
            {
                assert _module.Expression.exprIf_q(expr#0);
                assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
            }

            assume (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true);
            if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue())
            {
            }
            else
            {
                // ----- if statement ----- CachedBuilds0.dfy(676,10)
                if (_module.Expression.exprIf_q(expr#0))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                }

                assume (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true);
                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse())
                {
                }
                else
                {
                    // ----- if statement ----- CachedBuilds0.dfy(677,10)
                    assume true;
                    if (_module.Expression.exprIf_q(expr#0))
                    {
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(678,9)
                        // ----- assignment statement ----- CachedBuilds0.dfy(678,16)
                        assume true;
                        assert _module.Expression.exprIf_q(expr#0);
                        expr#51 := _module.Expression.cond(expr#0);
                        st#52 := st#1;
                        env#53 := env#2;
                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                        assume _module.__default.eval#canCall($Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                        result#50 := _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), st#1, env#2);
                        assume {:captureState "CachedBuilds0.dfy(678,16)"} true;
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(679,9)
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(679,16)
                        // ----- update statement ----- CachedBuilds0.dfy(679,20)
                        assume true;
                        assume true;
                        assume _module.Tuple.Pair_q(result#50);
                        assume true;
                        $rhs#11 := $Unbox(_module.Tuple.fst(result#50)): DatatypeType;
                        assume _module.Tuple.Pair_q(result#50);
                        assume true;
                        $rhs#12 := _module.Tuple.snd(result#50);
                        cond'#54 := $rhs#11;
                        st'#55 := $rhs#12;
                        assume {:captureState "CachedBuilds0.dfy(679,20)"} true;
                        // ----- if statement ----- CachedBuilds0.dfy(680,5)
                        if (_module.Expression.exprLiteral_q(cond'#54))
                        {
                            assert _module.Expression.exprLiteral_q(cond'#54);
                        }

                        assume _module.Expression.exprLiteral_q(cond'#54) ==> true;
                        if (_module.Expression.exprLiteral_q(cond'#54) && _module.Expression.lit(cond'#54) == #_module.Literal.litTrue())
                        {
                            // ----- call statement ----- CachedBuilds0.dfy(681,7)
                            assert _module.Expression.exprIf_q(expr#0);
                            assume true;
                            expr##56 := _module.Expression.ifTrue(expr#0);
                            assume true;
                            st##57 := st'#55;
                            assume true;
                            env##58 := env#2;
                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                            assert DtRank(expr##56) < DtRank(expr#0);
                            call IntraModuleCall$$_module.__default.EvalLemma(this, expr##56, st##57, env##58);
                            assume {:captureState "CachedBuilds0.dfy(681,7)"} true;
                        }
                        else
                        {
                            // ----- if statement ----- CachedBuilds0.dfy(682,12)
                            if (_module.Expression.exprLiteral_q(cond'#54))
                            {
                                assert _module.Expression.exprLiteral_q(cond'#54);
                            }

                            assume _module.Expression.exprLiteral_q(cond'#54) ==> true;
                            if (_module.Expression.exprLiteral_q(cond'#54) && _module.Expression.lit(cond'#54) == #_module.Literal.litFalse())
                            {
                                // ----- call statement ----- CachedBuilds0.dfy(683,7)
                                assert _module.Expression.exprIf_q(expr#0);
                                assume true;
                                expr##59 := _module.Expression.ifFalse(expr#0);
                                assume true;
                                st##60 := st'#55;
                                assume true;
                                env##61 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr##59) < DtRank(expr#0);
                                call IntraModuleCall$$_module.__default.EvalLemma(this, expr##59, st##60, env##61);
                                assume {:captureState "CachedBuilds0.dfy(683,7)"} true;
                            }
                            else
                            {
                            }
                        }
                    }
                    else
                    {
                        // ----- if statement ----- CachedBuilds0.dfy(685,10)
                        assume true;
                        if (_module.Expression.exprAnd_q(expr#0))
                        {
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(686,9)
                            // ----- assignment statement ----- CachedBuilds0.dfy(686,16)
                            assume true;
                            assert _module.Expression.exprAnd_q(expr#0);
                            expr#63 := _module.Expression.conj0(expr#0);
                            st#64 := st#1;
                            env#65 := env#2;
                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                            assume _module.__default.eval#canCall($Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                            result#62 := _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), st#1, env#2);
                            assume {:captureState "CachedBuilds0.dfy(686,16)"} true;
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(687,9)
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(687,17)
                            // ----- update statement ----- CachedBuilds0.dfy(687,21)
                            assume true;
                            assume true;
                            assume _module.Tuple.Pair_q(result#62);
                            assume true;
                            $rhs#13 := $Unbox(_module.Tuple.fst(result#62)): DatatypeType;
                            assume _module.Tuple.Pair_q(result#62);
                            assume true;
                            $rhs#14 := _module.Tuple.snd(result#62);
                            conj0'#66 := $rhs#13;
                            st'#67 := $rhs#14;
                            assume {:captureState "CachedBuilds0.dfy(687,21)"} true;
                            // ----- if statement ----- CachedBuilds0.dfy(688,5)
                            if (_module.Expression.exprLiteral_q(conj0'#66))
                            {
                                assert _module.Expression.exprLiteral_q(conj0'#66);
                            }

                            assume _module.Expression.exprLiteral_q(conj0'#66) ==> true;
                            if (_module.Expression.exprLiteral_q(conj0'#66) && _module.Expression.lit(conj0'#66) == #_module.Literal.litTrue())
                            {
                                // ----- call statement ----- CachedBuilds0.dfy(689,7)
                                assert _module.Expression.exprAnd_q(expr#0);
                                assume true;
                                expr##68 := _module.Expression.conj1(expr#0);
                                assume true;
                                st##69 := st'#67;
                                assume true;
                                env##70 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr##68) < DtRank(expr#0);
                                call IntraModuleCall$$_module.__default.EvalLemma(this, expr##68, st##69, env##70);
                                assume {:captureState "CachedBuilds0.dfy(689,7)"} true;
                            }
                            else
                            {
                                // ----- if statement ----- CachedBuilds0.dfy(690,12)
                                if (_module.Expression.exprLiteral_q(conj0'#66))
                                {
                                    assert _module.Expression.exprLiteral_q(conj0'#66);
                                }

                                assume _module.Expression.exprLiteral_q(conj0'#66) ==> true;
                                if (_module.Expression.exprLiteral_q(conj0'#66) && _module.Expression.lit(conj0'#66) == #_module.Literal.litFalse())
                                {
                                }
                                else
                                {
                                }
                            }
                        }
                        else
                        {
                            // ----- if statement ----- CachedBuilds0.dfy(692,10)
                            assume true;
                            if (_module.Expression.exprOr_q(expr#0))
                            {
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(693,9)
                                // ----- assignment statement ----- CachedBuilds0.dfy(693,16)
                                assume true;
                                assert _module.Expression.exprOr_q(expr#0);
                                expr#72 := _module.Expression.disj0(expr#0);
                                st#73 := st#1;
                                env#74 := env#2;
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                assume _module.__default.eval#canCall($Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                result#71 := _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), st#1, env#2);
                                assume {:captureState "CachedBuilds0.dfy(693,16)"} true;
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(694,9)
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(694,17)
                                // ----- update statement ----- CachedBuilds0.dfy(694,21)
                                assume true;
                                assume true;
                                assume _module.Tuple.Pair_q(result#71);
                                assume true;
                                $rhs#15 := $Unbox(_module.Tuple.fst(result#71)): DatatypeType;
                                assume _module.Tuple.Pair_q(result#71);
                                assume true;
                                $rhs#16 := _module.Tuple.snd(result#71);
                                disj0'#75 := $rhs#15;
                                st'#76 := $rhs#16;
                                assume {:captureState "CachedBuilds0.dfy(694,21)"} true;
                                // ----- if statement ----- CachedBuilds0.dfy(695,5)
                                if (_module.Expression.exprLiteral_q(disj0'#75))
                                {
                                    assert _module.Expression.exprLiteral_q(disj0'#75);
                                }

                                assume _module.Expression.exprLiteral_q(disj0'#75) ==> true;
                                if (_module.Expression.exprLiteral_q(disj0'#75) && _module.Expression.lit(disj0'#75) == #_module.Literal.litTrue())
                                {
                                }
                                else
                                {
                                    // ----- if statement ----- CachedBuilds0.dfy(696,12)
                                    if (_module.Expression.exprLiteral_q(disj0'#75))
                                    {
                                        assert _module.Expression.exprLiteral_q(disj0'#75);
                                    }

                                    assume _module.Expression.exprLiteral_q(disj0'#75) ==> true;
                                    if (_module.Expression.exprLiteral_q(disj0'#75) && _module.Expression.lit(disj0'#75) == #_module.Literal.litFalse())
                                    {
                                        // ----- call statement ----- CachedBuilds0.dfy(697,7)
                                        assert _module.Expression.exprOr_q(expr#0);
                                        assume true;
                                        expr##77 := _module.Expression.disj1(expr#0);
                                        assume true;
                                        st##78 := st'#76;
                                        assume true;
                                        env##79 := env#2;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr##77) < DtRank(expr#0);
                                        call IntraModuleCall$$_module.__default.EvalLemma(this, expr##77, st##78, env##79);
                                        assume {:captureState "CachedBuilds0.dfy(697,7)"} true;
                                    }
                                    else
                                    {
                                    }
                                }
                            }
                            else
                            {
                                // ----- if statement ----- CachedBuilds0.dfy(699,10)
                                assume true;
                                if (_module.Expression.exprInvocation_q(expr#0))
                                {
                                    // ----- call statement ----- CachedBuilds0.dfy(700,5)
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    assume true;
                                    expr##80 := _module.Expression.fun(expr#0);
                                    assume true;
                                    st##81 := st#1;
                                    assume true;
                                    env##82 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr##80) < DtRank(expr#0);
                                    call IntraModuleCall$$_module.__default.EvalLemma(this, expr##80, st##81, env##82);
                                    assume {:captureState "CachedBuilds0.dfy(700,5)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(701,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(701,19)
                                    assume true;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    expr#84 := _module.Expression.fun(expr#0);
                                    st#85 := st#1;
                                    env#86 := env#2;
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                    assume _module.__default.eval#canCall($Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                    resultFun#83 := _module.__default.eval($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), st#1, env#2);
                                    assume {:captureState "CachedBuilds0.dfy(701,19)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(702,9)
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(702,15)
                                    // ----- update statement ----- CachedBuilds0.dfy(702,19)
                                    assume true;
                                    assume true;
                                    assume _module.Tuple.Pair_q(resultFun#83);
                                    assume true;
                                    $rhs#17 := $Unbox(_module.Tuple.fst(resultFun#83)): DatatypeType;
                                    assume _module.Tuple.Pair_q(resultFun#83);
                                    assume true;
                                    $rhs#18 := _module.Tuple.snd(resultFun#83);
                                    fun'#87 := $rhs#17;
                                    st'#88 := $rhs#18;
                                    assume {:captureState "CachedBuilds0.dfy(702,19)"} true;
                                    // ----- call statement ----- CachedBuilds0.dfy(703,5)
                                    assume true;
                                    expr##89 := expr#0;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    assume true;
                                    args##90 := _module.Expression.args(expr#0);
                                    assume true;
                                    st##91 := st#1;
                                    assume true;
                                    env##92 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr##89) <= DtRank(expr#0) && (DtRank(expr##89) == DtRank(expr#0) ==> true);
                                    call IntraModuleCall$$_module.__default.EvalArgsLemma(this, expr##89, args##90, st##91, env##92);
                                    assume {:captureState "CachedBuilds0.dfy(703,5)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(704,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(704,20)
                                    assume true;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    expr#94 := expr#0;
                                    args#95 := _module.Expression.args(expr#0);
                                    st#96 := st#1;
                                    env#97 := env#2;
                                    assert (forall arg#98: DatatypeType :: DtAlloc(arg#98, $Heap) && DtType(arg#98) == class._module.Expression ==> Seq#Contains(args#95, $Box(arg#98)) ==> DtRank(arg#98) < DtRank(expr#94));
                                    assume _module.__default.evalArgs#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                    assume _module.__default.evalArgs#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                    resultArgs#93 := _module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), st#1, env#2);
                                    assume {:captureState "CachedBuilds0.dfy(704,20)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(705,9)
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(705,16)
                                    // ----- update statement ----- CachedBuilds0.dfy(705,21)
                                    assume true;
                                    assume true;
                                    assume _module.Tuple.Pair_q(resultArgs#93);
                                    assume true;
                                    $rhs#21 := $Unbox(_module.Tuple.fst(resultArgs#93)): Seq BoxType;
                                    assume _module.Tuple.Pair_q(resultArgs#93);
                                    assume true;
                                    $rhs#22 := $Unbox(_module.Tuple.snd(resultArgs#93)): Set BoxType;
                                    args'#99 := $rhs#21;
                                    sts'#100 := $rhs#22;
                                    assume {:captureState "CachedBuilds0.dfy(705,21)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(706,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(706,15)
                                    assume true;
                                    assume true;
                                    sts''#101 := Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, st'#88), sts'#100);
                                    assume {:captureState "CachedBuilds0.dfy(706,15)"} true;
                                    // ----- forall statement (proof) ----- CachedBuilds0.dfy(707,5)
                                    if (*)
                                    {
                                        havoc st0#102, st1#103, p#104;
                                        assume GenericAlloc(st0#102, $Heap) && GenericAlloc(st1#103, $Heap) && DtAlloc(p#104, $Heap) && DtType(p#104) == class._module.Path;
                                        if (sts''#101[st0#102])
                                        {
                                        }

                                        if (sts''#101[st0#102] && sts''#101[st1#103])
                                        {
                                            st#105 := st0#102;
                                            assume _module.__default.DomSt#canCall($Heap, this, st0#102);
                                        }

                                        if (sts''#101[st0#102] && sts''#101[st1#103] && _module.__default.DomSt($Heap, this, st0#102)[$Box(p#104)])
                                        {
                                            st#106 := st1#103;
                                            assume _module.__default.DomSt#canCall($Heap, this, st1#103);
                                        }

                                        assume (sts''#101[st0#102] ==> true) && (sts''#101[st0#102] && sts''#101[st1#103] ==> _module.__default.DomSt#canCall($Heap, this, st0#102)) && (sts''#101[st0#102] && sts''#101[st1#103] && _module.__default.DomSt($Heap, this, st0#102)[$Box(p#104)] ==> _module.__default.DomSt#canCall($Heap, this, st1#103));
                                        assume sts''#101[st0#102] && sts''#101[st1#103] && _module.__default.DomSt($Heap, this, st0#102)[$Box(p#104)] && _module.__default.DomSt($Heap, this, st1#103)[$Box(p#104)];
                                        // ----- if statement ----- CachedBuilds0.dfy(710,7)
                                        if (st0#102 == st'#88)
                                        {
                                        }

                                        assume st0#102 == st'#88 ==> true;
                                        if (st0#102 == st'#88 && st1#103 == st'#88)
                                        {
                                        }
                                        else
                                        {
                                            // ----- if statement ----- CachedBuilds0.dfy(711,14)
                                            if (st0#102 == st'#88)
                                            {
                                            }

                                            assume st0#102 == st'#88 ==> true;
                                            if (st0#102 == st'#88 && sts'#100[st1#103])
                                            {
                                            }
                                            else
                                            {
                                                // ----- if statement ----- CachedBuilds0.dfy(712,14)
                                                if (sts'#100[st0#102])
                                                {
                                                }

                                                assume sts'#100[st0#102] ==> true;
                                                if (sts'#100[st0#102] && st1#103 == st'#88)
                                                {
                                                }
                                                else
                                                {
                                                }
                                            }
                                        }

                                        p#107 := p#104;
                                        st#108 := st0#102;
                                        assume _module.__default.GetSt#canCall($Heap, this, p#104, st0#102);
                                        p#109 := p#104;
                                        st#110 := st1#103;
                                        assume _module.__default.GetSt#canCall($Heap, this, p#104, st1#103);
                                        assume _module.__default.GetSt#canCall($Heap, this, p#104, st0#102) && _module.__default.GetSt#canCall($Heap, this, p#104, st1#103);
                                        assert _module.__default.GetSt($Heap, this, p#104, st0#102) == _module.__default.GetSt($Heap, this, p#104, st1#103);
                                        assume false;
                                    }
                                    else
                                    {
                                        $initHeapForallStmt#24 := $Heap;
                                        havoc $Heap, $Tick;
                                        assume $initHeapForallStmt#24 == $Heap;
                                        assume (forall st0#111: BoxType, st1#112: BoxType, p#113: DatatypeType :: GenericAlloc(st0#111, $initHeapForallStmt#24) && GenericAlloc(st1#112, $initHeapForallStmt#24) && DtAlloc(p#113, $initHeapForallStmt#24) && DtType(p#113) == class._module.Path && sts''#101[st0#111] && sts''#101[st1#112] && _module.__default.DomSt($initHeapForallStmt#24, this, st0#111)[$Box(p#113)] && _module.__default.DomSt($initHeapForallStmt#24, this, st1#112)[$Box(p#113)] ==> _module.__default.GetSt($Heap, this, p#113, st0#111) == _module.__default.GetSt($Heap, this, p#113, st1#112));
                                    }

                                    assume {:captureState "CachedBuilds0.dfy(707,5)"} true;
                                    // ----- if statement ----- CachedBuilds0.dfy(715,5)
                                    sts#114 := sts''#101;
                                    assume _module.__default.Compatible#canCall($Heap, this, sts''#101);
                                    assume _module.__default.Compatible#canCall($Heap, this, sts''#101);
                                    if (_module.__default.Compatible($Heap, this, sts''#101))
                                    {
                                        // ----- var-declaration statement ----- CachedBuilds0.dfy(716,11)
                                        // ----- assignment statement ----- CachedBuilds0.dfy(716,22)
                                        assume true;
                                        sts#116 := sts''#101;
                                        assert !Set#Equal(sts#116, Set#Empty(): Set BoxType);
                                        assume _module.__default.Combine#canCall($Heap, this, sts''#101);
                                        assume _module.__default.Combine#canCall($Heap, this, sts''#101);
                                        stCombined#115 := _module.__default.Combine($LS($LZ), $Heap, this, sts''#101);
                                        assume {:captureState "CachedBuilds0.dfy(716,22)"} true;
                                        // ----- if statement ----- CachedBuilds0.dfy(717,7)
                                        if (_module.Expression.exprLiteral_q(fun'#87))
                                        {
                                            assert _module.Expression.exprLiteral_q(fun'#87);
                                        }

                                        assume _module.Expression.exprLiteral_q(fun'#87) ==> true;
                                        if (_module.Expression.exprLiteral_q(fun'#87) && _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#87)))
                                        {
                                            // ----- if statement ----- CachedBuilds0.dfy(718,9)
                                            assert _module.Expression.exprLiteral_q(fun'#87);
                                            assert _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#87));
                                            assume true;
                                            if (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit(fun'#87))))
                                            {
                                                // ----- if statement ----- CachedBuilds0.dfy(719,11)
                                                prim#117 := #_module.Primitive.primExec();
                                                assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec());
                                                if (Seq#Length(args'#99) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()))
                                                {
                                                    prim#118 := #_module.Primitive.primExec();
                                                    args#119 := args'#99;
                                                    st#120 := stCombined#115;
                                                    assert _module.Primitive.primExec_q(prim#118) ==> Seq#Length(args#119) == 3;
                                                    assert _module.Primitive.primCreatePath_q(prim#118) ==> Seq#Length(args#119) == 1;
                                                    assume _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), args'#99, stCombined#115);
                                                }

                                                assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length(args'#99) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgs#canCall($Heap, this, #_module.Primitive.primExec(), args'#99, stCombined#115));
                                                if (Seq#Length(args'#99) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgs($Heap, this, #_module.Primitive.primExec(), args'#99, stCombined#115))
                                                {
                                                    // ----- call statement ----- CachedBuilds0.dfy(720,13)
                                                    assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#99);
                                                    assume true;
                                                    cmd##121 := $Unbox(Seq#Index(args'#99, Lit(0))): DatatypeType;
                                                    assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#99);
                                                    assume true;
                                                    deps##122 := $Unbox(Seq#Index(args'#99, Lit(1))): DatatypeType;
                                                    assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#99);
                                                    assume true;
                                                    exts##123 := $Unbox(Seq#Index(args'#99, Lit(2))): DatatypeType;
                                                    assume true;
                                                    st##124 := stCombined#115;
                                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                    call IntraModuleCall$$_module.__default.ExecProperty(this, cmd##121, deps##122, exts##123, st##124);
                                                    assume {:captureState "CachedBuilds0.dfy(720,13)"} true;
                                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(721,17)
                                                    // ----- assignment statement ----- CachedBuilds0.dfy(721,28)
                                                    assume true;
                                                    assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#99);
                                                    assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#99);
                                                    assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#99);
                                                    cmd#126 := $Unbox(Seq#Index(args'#99, Lit(0))): DatatypeType;
                                                    deps#127 := $Unbox(Seq#Index(args'#99, Lit(1))): DatatypeType;
                                                    exts#128 := $Unbox(Seq#Index(args'#99, Lit(2))): DatatypeType;
                                                    st#129 := stCombined#115;
                                                    assume _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index(args'#99, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(2))): DatatypeType, stCombined#115);
                                                    assume _module.__default.exec#canCall($Heap, this, $Unbox(Seq#Index(args'#99, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(2))): DatatypeType, stCombined#115);
                                                    resultExec#125 := _module.__default.exec($Heap, this, $Unbox(Seq#Index(args'#99, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#99, Lit(2))): DatatypeType, stCombined#115);
                                                    assume {:captureState "CachedBuilds0.dfy(721,28)"} true;
                                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(722,17)
                                                    // ----- assignment statement ----- CachedBuilds0.dfy(722,24)
                                                    assume true;
                                                    assume _module.Tuple.Pair_q(resultExec#125);
                                                    assume true;
                                                    stExec#130 := _module.Tuple.snd(resultExec#125);
                                                    assume {:captureState "CachedBuilds0.dfy(722,24)"} true;
                                                    // ----- forall statement (proof) ----- CachedBuilds0.dfy(723,13)
                                                    if (*)
                                                    {
                                                        havoc p#131;
                                                        assume DtAlloc(p#131, $Heap) && DtType(p#131) == class._module.Path;
                                                        st#132 := stCombined#115;
                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115);
                                                        if (_module.__default.DomSt($Heap, this, stCombined#115)[$Box(p#131)])
                                                        {
                                                            st#133 := stExec#130;
                                                            assume _module.__default.DomSt#canCall($Heap, this, stExec#130);
                                                        }

                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115) && (_module.__default.DomSt($Heap, this, stCombined#115)[$Box(p#131)] ==> _module.__default.DomSt#canCall($Heap, this, stExec#130));
                                                        assume _module.__default.DomSt($Heap, this, stCombined#115)[$Box(p#131)] && _module.__default.DomSt($Heap, this, stExec#130)[$Box(p#131)];
                                                        // ----- assert statement ----- CachedBuilds0.dfy(726,15)
                                                        st#134 := stCombined#115;
                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115);
                                                        st#135 := stExec#130;
                                                        assume _module.__default.DomSt#canCall($Heap, this, stExec#130);
                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115) && _module.__default.DomSt#canCall($Heap, this, stExec#130);
                                                        assert Set#Subset(_module.__default.DomSt($Heap, this, stCombined#115), _module.__default.DomSt($Heap, this, stExec#130));
                                                        // ----- assert statement ----- CachedBuilds0.dfy(727,15)
                                                        st#136 := stCombined#115;
                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115);
                                                        paths#137 := _module.__default.DomSt($Heap, this, stCombined#115);
                                                        st#138 := stExec#130;
                                                        assert {:subsumption 0} Set#Subset(paths#137, _module.__default.DomSt($Heap, this, st#138));
                                                        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, stCombined#115), stExec#130);
                                                        assume _module.__default.DomSt#canCall($Heap, this, stCombined#115) && _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, stCombined#115), stExec#130);
                                                        assert {:subsumption 0} stCombined#115 == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, stCombined#115), stExec#130);
                                                        assume stCombined#115 == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, stCombined#115), stExec#130);
                                                        p#139 := p#131;
                                                        st#140 := stCombined#115;
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#131, stCombined#115);
                                                        p#141 := p#131;
                                                        st#142 := stExec#130;
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#131, stExec#130);
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#131, stCombined#115) && _module.__default.GetSt#canCall($Heap, this, p#131, stExec#130);
                                                        assert _module.__default.GetSt($Heap, this, p#131, stCombined#115) == _module.__default.GetSt($Heap, this, p#131, stExec#130);
                                                        assume false;
                                                    }
                                                    else
                                                    {
                                                        $initHeapForallStmt#25 := $Heap;
                                                        havoc $Heap, $Tick;
                                                        assume $initHeapForallStmt#25 == $Heap;
                                                        assume (forall p#143: DatatypeType :: DtAlloc(p#143, $initHeapForallStmt#25) && DtType(p#143) == class._module.Path && _module.__default.DomSt($initHeapForallStmt#25, this, stCombined#115)[$Box(p#143)] && _module.__default.DomSt($initHeapForallStmt#25, this, stExec#130)[$Box(p#143)] ==> _module.__default.GetSt($Heap, this, p#143, stCombined#115) == _module.__default.GetSt($Heap, this, p#143, stExec#130));
                                                    }

                                                    assume {:captureState "CachedBuilds0.dfy(723,13)"} true;
                                                }
                                                else
                                                {
                                                }
                                            }
                                            else
                                            {
                                            }
                                        }
                                        else
                                        {
                                        }
                                    }
                                    else
                                    {
                                    }
                                }
                                else
                                {
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



procedure CheckWellformed$$_module.__default.EvalArgsLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap));
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.EvalArgsLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#4: DatatypeType;
  var result#6: DatatypeType;
  var expr#7: DatatypeType;
  var args#8: Seq BoxType;
  var st#9: BoxType;
  var env#10: BoxType;
  var sts'#12: Set BoxType;
  var st'#13: BoxType;
  var st#14: BoxType;
  var st#15: BoxType;
  var st'#16: BoxType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var st#19: BoxType;
  var p#20: DatatypeType;
  var st#21: BoxType;
  var p#22: DatatypeType;
  var st#23: BoxType;
  var st'#25: BoxType;
  var p#26: DatatypeType;
  var st#27: BoxType;
  var st#28: BoxType;
  var p#29: DatatypeType;
  var st#30: BoxType;
  var p#31: DatatypeType;
  var st#32: BoxType;
  var st'#35: BoxType;
  var p#36: DatatypeType;
  var st#37: BoxType;
  var st#38: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(736,14): initial state"} true;
    havoc arg#4;
    assume DtAlloc(arg#4, $Heap) && DtType(arg#4) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#4)))
    {
    }

    assume (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(739,5): post-state"} true;
    expr#7 := expr#0;
    args#8 := args#1;
    st#9 := st#2;
    env#10 := env#3;
    assert (forall arg#11: DatatypeType :: DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression ==> Seq#Contains(args#8, $Box(arg#11)) ==> DtRank(arg#11) < DtRank(expr#7));
    assume _module.__default.evalArgs#canCall($Heap, this, expr#0, args#1, st#2, env#3);
    assume result#6 == _module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3);
    assume _module.__default.evalArgs#canCall($Heap, this, expr#0, args#1, st#2, env#3);
    assume _module.Tuple.Pair_q(result#6);
    assume sts'#12 == $Unbox(_module.Tuple.snd(result#6)): Set BoxType;
    assume true;
    havoc st'#13;
    assume GenericAlloc(st'#13, $Heap);
    if (sts'#12[st'#13])
    {
        st#14 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
        st#15 := st'#13;
        assume _module.__default.DomSt#canCall($Heap, this, st'#13);
    }

    if ((forall st'#24: BoxType :: GenericAlloc(st'#24, $Heap) ==> sts'#12[st'#24] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#24))))
    {
        havoc st'#16;
        assume GenericAlloc(st'#16, $Heap);
        havoc p#17;
        assume DtAlloc(p#17, $Heap) && DtType(p#17) == class._module.Path;
        if (sts'#12[st'#16])
        {
            st#18 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts'#12[st'#16] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#17)])
        {
            st#19 := st'#16;
            assume _module.__default.DomSt#canCall($Heap, this, st'#16);
        }

        if (sts'#12[st'#16] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#17)] && _module.__default.DomSt($Heap, this, st'#16)[$Box(p#17)])
        {
            p#20 := p#17;
            st#21 := st#2;
            assume _module.__default.GetSt#canCall($Heap, this, p#17, st#2);
            p#22 := p#17;
            st#23 := st'#16;
            assume _module.__default.GetSt#canCall($Heap, this, p#17, st'#16);
        }
    }

    if ((forall st'#24: BoxType :: GenericAlloc(st'#24, $Heap) ==> sts'#12[st'#24] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#24))) && (forall st'#33: BoxType, p#34: DatatypeType :: GenericAlloc(st'#33, $Heap) && DtAlloc(p#34, $Heap) && DtType(p#34) == class._module.Path ==> sts'#12[st'#33] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#34)] && _module.__default.DomSt($Heap, this, st'#33)[$Box(p#34)] ==> _module.__default.GetSt($Heap, this, p#34, st#2) == _module.__default.GetSt($Heap, this, p#34, st'#33)))
    {
        havoc st'#25;
        assume GenericAlloc(st'#25, $Heap);
        havoc p#26;
        assume DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path;
        if (sts'#12[st'#25])
        {
            st#27 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts'#12[st'#25] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#26)])
        {
            st#28 := st'#25;
            assume _module.__default.DomSt#canCall($Heap, this, st'#25);
        }

        if (sts'#12[st'#25] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#26)] && _module.__default.DomSt($Heap, this, st'#25)[$Box(p#26)])
        {
            p#29 := p#26;
            st#30 := st'#25;
            assume _module.__default.Res_k#canCall($Heap, this, p#26, st'#25);
            p#31 := p#26;
            st#32 := st'#25;
            assume _module.__default.GetSt#canCall($Heap, this, p#26, st'#25);
        }
    }

    if ((forall st'#24: BoxType :: GenericAlloc(st'#24, $Heap) ==> sts'#12[st'#24] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#24))) && (forall st'#33: BoxType, p#34: DatatypeType :: GenericAlloc(st'#33, $Heap) && DtAlloc(p#34, $Heap) && DtType(p#34) == class._module.Path ==> sts'#12[st'#33] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#34)] && _module.__default.DomSt($Heap, this, st'#33)[$Box(p#34)] ==> _module.__default.GetSt($Heap, this, p#34, st#2) == _module.__default.GetSt($Heap, this, p#34, st'#33)) && (forall st'#39: BoxType, p#40: DatatypeType :: GenericAlloc(st'#39, $Heap) && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> sts'#12[st'#39] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#40)] && _module.__default.DomSt($Heap, this, st'#39)[$Box(p#40)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#40, st'#39) == _module.__default.GetSt($Heap, this, p#40, st'#39)))
    {
        havoc st'#35;
        assume GenericAlloc(st'#35, $Heap);
        havoc p#36;
        assume DtAlloc(p#36, $Heap) && DtType(p#36) == class._module.Path;
        if (sts'#12[st'#35])
        {
            st#37 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts'#12[st'#35] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#36)])
        {
            st#38 := st'#35;
            assume _module.__default.DomSt#canCall($Heap, this, st'#35);
        }

        if (sts'#12[st'#35] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#36)] && _module.__default.DomSt($Heap, this, st'#35)[$Box(p#36)])
        {
        }
    }

    assume (forall st'#41: BoxType :: GenericAlloc(st'#41, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#41] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#41))) && (forall st'#42: BoxType, p#43: DatatypeType :: GenericAlloc(st'#42, $Heap) && DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#42] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#43)] && _module.__default.DomSt($Heap, this, st'#42)[$Box(p#43)] ==> _module.__default.GetSt($Heap, this, p#43, st#2) == _module.__default.GetSt($Heap, this, p#43, st'#42)) && (forall st'#44: BoxType, p#45: DatatypeType :: GenericAlloc(st'#44, $Heap) && DtAlloc(p#45, $Heap) && DtType(p#45) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#44] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#45)] && _module.__default.DomSt($Heap, this, st'#44)[$Box(p#45)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#45, st'#44) == _module.__default.GetSt($Heap, this, p#45, st'#44)) && (forall st'#46: BoxType, p#47: DatatypeType :: GenericAlloc(st'#46, $Heap) && DtAlloc(p#47, $Heap) && DtType(p#47) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#46] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#47)] && _module.__default.DomSt($Heap, this, st'#46)[$Box(p#47)] ==> _module.Path.OpaquePath_q(p#47));
}



procedure InterModuleCall$$_module.__default.EvalArgsLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap));
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st'#48: BoxType :: GenericAlloc(st'#48, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#48] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#48)));
  ensures (forall st'#49: BoxType, p#50: DatatypeType :: GenericAlloc(st'#49, $Heap) && DtAlloc(p#50, $Heap) && DtType(p#50) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#49] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#50)] && _module.__default.DomSt($Heap, this, st'#49)[$Box(p#50)] ==> _module.__default.GetSt($Heap, this, p#50, st#2) == _module.__default.GetSt($Heap, this, p#50, st'#49));
  ensures (forall st'#53: BoxType, p#52: DatatypeType :: GenericAlloc(st'#53, $Heap) && DtAlloc(p#52, $Heap) && DtType(p#52) == class._module.Path && (forall p$ih#1#51: DatatypeType :: DtAlloc(p$ih#1#51, $Heap) && DtType(p$ih#1#51) == class._module.Path ==> DtRank(p$ih#1#51) < DtRank(p#52) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#53] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#1#51)] && _module.__default.DomSt($Heap, this, st'#53)[$Box(p$ih#1#51)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#1#51, st'#53) == _module.__default.GetSt($Heap, this, p$ih#1#51, st'#53)) && true && (exists a0#2: int :: #_module.Path.OpaquePath(a0#2) == p#52) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#53] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#52)] && _module.__default.DomSt($Heap, this, st'#53)[$Box(p#52)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#52, st'#53) == _module.__default.GetSt($Heap, this, p#52, st'#53));
  ensures (forall st'#53: BoxType, p#52: DatatypeType :: GenericAlloc(st'#53, $Heap) && DtAlloc(p#52, $Heap) && DtType(p#52) == class._module.Path && (forall p$ih#1#51: DatatypeType :: DtAlloc(p$ih#1#51, $Heap) && DtType(p$ih#1#51) == class._module.Path ==> DtRank(p$ih#1#51) < DtRank(p#52) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#53] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#1#51)] && _module.__default.DomSt($Heap, this, st'#53)[$Box(p$ih#1#51)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#1#51, st'#53) == _module.__default.GetSt($Heap, this, p$ih#1#51, st'#53)) && true && (exists a0#3: int :: #_module.Path.TransparentPath(a0#3) == p#52) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#53] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#52)] && _module.__default.DomSt($Heap, this, st'#53)[$Box(p#52)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#52, st'#53) == _module.__default.GetSt($Heap, this, p#52, st'#53));
  free ensures (forall st'#53: BoxType, p#52: DatatypeType :: GenericAlloc(st'#53, $Heap) && DtAlloc(p#52, $Heap) && DtType(p#52) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#53] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#52)] && _module.__default.DomSt($Heap, this, st'#53)[$Box(p#52)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#52, st'#53) == _module.__default.GetSt($Heap, this, p#52, st'#53));
  ensures (forall st'#54: BoxType, p#55: DatatypeType :: GenericAlloc(st'#54, $Heap) && DtAlloc(p#55, $Heap) && DtType(p#55) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#54] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#55)] && _module.__default.DomSt($Heap, this, st'#54)[$Box(p#55)] ==> _module.Path.OpaquePath_q(p#55));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalArgsLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#4: int :: { Seq#Index(args#1, $i#4) } 0 <= $i#4 && $i#4 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#4)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#4)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap));
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st'#56: BoxType :: GenericAlloc(st'#56, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#56] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#56)));
  ensures (forall st'#57: BoxType, p#58: DatatypeType :: GenericAlloc(st'#57, $Heap) && DtAlloc(p#58, $Heap) && DtType(p#58) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#57] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#58)] && _module.__default.DomSt($Heap, this, st'#57)[$Box(p#58)] ==> _module.__default.GetSt($Heap, this, p#58, st#2) == _module.__default.GetSt($Heap, this, p#58, st'#57));
  ensures (forall st'#61: BoxType, p#60: DatatypeType :: GenericAlloc(st'#61, $Heap) && DtAlloc(p#60, $Heap) && DtType(p#60) == class._module.Path && (forall p$ih#5#59: DatatypeType :: DtAlloc(p$ih#5#59, $Heap) && DtType(p$ih#5#59) == class._module.Path ==> DtRank(p$ih#5#59) < DtRank(p#60) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#61] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#5#59)] && _module.__default.DomSt($Heap, this, st'#61)[$Box(p$ih#5#59)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#5#59, st'#61) == _module.__default.GetSt($Heap, this, p$ih#5#59, st'#61)) && true && (exists a0#6: int :: #_module.Path.OpaquePath(a0#6) == p#60) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#61] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#60)] && _module.__default.DomSt($Heap, this, st'#61)[$Box(p#60)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#60, st'#61) == _module.__default.GetSt($Heap, this, p#60, st'#61));
  ensures (forall st'#61: BoxType, p#60: DatatypeType :: GenericAlloc(st'#61, $Heap) && DtAlloc(p#60, $Heap) && DtType(p#60) == class._module.Path && (forall p$ih#5#59: DatatypeType :: DtAlloc(p$ih#5#59, $Heap) && DtType(p$ih#5#59) == class._module.Path ==> DtRank(p$ih#5#59) < DtRank(p#60) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#61] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#5#59)] && _module.__default.DomSt($Heap, this, st'#61)[$Box(p$ih#5#59)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#5#59, st'#61) == _module.__default.GetSt($Heap, this, p$ih#5#59, st'#61)) && true && (exists a0#7: int :: #_module.Path.TransparentPath(a0#7) == p#60) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#61] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#60)] && _module.__default.DomSt($Heap, this, st'#61)[$Box(p#60)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#60, st'#61) == _module.__default.GetSt($Heap, this, p#60, st'#61));
  free ensures (forall st'#61: BoxType, p#60: DatatypeType :: GenericAlloc(st'#61, $Heap) && DtAlloc(p#60, $Heap) && DtType(p#60) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#61] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#60)] && _module.__default.DomSt($Heap, this, st'#61)[$Box(p#60)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#60, st'#61) == _module.__default.GetSt($Heap, this, p#60, st'#61));
  ensures (forall st'#62: BoxType, p#63: DatatypeType :: GenericAlloc(st'#62, $Heap) && DtAlloc(p#63, $Heap) && DtType(p#63) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#62] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#63)] && _module.__default.DomSt($Heap, this, st'#62)[$Box(p#63)] ==> _module.Path.OpaquePath_q(p#63));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalArgsLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#8: int :: { Seq#Index(args#1, $i#8) } 0 <= $i#8 && $i#8 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#8)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#8)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st'#64: BoxType :: GenericAlloc(st'#64, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#64] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#64)));
  ensures (forall st'#65: BoxType, p#66: DatatypeType :: GenericAlloc(st'#65, $Heap) && DtAlloc(p#66, $Heap) && DtType(p#66) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#65] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#66)] && _module.__default.DomSt($Heap, this, st'#65)[$Box(p#66)] ==> _module.__default.GetSt($Heap, this, p#66, st#2) == _module.__default.GetSt($Heap, this, p#66, st'#65));
  ensures (forall st'#69: BoxType, p#68: DatatypeType :: GenericAlloc(st'#69, $Heap) && DtAlloc(p#68, $Heap) && DtType(p#68) == class._module.Path && (forall p$ih#9#67: DatatypeType :: DtAlloc(p$ih#9#67, $Heap) && DtType(p$ih#9#67) == class._module.Path ==> DtRank(p$ih#9#67) < DtRank(p#68) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#9#67)] && _module.__default.DomSt($Heap, this, st'#69)[$Box(p$ih#9#67)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#9#67, st'#69) == _module.__default.GetSt($Heap, this, p$ih#9#67, st'#69)) && true && (exists a0#10: int :: #_module.Path.OpaquePath(a0#10) == p#68) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#68)] && _module.__default.DomSt($Heap, this, st'#69)[$Box(p#68)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#68, st'#69) == _module.__default.GetSt($Heap, this, p#68, st'#69));
  ensures (forall st'#69: BoxType, p#68: DatatypeType :: GenericAlloc(st'#69, $Heap) && DtAlloc(p#68, $Heap) && DtType(p#68) == class._module.Path && (forall p$ih#9#67: DatatypeType :: DtAlloc(p$ih#9#67, $Heap) && DtType(p$ih#9#67) == class._module.Path ==> DtRank(p$ih#9#67) < DtRank(p#68) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#9#67)] && _module.__default.DomSt($Heap, this, st'#69)[$Box(p$ih#9#67)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#9#67, st'#69) == _module.__default.GetSt($Heap, this, p$ih#9#67, st'#69)) && true && (exists a0#11: int :: #_module.Path.TransparentPath(a0#11) == p#68) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#68)] && _module.__default.DomSt($Heap, this, st'#69)[$Box(p#68)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#68, st'#69) == _module.__default.GetSt($Heap, this, p#68, st'#69));
  free ensures (forall st'#69: BoxType, p#68: DatatypeType :: GenericAlloc(st'#69, $Heap) && DtAlloc(p#68, $Heap) && DtType(p#68) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#68)] && _module.__default.DomSt($Heap, this, st'#69)[$Box(p#68)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#68, st'#69) == _module.__default.GetSt($Heap, this, p#68, st'#69));
  ensures (forall st'#70: BoxType, p#71: DatatypeType :: GenericAlloc(st'#70, $Heap) && DtAlloc(p#71, $Heap) && DtType(p#71) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3))): Set BoxType)[st'#70] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#71)] && _module.__default.DomSt($Heap, this, st'#70)[$Box(p#71)] ==> _module.Path.OpaquePath_q(p#71));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.EvalArgsLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#14: HeapType;
  var expr##82: DatatypeType;
  var args##83: Seq BoxType;
  var st##84: BoxType;
  var env##85: BoxType;
  var args'##86: Seq BoxType;
  var sts'##87: Set BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(736,14): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    $initHeapForallStmt#14 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#14 == $Heap;
    assume (forall $ih#expr12#72: DatatypeType, $ih#args13#73: Seq BoxType :: DtAlloc($ih#expr12#72, $initHeapForallStmt#14) && DtType($ih#expr12#72) == class._module.Expression && (forall $i#15: int :: { Seq#Index($ih#args13#73, $i#15) } 0 <= $i#15 && $i#15 < Seq#Length($ih#args13#73) ==> DtAlloc($Unbox(Seq#Index($ih#args13#73, $i#15)): DatatypeType, $initHeapForallStmt#14) && DtType($Unbox(Seq#Index($ih#args13#73, $i#15)): DatatypeType) == class._module.Expression) && (forall arg#74: DatatypeType :: DtAlloc(arg#74, $initHeapForallStmt#14) && DtType(arg#74) == class._module.Expression ==> Seq#Contains($ih#args13#73, $Box(arg#74)) ==> DtRank(arg#74) < DtRank($ih#expr12#72)) && (DtRank($ih#expr12#72) < DtRank(expr#0) || (DtRank($ih#expr12#72) == DtRank(expr#0) && 0 <= Seq#Length($ih#args13#73) + 1 && Seq#Length($ih#args13#73) + 1 < Seq#Length(args#1) + 1)) ==> (forall st'#75: BoxType :: GenericAlloc(st'#75, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, $ih#expr12#72, $ih#args13#73, st#2, env#3))): Set BoxType)[st'#75] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#75))) && (forall st'#76: BoxType, p#77: DatatypeType :: GenericAlloc(st'#76, $Heap) && DtAlloc(p#77, $Heap) && DtType(p#77) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, $ih#expr12#72, $ih#args13#73, st#2, env#3))): Set BoxType)[st'#76] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#77)] && _module.__default.DomSt($Heap, this, st'#76)[$Box(p#77)] ==> _module.__default.GetSt($Heap, this, p#77, st#2) == _module.__default.GetSt($Heap, this, p#77, st'#76)) && (forall st'#78: BoxType, p#79: DatatypeType :: GenericAlloc(st'#78, $Heap) && DtAlloc(p#79, $Heap) && DtType(p#79) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, $ih#expr12#72, $ih#args13#73, st#2, env#3))): Set BoxType)[st'#78] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#79)] && _module.__default.DomSt($Heap, this, st'#78)[$Box(p#79)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#79, st'#78) == _module.__default.GetSt($Heap, this, p#79, st'#78)) && (forall st'#80: BoxType, p#81: DatatypeType :: GenericAlloc(st'#80, $Heap) && DtAlloc(p#81, $Heap) && DtType(p#81) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs($LS($LZ), $Heap, this, $ih#expr12#72, $ih#args13#73, st#2, env#3))): Set BoxType)[st'#80] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#81)] && _module.__default.DomSt($Heap, this, st'#80)[$Box(p#81)] ==> _module.Path.OpaquePath_q(p#81)));
    $_reverifyPost := false;
    // ----- call statement ----- CachedBuilds0.dfy(750,3)
    assume true;
    expr##82 := expr#0;
    assume true;
    args##83 := args#1;
    assume true;
    st##84 := st#2;
    assume true;
    env##85 := env#3;
    assume true;
    args'##86 := Seq#Empty(): Seq BoxType;
    assume true;
    sts'##87 := Set#Empty(): Set BoxType;
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    assert 0 <= Seq#Length(args#1) + 1 || DtRank(expr##82) < DtRank(expr#0) || Seq#Length(args##83) == Seq#Length(args#1) + 1;
    assert DtRank(expr##82) < DtRank(expr#0) || (DtRank(expr##82) == DtRank(expr#0) && Seq#Length(args##83) < Seq#Length(args#1) + 1);
    call IntraModuleCall$$_module.__default.EvalArgs_kLemma(this, expr##82, args##83, st##84, env##85, args'##86, sts'##87);
    assume {:captureState "CachedBuilds0.dfy(750,3)"} true;
}



procedure CheckWellformed$$_module.__default.EvalArgs_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#1: int :: { Seq#Index(args'#4, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType) == class._module.Expression), sts'#5: Set BoxType where (forall $t#2: BoxType :: { sts'#5[$t#2] } sts'#5[$t#2] ==> GenericAlloc($t#2, $Heap)));
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.EvalArgs_kLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#6: DatatypeType;
  var st'#8: BoxType;
  var st#9: BoxType;
  var st#10: BoxType;
  var st'#12: BoxType;
  var p#13: DatatypeType;
  var st#14: BoxType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var st'#22: BoxType;
  var p#23: DatatypeType;
  var st#24: BoxType;
  var st#25: BoxType;
  var p#26: DatatypeType;
  var st#27: BoxType;
  var p#28: DatatypeType;
  var st#29: BoxType;
  var st'#32: BoxType;
  var p#33: DatatypeType;
  var st#34: BoxType;
  var st#35: BoxType;
  var result#38: DatatypeType;
  var expr#39: DatatypeType;
  var args#40: Seq BoxType;
  var st#41: BoxType;
  var env#42: BoxType;
  var args'#43: Seq BoxType;
  var sts'#44: Set BoxType;
  var sts''#46: Set BoxType;
  var st''#47: BoxType;
  var st#48: BoxType;
  var st#49: BoxType;
  var st''#50: BoxType;
  var p#51: DatatypeType;
  var st#52: BoxType;
  var st#53: BoxType;
  var p#54: DatatypeType;
  var st#55: BoxType;
  var p#56: DatatypeType;
  var st#57: BoxType;
  var st''#59: BoxType;
  var p#60: DatatypeType;
  var st#61: BoxType;
  var st#62: BoxType;
  var p#63: DatatypeType;
  var st#64: BoxType;
  var p#65: DatatypeType;
  var st#66: BoxType;
  var st''#69: BoxType;
  var p#70: DatatypeType;
  var st#71: BoxType;
  var st#72: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(753,14): initial state"} true;
    havoc arg#6;
    assume DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#6)))
    {
    }

    assume (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
    havoc st'#8;
    assume GenericAlloc(st'#8, $Heap);
    if (sts'#5[st'#8])
    {
        st#9 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
        st#10 := st'#8;
        assume _module.__default.DomSt#canCall($Heap, this, st'#8);
    }

    assume (forall st'#11: BoxType :: GenericAlloc(st'#11, $Heap) ==> sts'#5[st'#11] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#11)));
    havoc st'#12;
    assume GenericAlloc(st'#12, $Heap);
    havoc p#13;
    assume DtAlloc(p#13, $Heap) && DtType(p#13) == class._module.Path;
    if (sts'#5[st'#12])
    {
        st#14 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
    }

    if (sts'#5[st'#12] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#13)])
    {
        st#15 := st'#12;
        assume _module.__default.DomSt#canCall($Heap, this, st'#12);
    }

    if (sts'#5[st'#12] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#13)] && _module.__default.DomSt($Heap, this, st'#12)[$Box(p#13)])
    {
        p#16 := p#13;
        st#17 := st#2;
        assume _module.__default.GetSt#canCall($Heap, this, p#13, st#2);
        p#18 := p#13;
        st#19 := st'#12;
        assume _module.__default.GetSt#canCall($Heap, this, p#13, st'#12);
    }

    assume (forall st'#20: BoxType, p#21: DatatypeType :: GenericAlloc(st'#20, $Heap) && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> sts'#5[st'#20] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#21)] && _module.__default.DomSt($Heap, this, st'#20)[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, st#2) == _module.__default.GetSt($Heap, this, p#21, st'#20));
    havoc st'#22;
    assume GenericAlloc(st'#22, $Heap);
    havoc p#23;
    assume DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path;
    if (sts'#5[st'#22])
    {
        st#24 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
    }

    if (sts'#5[st'#22] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#23)])
    {
        st#25 := st'#22;
        assume _module.__default.DomSt#canCall($Heap, this, st'#22);
    }

    if (sts'#5[st'#22] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#23)] && _module.__default.DomSt($Heap, this, st'#22)[$Box(p#23)])
    {
        p#26 := p#23;
        st#27 := st'#22;
        assume _module.__default.Res_k#canCall($Heap, this, p#23, st'#22);
        p#28 := p#23;
        st#29 := st'#22;
        assume _module.__default.GetSt#canCall($Heap, this, p#23, st'#22);
    }

    assume (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
    havoc st'#32;
    assume GenericAlloc(st'#32, $Heap);
    havoc p#33;
    assume DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path;
    if (sts'#5[st'#32])
    {
        st#34 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
    }

    if (sts'#5[st'#32] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#33)])
    {
        st#35 := st'#32;
        assume _module.__default.DomSt#canCall($Heap, this, st'#32);
    }

    if (sts'#5[st'#32] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#33)] && _module.__default.DomSt($Heap, this, st'#32)[$Box(p#33)])
    {
    }

    assume (forall st'#36: BoxType, p#37: DatatypeType :: GenericAlloc(st'#36, $Heap) && DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> sts'#5[st'#36] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#37)] && _module.__default.DomSt($Heap, this, st'#36)[$Box(p#37)] ==> _module.Path.OpaquePath_q(p#37));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(763,5): post-state"} true;
    expr#39 := expr#0;
    args#40 := args#1;
    st#41 := st#2;
    env#42 := env#3;
    args'#43 := args'#4;
    sts'#44 := sts'#5;
    assert (forall arg#45: DatatypeType :: DtAlloc(arg#45, $Heap) && DtType(arg#45) == class._module.Expression ==> Seq#Contains(args#40, $Box(arg#45)) ==> DtRank(arg#45) < DtRank(expr#39));
    assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5);
    assume result#38 == _module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5);
    assume _module.__default.evalArgs_k#canCall($Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5);
    assume _module.Tuple.Pair_q(result#38);
    assume sts''#46 == $Unbox(_module.Tuple.snd(result#38)): Set BoxType;
    assume true;
    havoc st''#47;
    assume GenericAlloc(st''#47, $Heap);
    if (sts''#46[st''#47])
    {
        st#48 := st#2;
        assume _module.__default.DomSt#canCall($Heap, this, st#2);
        st#49 := st''#47;
        assume _module.__default.DomSt#canCall($Heap, this, st''#47);
    }

    if ((forall st''#58: BoxType :: GenericAlloc(st''#58, $Heap) ==> sts''#46[st''#58] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#58))))
    {
        havoc st''#50;
        assume GenericAlloc(st''#50, $Heap);
        havoc p#51;
        assume DtAlloc(p#51, $Heap) && DtType(p#51) == class._module.Path;
        if (sts''#46[st''#50])
        {
            st#52 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts''#46[st''#50] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#51)])
        {
            st#53 := st''#50;
            assume _module.__default.DomSt#canCall($Heap, this, st''#50);
        }

        if (sts''#46[st''#50] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#51)] && _module.__default.DomSt($Heap, this, st''#50)[$Box(p#51)])
        {
            p#54 := p#51;
            st#55 := st#2;
            assume _module.__default.GetSt#canCall($Heap, this, p#51, st#2);
            p#56 := p#51;
            st#57 := st''#50;
            assume _module.__default.GetSt#canCall($Heap, this, p#51, st''#50);
        }
    }

    if ((forall st''#58: BoxType :: GenericAlloc(st''#58, $Heap) ==> sts''#46[st''#58] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#58))) && (forall st''#67: BoxType, p#68: DatatypeType :: GenericAlloc(st''#67, $Heap) && DtAlloc(p#68, $Heap) && DtType(p#68) == class._module.Path ==> sts''#46[st''#67] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#68)] && _module.__default.DomSt($Heap, this, st''#67)[$Box(p#68)] ==> _module.__default.GetSt($Heap, this, p#68, st#2) == _module.__default.GetSt($Heap, this, p#68, st''#67)))
    {
        havoc st''#59;
        assume GenericAlloc(st''#59, $Heap);
        havoc p#60;
        assume DtAlloc(p#60, $Heap) && DtType(p#60) == class._module.Path;
        if (sts''#46[st''#59])
        {
            st#61 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts''#46[st''#59] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#60)])
        {
            st#62 := st''#59;
            assume _module.__default.DomSt#canCall($Heap, this, st''#59);
        }

        if (sts''#46[st''#59] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#60)] && _module.__default.DomSt($Heap, this, st''#59)[$Box(p#60)])
        {
            p#63 := p#60;
            st#64 := st''#59;
            assume _module.__default.Res_k#canCall($Heap, this, p#60, st''#59);
            p#65 := p#60;
            st#66 := st''#59;
            assume _module.__default.GetSt#canCall($Heap, this, p#60, st''#59);
        }
    }

    if ((forall st''#58: BoxType :: GenericAlloc(st''#58, $Heap) ==> sts''#46[st''#58] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#58))) && (forall st''#67: BoxType, p#68: DatatypeType :: GenericAlloc(st''#67, $Heap) && DtAlloc(p#68, $Heap) && DtType(p#68) == class._module.Path ==> sts''#46[st''#67] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#68)] && _module.__default.DomSt($Heap, this, st''#67)[$Box(p#68)] ==> _module.__default.GetSt($Heap, this, p#68, st#2) == _module.__default.GetSt($Heap, this, p#68, st''#67)) && (forall st''#73: BoxType, p#74: DatatypeType :: GenericAlloc(st''#73, $Heap) && DtAlloc(p#74, $Heap) && DtType(p#74) == class._module.Path ==> sts''#46[st''#73] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#74)] && _module.__default.DomSt($Heap, this, st''#73)[$Box(p#74)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#74, st''#73) == _module.__default.GetSt($Heap, this, p#74, st''#73)))
    {
        havoc st''#69;
        assume GenericAlloc(st''#69, $Heap);
        havoc p#70;
        assume DtAlloc(p#70, $Heap) && DtType(p#70) == class._module.Path;
        if (sts''#46[st''#69])
        {
            st#71 := st#2;
            assume _module.__default.DomSt#canCall($Heap, this, st#2);
        }

        if (sts''#46[st''#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#70)])
        {
            st#72 := st''#69;
            assume _module.__default.DomSt#canCall($Heap, this, st''#69);
        }

        if (sts''#46[st''#69] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#70)] && _module.__default.DomSt($Heap, this, st''#69)[$Box(p#70)])
        {
        }
    }

    assume (forall st''#75: BoxType :: GenericAlloc(st''#75, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#75] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#75))) && (forall st''#76: BoxType, p#77: DatatypeType :: GenericAlloc(st''#76, $Heap) && DtAlloc(p#77, $Heap) && DtType(p#77) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#76] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#77)] && _module.__default.DomSt($Heap, this, st''#76)[$Box(p#77)] ==> _module.__default.GetSt($Heap, this, p#77, st#2) == _module.__default.GetSt($Heap, this, p#77, st''#76)) && (forall st''#78: BoxType, p#79: DatatypeType :: GenericAlloc(st''#78, $Heap) && DtAlloc(p#79, $Heap) && DtType(p#79) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#78] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#79)] && _module.__default.DomSt($Heap, this, st''#78)[$Box(p#79)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#79, st''#78) == _module.__default.GetSt($Heap, this, p#79, st''#78)) && (forall st''#80: BoxType, p#81: DatatypeType :: GenericAlloc(st''#80, $Heap) && DtAlloc(p#81, $Heap) && DtType(p#81) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#80] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#81)] && _module.__default.DomSt($Heap, this, st''#80)[$Box(p#81)] ==> _module.Path.OpaquePath_q(p#81));
}



procedure InterModuleCall$$_module.__default.EvalArgs_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#1: int :: { Seq#Index(args'#4, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType) == class._module.Expression), sts'#5: Set BoxType where (forall $t#2: BoxType :: { sts'#5[$t#2] } sts'#5[$t#2] ==> GenericAlloc($t#2, $Heap)));
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall st'#11: BoxType :: GenericAlloc(st'#11, $Heap) ==> sts'#5[st'#11] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#11)));
  requires (forall st'#20: BoxType, p#21: DatatypeType :: GenericAlloc(st'#20, $Heap) && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> sts'#5[st'#20] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#21)] && _module.__default.DomSt($Heap, this, st'#20)[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, st#2) == _module.__default.GetSt($Heap, this, p#21, st'#20));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#3#82: DatatypeType :: DtAlloc(p$ih#3#82, $Heap) && DtType(p$ih#3#82) == class._module.Path ==> DtRank(p$ih#3#82) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#3#82)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#3#82)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#82, st'#30) == _module.__default.GetSt($Heap, this, p$ih#3#82, st'#30)) && true && (exists a0#4: int :: #_module.Path.OpaquePath(a0#4) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#3#82: DatatypeType :: DtAlloc(p$ih#3#82, $Heap) && DtType(p$ih#3#82) == class._module.Path ==> DtRank(p$ih#3#82) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#3#82)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#3#82)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#3#82, st'#30) == _module.__default.GetSt($Heap, this, p$ih#3#82, st'#30)) && true && (exists a0#5: int :: #_module.Path.TransparentPath(a0#5) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  free requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#36: BoxType, p#37: DatatypeType :: GenericAlloc(st'#36, $Heap) && DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> sts'#5[st'#36] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#37)] && _module.__default.DomSt($Heap, this, st'#36)[$Box(p#37)] ==> _module.Path.OpaquePath_q(p#37));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st''#83: BoxType :: GenericAlloc(st''#83, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#83] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#83)));
  ensures (forall st''#84: BoxType, p#85: DatatypeType :: GenericAlloc(st''#84, $Heap) && DtAlloc(p#85, $Heap) && DtType(p#85) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#84] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#85)] && _module.__default.DomSt($Heap, this, st''#84)[$Box(p#85)] ==> _module.__default.GetSt($Heap, this, p#85, st#2) == _module.__default.GetSt($Heap, this, p#85, st''#84));
  ensures (forall st''#88: BoxType, p#87: DatatypeType :: GenericAlloc(st''#88, $Heap) && DtAlloc(p#87, $Heap) && DtType(p#87) == class._module.Path && (forall p$ih#6#86: DatatypeType :: DtAlloc(p$ih#6#86, $Heap) && DtType(p$ih#6#86) == class._module.Path ==> DtRank(p$ih#6#86) < DtRank(p#87) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#88] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#6#86)] && _module.__default.DomSt($Heap, this, st''#88)[$Box(p$ih#6#86)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#86, st''#88) == _module.__default.GetSt($Heap, this, p$ih#6#86, st''#88)) && true && (exists a0#7: int :: #_module.Path.OpaquePath(a0#7) == p#87) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#88] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#87)] && _module.__default.DomSt($Heap, this, st''#88)[$Box(p#87)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#87, st''#88) == _module.__default.GetSt($Heap, this, p#87, st''#88));
  ensures (forall st''#88: BoxType, p#87: DatatypeType :: GenericAlloc(st''#88, $Heap) && DtAlloc(p#87, $Heap) && DtType(p#87) == class._module.Path && (forall p$ih#6#86: DatatypeType :: DtAlloc(p$ih#6#86, $Heap) && DtType(p$ih#6#86) == class._module.Path ==> DtRank(p$ih#6#86) < DtRank(p#87) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#88] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#6#86)] && _module.__default.DomSt($Heap, this, st''#88)[$Box(p$ih#6#86)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#6#86, st''#88) == _module.__default.GetSt($Heap, this, p$ih#6#86, st''#88)) && true && (exists a0#8: int :: #_module.Path.TransparentPath(a0#8) == p#87) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#88] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#87)] && _module.__default.DomSt($Heap, this, st''#88)[$Box(p#87)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#87, st''#88) == _module.__default.GetSt($Heap, this, p#87, st''#88));
  free ensures (forall st''#88: BoxType, p#87: DatatypeType :: GenericAlloc(st''#88, $Heap) && DtAlloc(p#87, $Heap) && DtType(p#87) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#88] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#87)] && _module.__default.DomSt($Heap, this, st''#88)[$Box(p#87)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#87, st''#88) == _module.__default.GetSt($Heap, this, p#87, st''#88));
  ensures (forall st''#89: BoxType, p#90: DatatypeType :: GenericAlloc(st''#89, $Heap) && DtAlloc(p#90, $Heap) && DtType(p#90) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#89] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#90)] && _module.__default.DomSt($Heap, this, st''#89)[$Box(p#90)] ==> _module.Path.OpaquePath_q(p#90));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalArgs_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#9: int :: { Seq#Index(args#1, $i#9) } 0 <= $i#9 && $i#9 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#9)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#9)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#10: int :: { Seq#Index(args'#4, $i#10) } 0 <= $i#10 && $i#10 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#10)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#10)): DatatypeType) == class._module.Expression), sts'#5: Set BoxType where (forall $t#11: BoxType :: { sts'#5[$t#11] } sts'#5[$t#11] ==> GenericAlloc($t#11, $Heap)));
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall st'#11: BoxType :: GenericAlloc(st'#11, $Heap) ==> sts'#5[st'#11] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#11)));
  requires (forall st'#20: BoxType, p#21: DatatypeType :: GenericAlloc(st'#20, $Heap) && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> sts'#5[st'#20] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#21)] && _module.__default.DomSt($Heap, this, st'#20)[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, st#2) == _module.__default.GetSt($Heap, this, p#21, st'#20));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#12#91: DatatypeType :: DtAlloc(p$ih#12#91, $Heap) && DtType(p$ih#12#91) == class._module.Path ==> DtRank(p$ih#12#91) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#12#91)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#12#91)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#12#91, st'#30) == _module.__default.GetSt($Heap, this, p$ih#12#91, st'#30)) && true && (exists a0#13: int :: #_module.Path.OpaquePath(a0#13) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#12#91: DatatypeType :: DtAlloc(p$ih#12#91, $Heap) && DtType(p$ih#12#91) == class._module.Path ==> DtRank(p$ih#12#91) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#12#91)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#12#91)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#12#91, st'#30) == _module.__default.GetSt($Heap, this, p$ih#12#91, st'#30)) && true && (exists a0#14: int :: #_module.Path.TransparentPath(a0#14) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  free requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#36: BoxType, p#37: DatatypeType :: GenericAlloc(st'#36, $Heap) && DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> sts'#5[st'#36] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#37)] && _module.__default.DomSt($Heap, this, st'#36)[$Box(p#37)] ==> _module.Path.OpaquePath_q(p#37));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st''#92: BoxType :: GenericAlloc(st''#92, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#92] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#92)));
  ensures (forall st''#93: BoxType, p#94: DatatypeType :: GenericAlloc(st''#93, $Heap) && DtAlloc(p#94, $Heap) && DtType(p#94) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#93] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#94)] && _module.__default.DomSt($Heap, this, st''#93)[$Box(p#94)] ==> _module.__default.GetSt($Heap, this, p#94, st#2) == _module.__default.GetSt($Heap, this, p#94, st''#93));
  ensures (forall st''#97: BoxType, p#96: DatatypeType :: GenericAlloc(st''#97, $Heap) && DtAlloc(p#96, $Heap) && DtType(p#96) == class._module.Path && (forall p$ih#15#95: DatatypeType :: DtAlloc(p$ih#15#95, $Heap) && DtType(p$ih#15#95) == class._module.Path ==> DtRank(p$ih#15#95) < DtRank(p#96) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#97] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#15#95)] && _module.__default.DomSt($Heap, this, st''#97)[$Box(p$ih#15#95)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#15#95, st''#97) == _module.__default.GetSt($Heap, this, p$ih#15#95, st''#97)) && true && (exists a0#16: int :: #_module.Path.OpaquePath(a0#16) == p#96) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#97] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#96)] && _module.__default.DomSt($Heap, this, st''#97)[$Box(p#96)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#96, st''#97) == _module.__default.GetSt($Heap, this, p#96, st''#97));
  ensures (forall st''#97: BoxType, p#96: DatatypeType :: GenericAlloc(st''#97, $Heap) && DtAlloc(p#96, $Heap) && DtType(p#96) == class._module.Path && (forall p$ih#15#95: DatatypeType :: DtAlloc(p$ih#15#95, $Heap) && DtType(p$ih#15#95) == class._module.Path ==> DtRank(p$ih#15#95) < DtRank(p#96) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#97] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#15#95)] && _module.__default.DomSt($Heap, this, st''#97)[$Box(p$ih#15#95)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#15#95, st''#97) == _module.__default.GetSt($Heap, this, p$ih#15#95, st''#97)) && true && (exists a0#17: int :: #_module.Path.TransparentPath(a0#17) == p#96) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#97] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#96)] && _module.__default.DomSt($Heap, this, st''#97)[$Box(p#96)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#96, st''#97) == _module.__default.GetSt($Heap, this, p#96, st''#97));
  free ensures (forall st''#97: BoxType, p#96: DatatypeType :: GenericAlloc(st''#97, $Heap) && DtAlloc(p#96, $Heap) && DtType(p#96) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#97] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#96)] && _module.__default.DomSt($Heap, this, st''#97)[$Box(p#96)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#96, st''#97) == _module.__default.GetSt($Heap, this, p#96, st''#97));
  ensures (forall st''#98: BoxType, p#99: DatatypeType :: GenericAlloc(st''#98, $Heap) && DtAlloc(p#99, $Heap) && DtType(p#99) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#98] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#99)] && _module.__default.DomSt($Heap, this, st''#98)[$Box(p#99)] ==> _module.Path.OpaquePath_q(p#99));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalArgs_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#18: int :: { Seq#Index(args#1, $i#18) } 0 <= $i#18 && $i#18 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#18)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#18)): DatatypeType) == class._module.Expression), st#2: BoxType where GenericAlloc(st#2, $Heap), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#19: int :: { Seq#Index(args'#4, $i#19) } 0 <= $i#19 && $i#19 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#19)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#19)): DatatypeType) == class._module.Expression), sts'#5: Set BoxType where (forall $t#20: BoxType :: { sts'#5[$t#20] } sts'#5[$t#20] ==> GenericAlloc($t#20, $Heap))) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 41 == $FunctionContextHeight;
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall st'#11: BoxType :: GenericAlloc(st'#11, $Heap) ==> sts'#5[st'#11] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st'#11)));
  requires (forall st'#20: BoxType, p#21: DatatypeType :: GenericAlloc(st'#20, $Heap) && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> sts'#5[st'#20] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#21)] && _module.__default.DomSt($Heap, this, st'#20)[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, st#2) == _module.__default.GetSt($Heap, this, p#21, st'#20));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#21#100: DatatypeType :: DtAlloc(p$ih#21#100, $Heap) && DtType(p$ih#21#100) == class._module.Path ==> DtRank(p$ih#21#100) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#21#100)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#21#100)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#21#100, st'#30) == _module.__default.GetSt($Heap, this, p$ih#21#100, st'#30)) && true && (exists a0#22: int :: #_module.Path.OpaquePath(a0#22) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path && (forall p$ih#21#100: DatatypeType :: DtAlloc(p$ih#21#100, $Heap) && DtType(p$ih#21#100) == class._module.Path ==> DtRank(p$ih#21#100) < DtRank(p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#21#100)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p$ih#21#100)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#21#100, st'#30) == _module.__default.GetSt($Heap, this, p$ih#21#100, st'#30)) && true && (exists a0#23: int :: #_module.Path.TransparentPath(a0#23) == p#31) ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  free requires (forall st'#30: BoxType, p#31: DatatypeType :: GenericAlloc(st'#30, $Heap) && DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> sts'#5[st'#30] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#31)] && _module.__default.DomSt($Heap, this, st'#30)[$Box(p#31)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#31, st'#30) == _module.__default.GetSt($Heap, this, p#31, st'#30));
  requires (forall st'#36: BoxType, p#37: DatatypeType :: GenericAlloc(st'#36, $Heap) && DtAlloc(p#37, $Heap) && DtType(p#37) == class._module.Path ==> sts'#5[st'#36] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#37)] && _module.__default.DomSt($Heap, this, st'#36)[$Box(p#37)] ==> _module.Path.OpaquePath_q(p#37));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall st''#101: BoxType :: GenericAlloc(st''#101, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#101] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#101)));
  ensures (forall st''#102: BoxType, p#103: DatatypeType :: GenericAlloc(st''#102, $Heap) && DtAlloc(p#103, $Heap) && DtType(p#103) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#102] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#103)] && _module.__default.DomSt($Heap, this, st''#102)[$Box(p#103)] ==> _module.__default.GetSt($Heap, this, p#103, st#2) == _module.__default.GetSt($Heap, this, p#103, st''#102));
  ensures (forall st''#106: BoxType, p#105: DatatypeType :: GenericAlloc(st''#106, $Heap) && DtAlloc(p#105, $Heap) && DtType(p#105) == class._module.Path && (forall p$ih#24#104: DatatypeType :: DtAlloc(p$ih#24#104, $Heap) && DtType(p$ih#24#104) == class._module.Path ==> DtRank(p$ih#24#104) < DtRank(p#105) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#106] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#24#104)] && _module.__default.DomSt($Heap, this, st''#106)[$Box(p$ih#24#104)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#24#104, st''#106) == _module.__default.GetSt($Heap, this, p$ih#24#104, st''#106)) && true && (exists a0#25: int :: #_module.Path.OpaquePath(a0#25) == p#105) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#106] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#105)] && _module.__default.DomSt($Heap, this, st''#106)[$Box(p#105)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#105, st''#106) == _module.__default.GetSt($Heap, this, p#105, st''#106));
  ensures (forall st''#106: BoxType, p#105: DatatypeType :: GenericAlloc(st''#106, $Heap) && DtAlloc(p#105, $Heap) && DtType(p#105) == class._module.Path && (forall p$ih#24#104: DatatypeType :: DtAlloc(p$ih#24#104, $Heap) && DtType(p$ih#24#104) == class._module.Path ==> DtRank(p$ih#24#104) < DtRank(p#105) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#106] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p$ih#24#104)] && _module.__default.DomSt($Heap, this, st''#106)[$Box(p$ih#24#104)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p$ih#24#104, st''#106) == _module.__default.GetSt($Heap, this, p$ih#24#104, st''#106)) && true && (exists a0#26: int :: #_module.Path.TransparentPath(a0#26) == p#105) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#106] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#105)] && _module.__default.DomSt($Heap, this, st''#106)[$Box(p#105)] ==> _module.__default.Res_k($LS($LS($LZ)), $Heap, this, p#105, st''#106) == _module.__default.GetSt($Heap, this, p#105, st''#106));
  free ensures (forall st''#106: BoxType, p#105: DatatypeType :: GenericAlloc(st''#106, $Heap) && DtAlloc(p#105, $Heap) && DtType(p#105) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#106] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#105)] && _module.__default.DomSt($Heap, this, st''#106)[$Box(p#105)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#105, st''#106) == _module.__default.GetSt($Heap, this, p#105, st''#106));
  ensures (forall st''#107: BoxType, p#108: DatatypeType :: GenericAlloc(st''#107, $Heap) && DtAlloc(p#108, $Heap) && DtType(p#108) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, expr#0, args#1, st#2, env#3, args'#4, sts'#5))): Set BoxType)[st''#107] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#108)] && _module.__default.DomSt($Heap, this, st''#107)[$Box(p#108)] ==> _module.Path.OpaquePath_q(p#108));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.EvalArgs_kLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, st#2: BoxType, env#3: BoxType, args'#4: Seq BoxType, sts'#5: Set BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#31: HeapType;
  var arg#128: DatatypeType where DtAlloc(arg#128, $Heap) && DtType(arg#128) == class._module.Expression;
  var expr##129: DatatypeType;
  var st##130: BoxType;
  var env##131: BoxType;
  var result#132: DatatypeType where DtAlloc(result#132, $Heap) && DtType(result#132) == class._module.Tuple;
  var expr#133: DatatypeType;
  var st#134: BoxType;
  var env#135: BoxType;
  var arg'#136: DatatypeType where DtAlloc(arg'#136, $Heap) && DtType(arg'#136) == class._module.Expression;
  var st'#137: BoxType where GenericAlloc(st'#137, $Heap);
  var $rhs#35: DatatypeType;
  var $rhs#36: BoxType;
  var expr##138: DatatypeType;
  var args##139: Seq BoxType;
  var st##140: BoxType;
  var env##141: BoxType;
  var args'##142: Seq BoxType;
  var sts'##143: Set BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(753,14): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    $initHeapForallStmt#31 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#31 == $Heap;
    assume (forall $ih#expr27#109: DatatypeType, $ih#args28#110: Seq BoxType, $ih#args'29#111: Seq BoxType, $ih#sts'30#112: Set BoxType :: DtAlloc($ih#expr27#109, $initHeapForallStmt#31) && DtType($ih#expr27#109) == class._module.Expression && (forall $i#32: int :: { Seq#Index($ih#args28#110, $i#32) } 0 <= $i#32 && $i#32 < Seq#Length($ih#args28#110) ==> DtAlloc($Unbox(Seq#Index($ih#args28#110, $i#32)): DatatypeType, $initHeapForallStmt#31) && DtType($Unbox(Seq#Index($ih#args28#110, $i#32)): DatatypeType) == class._module.Expression) && (forall $i#33: int :: { Seq#Index($ih#args'29#111, $i#33) } 0 <= $i#33 && $i#33 < Seq#Length($ih#args'29#111) ==> DtAlloc($Unbox(Seq#Index($ih#args'29#111, $i#33)): DatatypeType, $initHeapForallStmt#31) && DtType($Unbox(Seq#Index($ih#args'29#111, $i#33)): DatatypeType) == class._module.Expression) && (forall $t#34: BoxType :: { $ih#sts'30#112[$t#34] } $ih#sts'30#112[$t#34] ==> GenericAlloc($t#34, $initHeapForallStmt#31)) && (forall arg#113: DatatypeType :: DtAlloc(arg#113, $initHeapForallStmt#31) && DtType(arg#113) == class._module.Expression ==> Seq#Contains($ih#args28#110, $Box(arg#113)) ==> DtRank(arg#113) < DtRank($ih#expr27#109)) && (forall st'#114: BoxType :: GenericAlloc(st'#114, $initHeapForallStmt#31) ==> $ih#sts'30#112[st'#114] ==> Set#Subset(_module.__default.DomSt($initHeapForallStmt#31, this, st#2), _module.__default.DomSt($initHeapForallStmt#31, this, st'#114))) && (forall st'#115: BoxType, p#116: DatatypeType :: GenericAlloc(st'#115, $initHeapForallStmt#31) && DtAlloc(p#116, $initHeapForallStmt#31) && DtType(p#116) == class._module.Path ==> $ih#sts'30#112[st'#115] && _module.__default.DomSt($initHeapForallStmt#31, this, st#2)[$Box(p#116)] && _module.__default.DomSt($initHeapForallStmt#31, this, st'#115)[$Box(p#116)] ==> _module.__default.GetSt($initHeapForallStmt#31, this, p#116, st#2) == _module.__default.GetSt($initHeapForallStmt#31, this, p#116, st'#115)) && (forall st'#117: BoxType, p#118: DatatypeType :: GenericAlloc(st'#117, $initHeapForallStmt#31) && DtAlloc(p#118, $initHeapForallStmt#31) && DtType(p#118) == class._module.Path ==> $ih#sts'30#112[st'#117] && !_module.__default.DomSt($initHeapForallStmt#31, this, st#2)[$Box(p#118)] && _module.__default.DomSt($initHeapForallStmt#31, this, st'#117)[$Box(p#118)] ==> _module.__default.Res_k($LS($LZ), $initHeapForallStmt#31, this, p#118, st'#117) == _module.__default.GetSt($initHeapForallStmt#31, this, p#118, st'#117)) && (forall st'#119: BoxType, p#120: DatatypeType :: GenericAlloc(st'#119, $initHeapForallStmt#31) && DtAlloc(p#120, $initHeapForallStmt#31) && DtType(p#120) == class._module.Path ==> $ih#sts'30#112[st'#119] && !_module.__default.DomSt($initHeapForallStmt#31, this, st#2)[$Box(p#120)] && _module.__default.DomSt($initHeapForallStmt#31, this, st'#119)[$Box(p#120)] ==> _module.Path.OpaquePath_q(p#120)) && (DtRank($ih#expr27#109) < DtRank(expr#0) || (DtRank($ih#expr27#109) == DtRank(expr#0) && 0 <= Seq#Length($ih#args28#110) && Seq#Length($ih#args28#110) < Seq#Length(args#1))) ==> (forall st''#121: BoxType :: GenericAlloc(st''#121, $Heap) ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, $ih#expr27#109, $ih#args28#110, st#2, env#3, $ih#args'29#111, $ih#sts'30#112))): Set BoxType)[st''#121] ==> Set#Subset(_module.__default.DomSt($Heap, this, st#2), _module.__default.DomSt($Heap, this, st''#121))) && (forall st''#122: BoxType, p#123: DatatypeType :: GenericAlloc(st''#122, $Heap) && DtAlloc(p#123, $Heap) && DtType(p#123) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, $ih#expr27#109, $ih#args28#110, st#2, env#3, $ih#args'29#111, $ih#sts'30#112))): Set BoxType)[st''#122] && _module.__default.DomSt($Heap, this, st#2)[$Box(p#123)] && _module.__default.DomSt($Heap, this, st''#122)[$Box(p#123)] ==> _module.__default.GetSt($Heap, this, p#123, st#2) == _module.__default.GetSt($Heap, this, p#123, st''#122)) && (forall st''#124: BoxType, p#125: DatatypeType :: GenericAlloc(st''#124, $Heap) && DtAlloc(p#125, $Heap) && DtType(p#125) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, $ih#expr27#109, $ih#args28#110, st#2, env#3, $ih#args'29#111, $ih#sts'30#112))): Set BoxType)[st''#124] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#125)] && _module.__default.DomSt($Heap, this, st''#124)[$Box(p#125)] ==> _module.__default.Res_k($LS($LZ), $Heap, this, p#125, st''#124) == _module.__default.GetSt($Heap, this, p#125, st''#124)) && (forall st''#126: BoxType, p#127: DatatypeType :: GenericAlloc(st''#126, $Heap) && DtAlloc(p#127, $Heap) && DtType(p#127) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgs_k($LS($LZ), $Heap, this, $ih#expr27#109, $ih#args28#110, st#2, env#3, $ih#args'29#111, $ih#sts'30#112))): Set BoxType)[st''#126] && !_module.__default.DomSt($Heap, this, st#2)[$Box(p#127)] && _module.__default.DomSt($Heap, this, st''#126)[$Box(p#127)] ==> _module.Path.OpaquePath_q(p#127)));
    $_reverifyPost := false;
    // ----- if statement ----- CachedBuilds0.dfy(773,3)
    assume true;
    if (Seq#Equal(args#1, Seq#Empty(): Seq BoxType))
    {
    }
    else
    {
        // ----- var-declaration statement ----- CachedBuilds0.dfy(775,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(775,13)
        assume true;
        assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
        assume true;
        arg#128 := $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
        assume {:captureState "CachedBuilds0.dfy(775,13)"} true;
        // ----- call statement ----- CachedBuilds0.dfy(776,5)
        assume true;
        expr##129 := arg#128;
        assume true;
        st##130 := st#2;
        assume true;
        env##131 := env#3;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert DtRank(expr##129) < DtRank(expr#0);
        call IntraModuleCall$$_module.__default.EvalLemma(this, expr##129, st##130, env##131);
        assume {:captureState "CachedBuilds0.dfy(776,5)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(777,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(777,16)
        assume true;
        expr#133 := arg#128;
        st#134 := st#2;
        env#135 := env#3;
        assume _module.__default.eval#canCall($Heap, this, arg#128, st#2, env#3);
        assume _module.__default.eval#canCall($Heap, this, arg#128, st#2, env#3);
        result#132 := _module.__default.eval($LS($LZ), $Heap, this, arg#128, st#2, env#3);
        assume {:captureState "CachedBuilds0.dfy(777,16)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(778,9)
        // ----- var-declaration statement ----- CachedBuilds0.dfy(778,15)
        // ----- update statement ----- CachedBuilds0.dfy(778,19)
        assume true;
        assume true;
        assume _module.Tuple.Pair_q(result#132);
        assume true;
        $rhs#35 := $Unbox(_module.Tuple.fst(result#132)): DatatypeType;
        assume _module.Tuple.Pair_q(result#132);
        assume true;
        $rhs#36 := _module.Tuple.snd(result#132);
        arg'#136 := $rhs#35;
        st'#137 := $rhs#36;
        assume {:captureState "CachedBuilds0.dfy(778,19)"} true;
        // ----- call statement ----- CachedBuilds0.dfy(779,5)
        assume true;
        expr##138 := expr#0;
        assert 0 <= Lit(1) && Lit(1) <= Seq#Length(args#1);
        assume true;
        args##139 := Seq#Drop(args#1, Lit(1));
        assume true;
        st##140 := st#2;
        assume true;
        env##141 := env#3;
        assume true;
        args'##142 := Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#136)));
        assume true;
        sts'##143 := Set#Union(sts'#5, Set#UnionOne(Set#Empty(): Set BoxType, st'#137));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert 0 <= Seq#Length(args#1) || DtRank(expr##138) < DtRank(expr#0) || Seq#Length(args##139) == Seq#Length(args#1);
        assert DtRank(expr##138) < DtRank(expr#0) || (DtRank(expr##138) == DtRank(expr#0) && Seq#Length(args##139) < Seq#Length(args#1));
        call IntraModuleCall$$_module.__default.EvalArgs_kLemma(this, expr##138, args##139, st##140, env##141, args'##142, sts'##143);
        assume {:captureState "CachedBuilds0.dfy(779,5)"} true;
    }
}



procedure CheckWellformed$$_module.__default.BuildCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1));
  free requires 0 == $ModuleContextHeight && 46 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.BuildCLemma(this: ref, prog#0: DatatypeType, stC#1: DatatypeType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#2: Seq BoxType;
  var result#3: DatatypeType;
  var prog#4: DatatypeType;
  var stC#5: DatatypeType;
  var stC'#6: DatatypeType;
  var st#7: BoxType;
  var st#8: BoxType;
  var p#9: DatatypeType;
  var st#10: BoxType;
  var st#11: BoxType;
  var p#12: DatatypeType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var st#18: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(783,14): initial state"} true;
    assume _module.Program.Program_q(prog#0);
    stmts#2 := _module.Program.stmts(prog#0);
    assume _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0));
    assume _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(786,5): post-state"} true;
    prog#4 := prog#0;
    stC#5 := stC#1;
    assert _module.__default.Legal($Heap, this, _module.Program.stmts(prog#4));
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#1);
    assume result#3 == _module.__default.buildC($Heap, this, prog#0, stC#1);
    assume _module.__default.buildC#canCall($Heap, this, prog#0, stC#1);
    assume _module.Tuple.Pair_q(result#3);
    assume stC'#6 == $Unbox(_module.Tuple.snd(result#3)): DatatypeType;
    assume true;
    assume _module.StateC.S_q(stC#1);
    st#7 := _module.StateC.st(stC#1);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
    assume _module.StateC.S_q(stC'#6);
    st#8 := _module.StateC.st(stC'#6);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#6));
    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))))
    {
        havoc p#9;
        assume DtAlloc(p#9, $Heap) && DtType(p#9) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#10 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#9)])
        {
            assume _module.StateC.S_q(stC'#6);
            st#11 := _module.StateC.st(stC'#6);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#6));
        }

        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#9)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#9)])
        {
            assume _module.StateC.S_q(stC#1);
            p#12 := p#9;
            st#13 := _module.StateC.st(stC#1);
            assume _module.__default.GetSt#canCall($Heap, this, p#9, _module.StateC.st(stC#1));
            assume _module.StateC.S_q(stC'#6);
            p#14 := p#9;
            st#15 := _module.StateC.st(stC'#6);
            assume _module.__default.GetSt#canCall($Heap, this, p#9, _module.StateC.st(stC'#6));
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))) && (forall p#19: DatatypeType :: DtAlloc(p#19, $Heap) && DtType(p#19) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#19)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#19)] ==> _module.__default.GetSt($Heap, this, p#19, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#19, _module.StateC.st(stC'#6))))
    {
        havoc p#16;
        assume DtAlloc(p#16, $Heap) && DtType(p#16) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#17 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#16)])
        {
            assume _module.StateC.S_q(stC'#6);
            st#18 := _module.StateC.st(stC'#6);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#6));
        }

        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#16)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#6))[$Box(p#16)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))) && (forall p#20: DatatypeType :: DtAlloc(p#20, $Heap) && DtType(p#20) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#20)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#20)] ==> _module.__default.GetSt($Heap, this, p#20, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#20, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))) && (forall p#21: DatatypeType :: DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#21)] ==> _module.Path.OpaquePath_q(p#21));
}



procedure InterModuleCall$$_module.__default.BuildCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1));
  // user-defined preconditions
  requires _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#22: DatatypeType :: DtAlloc(p#22, $Heap) && DtType(p#22) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#22)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#22)] ==> _module.__default.GetSt($Heap, this, p#22, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#22, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#23: DatatypeType :: DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#23)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#23)] ==> _module.Path.OpaquePath_q(p#23));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.BuildCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1));
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#24: DatatypeType :: DtAlloc(p#24, $Heap) && DtType(p#24) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#24)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#24)] ==> _module.__default.GetSt($Heap, this, p#24, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#24, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#25)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#25)] ==> _module.Path.OpaquePath_q(p#25));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.BuildCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, prog#0: DatatypeType where DtAlloc(prog#0, $Heap) && DtType(prog#0) == class._module.Program && $IsA#_module.Program(prog#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 46 == $FunctionContextHeight;
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) && _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) && Seq#Length(_module.Program.stmts(prog#0)) != 0;
  requires _module.__default.Legal#canCall($Heap, this, _module.Program.stmts(prog#0)) ==> _module.__default.Legal($Heap, this, _module.Program.stmts(prog#0)) || Seq#Length(_module.Program.stmts(prog#0)) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#26: DatatypeType :: DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#26)] ==> _module.__default.GetSt($Heap, this, p#26, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#26, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType)));
  ensures (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.buildC($Heap, this, prog#0, stC#1))): DatatypeType))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.BuildCLemma(this: ref, prog#0: DatatypeType, stC#1: DatatypeType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts##28: Seq BoxType;
  var stC##29: DatatypeType;
  var env##30: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(783,14): initial state"} true;
    $_reverifyPost := false;
    // ----- call statement ----- CachedBuilds0.dfy(793,3)
    assume _module.Program.Program_q(prog#0);
    assume true;
    stmts##28 := _module.Program.stmts(prog#0);
    assume true;
    stC##29 := stC#1;
    assume _module.__default.EmptyEnv#canCall($Heap, this);
    assume _module.__default.EmptyEnv#canCall($Heap, this);
    env##30 := _module.__default.EmptyEnv($Heap, this);
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    call IntraModuleCall$$_module.__default.DoCLemma(this, stmts##28, stC##29, env##30);
    assume {:captureState "CachedBuilds0.dfy(793,3)"} true;
}



procedure CheckWellformed$$_module.__default.DoCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#0: int :: { Seq#Index(stmts#0, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType) == class._module.Statement), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 45 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.DoCLemma(this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var stmts#3: Seq BoxType;
  var result#4: DatatypeType;
  var stmts#5: Seq BoxType;
  var stC#6: DatatypeType;
  var env#7: BoxType;
  var stC'#8: DatatypeType;
  var st#9: BoxType;
  var st#10: BoxType;
  var p#11: DatatypeType;
  var st#12: BoxType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var st#20: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(796,14): initial state"} true;
    stmts#3 := stmts#0;
    assume _module.__default.Legal#canCall($Heap, this, stmts#0);
    assume _module.__default.Legal($Heap, this, stmts#0);
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(799,5): post-state"} true;
    stmts#5 := stmts#0;
    stC#6 := stC#1;
    env#7 := env#2;
    assert _module.__default.Legal($Heap, this, stmts#5);
    assume _module.__default.doC#canCall($Heap, this, stmts#0, stC#1, env#2);
    assume result#4 == _module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2);
    assume _module.__default.doC#canCall($Heap, this, stmts#0, stC#1, env#2);
    assume _module.Tuple.Pair_q(result#4);
    assume stC'#8 == $Unbox(_module.Tuple.snd(result#4)): DatatypeType;
    assume true;
    assume _module.StateC.S_q(stC#1);
    st#9 := _module.StateC.st(stC#1);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
    assume _module.StateC.S_q(stC'#8);
    st#10 := _module.StateC.st(stC'#8);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))))
    {
        havoc p#11;
        assume DtAlloc(p#11, $Heap) && DtType(p#11) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#12 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC'#8);
            st#13 := _module.StateC.st(stC'#8);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
        }

        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#11)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC#1);
            p#14 := p#11;
            st#15 := _module.StateC.st(stC#1);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC#1));
            assume _module.StateC.S_q(stC'#8);
            p#16 := p#11;
            st#17 := _module.StateC.st(stC'#8);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC'#8));
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))) && (forall p#21: DatatypeType :: DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#8))))
    {
        havoc p#18;
        assume DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#19 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#18)])
        {
            assume _module.StateC.S_q(stC'#8);
            st#20 := _module.StateC.st(stC'#8);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
        }

        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#18)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#18)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))) && (forall p#22: DatatypeType :: DtAlloc(p#22, $Heap) && DtType(p#22) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#22)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#22)] ==> _module.__default.GetSt($Heap, this, p#22, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#22, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))) && (forall p#23: DatatypeType :: DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#23)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#23)] ==> _module.Path.OpaquePath_q(p#23));
}



procedure InterModuleCall$$_module.__default.DoCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#0: int :: { Seq#Index(stmts#0, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#0)): DatatypeType) == class._module.Statement), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  // user-defined preconditions
  requires _module.__default.Legal($Heap, this, stmts#0);
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#24: DatatypeType :: DtAlloc(p#24, $Heap) && DtType(p#24) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#24)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#24)] ==> _module.__default.GetSt($Heap, this, p#24, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#24, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#25)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#25)] ==> _module.Path.OpaquePath_q(p#25));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.DoCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#1: int :: { Seq#Index(stmts#0, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#1)): DatatypeType) == class._module.Statement), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, stmts#0) && _module.__default.Legal($Heap, this, stmts#0) && Seq#Length(stmts#0) != 0;
  requires _module.__default.Legal#canCall($Heap, this, stmts#0) ==> _module.__default.Legal($Heap, this, stmts#0) || Seq#Length(stmts#0) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#26: DatatypeType :: DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#26)] ==> _module.__default.GetSt($Heap, this, p#26, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#26, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.DoCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, stmts#0: Seq BoxType where (forall $i#2: int :: { Seq#Index(stmts#0, $i#2) } 0 <= $i#2 && $i#2 < Seq#Length(stmts#0) ==> DtAlloc($Unbox(Seq#Index(stmts#0, $i#2)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(stmts#0, $i#2)): DatatypeType) == class._module.Statement), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 45 == $FunctionContextHeight;
  // user-defined preconditions
  free requires _module.__default.Legal#canCall($Heap, this, stmts#0) && _module.__default.Legal($Heap, this, stmts#0) && Seq#Length(stmts#0) != 0;
  requires _module.__default.Legal#canCall($Heap, this, stmts#0) ==> _module.__default.Legal($Heap, this, stmts#0) || Seq#Length(stmts#0) != 0;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#28: DatatypeType :: DtAlloc(p#28, $Heap) && DtType(p#28) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#28)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#28)] ==> _module.__default.GetSt($Heap, this, p#28, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#28, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#29)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, stmts#0, stC#1, env#2))): DatatypeType))[$Box(p#29)] ==> _module.Path.OpaquePath_q(p#29));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.DoCLemma(this: ref, stmts#0: Seq BoxType, stC#1: DatatypeType, env#2: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#5: HeapType;
  var stmt#34: DatatypeType where DtAlloc(stmt#34, $Heap) && DtType(stmt#34) == class._module.Statement;
  var expr##35: DatatypeType;
  var stC##36: DatatypeType;
  var env##37: BoxType;
  var result#38: DatatypeType where DtAlloc(result#38, $Heap) && DtType(result#38) == class._module.Tuple;
  var expr#39: DatatypeType;
  var stC#40: DatatypeType;
  var env#41: BoxType;
  var expr'#42: DatatypeType where DtAlloc(expr'#42, $Heap) && DtType(expr'#42) == class._module.Expression;
  var stC'#43: DatatypeType where DtAlloc(stC'#43, $Heap) && DtType(stC'#43) == class._module.StateC;
  var $rhs#7: DatatypeType;
  var $rhs#8: DatatypeType;
  var expr#44: DatatypeType;
  var env'#45: BoxType where GenericAlloc(env'#45, $Heap);
  var id#46: BoxType;
  var expr#47: DatatypeType;
  var env#48: BoxType;
  var stmts#49: Seq BoxType;
  var stmts##50: Seq BoxType;
  var stC##51: DatatypeType;
  var env##52: BoxType;
  var expr##53: DatatypeType;
  var stC##54: DatatypeType;
  var env##55: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(796,14): initial state"} true;
    assume $IsA#_module.StateC(stC#1);
    $initHeapForallStmt#5 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#5 == $Heap;
    assume (forall $ih#stmts3#30: Seq BoxType, $ih#stC4#31: DatatypeType :: (forall $i#6: int :: { Seq#Index($ih#stmts3#30, $i#6) } 0 <= $i#6 && $i#6 < Seq#Length($ih#stmts3#30) ==> DtAlloc($Unbox(Seq#Index($ih#stmts3#30, $i#6)): DatatypeType, $initHeapForallStmt#5) && DtType($Unbox(Seq#Index($ih#stmts3#30, $i#6)): DatatypeType) == class._module.Statement) && DtAlloc($ih#stC4#31, $initHeapForallStmt#5) && DtType($ih#stC4#31) == class._module.StateC && _module.__default.Legal($initHeapForallStmt#5, this, $ih#stmts3#30) && (Seq#Rank($ih#stmts3#30) < Seq#Rank(stmts#0) || (Seq#Rank($ih#stmts3#30) == Seq#Rank(stmts#0) && DtRank($ih#stC4#31) < DtRank(stC#1))) ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC4#31)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, $ih#stmts3#30, $ih#stC4#31, env#2))): DatatypeType))) && (forall p#32: DatatypeType :: DtAlloc(p#32, $Heap) && DtType(p#32) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC4#31))[$Box(p#32)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, $ih#stmts3#30, $ih#stC4#31, env#2))): DatatypeType))[$Box(p#32)] ==> _module.__default.GetSt($Heap, this, p#32, _module.StateC.st($ih#stC4#31)) == _module.__default.GetSt($Heap, this, p#32, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, $ih#stmts3#30, $ih#stC4#31, env#2))): DatatypeType))) && (forall p#33: DatatypeType :: DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC4#31))[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.doC($LS($LZ), $Heap, this, $ih#stmts3#30, $ih#stC4#31, env#2))): DatatypeType))[$Box(p#33)] ==> _module.Path.OpaquePath_q(p#33)));
    $_reverifyPost := false;
    // ----- var-declaration statement ----- CachedBuilds0.dfy(806,7)
    // ----- assignment statement ----- CachedBuilds0.dfy(806,12)
    assume true;
    assert 0 <= Lit(0) && Lit(0) < Seq#Length(stmts#0);
    assume true;
    stmt#34 := $Unbox(Seq#Index(stmts#0, Lit(0))): DatatypeType;
    assume {:captureState "CachedBuilds0.dfy(806,12)"} true;
    // ----- if statement ----- CachedBuilds0.dfy(807,3)
    assume true;
    if (_module.Statement.stmtVariable_q(stmt#34))
    {
        // ----- call statement ----- CachedBuilds0.dfy(808,5)
        assert _module.Statement.stmtVariable_q(stmt#34);
        assume true;
        expr##35 := _module.Statement.expr(stmt#34);
        assume true;
        stC##36 := stC#1;
        assume true;
        env##37 := env#2;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##35, stC##36, env##37);
        assume {:captureState "CachedBuilds0.dfy(808,5)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(809,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(809,16)
        assume true;
        assert _module.Statement.stmtVariable_q(stmt#34);
        expr#39 := _module.Statement.expr(stmt#34);
        stC#40 := stC#1;
        env#41 := env#2;
        assume _module.__default.evalC#canCall($Heap, this, _module.Statement.expr(stmt#34), stC#1, env#2);
        assume _module.__default.evalC#canCall($Heap, this, _module.Statement.expr(stmt#34), stC#1, env#2);
        result#38 := _module.__default.evalC($LS($LZ), $Heap, this, _module.Statement.expr(stmt#34), stC#1, env#2);
        assume {:captureState "CachedBuilds0.dfy(809,16)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(810,9)
        // ----- var-declaration statement ----- CachedBuilds0.dfy(810,16)
        // ----- update statement ----- CachedBuilds0.dfy(810,21)
        assume true;
        assume true;
        assume _module.Tuple.Pair_q(result#38);
        assume true;
        $rhs#7 := $Unbox(_module.Tuple.fst(result#38)): DatatypeType;
        assume _module.Tuple.Pair_q(result#38);
        assume true;
        $rhs#8 := $Unbox(_module.Tuple.snd(result#38)): DatatypeType;
        expr'#42 := $rhs#7;
        stC'#43 := $rhs#8;
        assume {:captureState "CachedBuilds0.dfy(810,21)"} true;
        // ----- if statement ----- CachedBuilds0.dfy(811,5)
        expr#44 := expr'#42;
        assume _module.__default.Value#canCall($Heap, this, expr'#42);
        assume _module.__default.Value#canCall($Heap, this, expr'#42);
        if (_module.__default.Value($Heap, this, expr'#42))
        {
            // ----- var-declaration statement ----- CachedBuilds0.dfy(812,11)
            // ----- assignment statement ----- CachedBuilds0.dfy(812,16)
            assume true;
            assert _module.Statement.stmtVariable_q(stmt#34);
            id#46 := _module.Statement.id(stmt#34);
            expr#47 := expr'#42;
            env#48 := env#2;
            assert _module.__default.Value($Heap, this, expr#47);
            assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#34), expr'#42, env#2);
            assume _module.__default.SetEnv#canCall($Heap, this, _module.Statement.id(stmt#34), expr'#42, env#2);
            env'#45 := _module.__default.SetEnv($Heap, this, _module.Statement.id(stmt#34), expr'#42, env#2);
            assume {:captureState "CachedBuilds0.dfy(812,16)"} true;
            // ----- if statement ----- CachedBuilds0.dfy(813,7)
            assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
            stmts#49 := Seq#Drop(stmts#0, Lit(1));
            assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
            assume _module.__default.Legal#canCall($Heap, this, Seq#Drop(stmts#0, Lit(1)));
            if (_module.__default.Legal($Heap, this, Seq#Drop(stmts#0, Lit(1))))
            {
                // ----- call statement ----- CachedBuilds0.dfy(814,9)
                assert 0 <= Lit(1) && Lit(1) <= Seq#Length(stmts#0);
                assume true;
                stmts##50 := Seq#Drop(stmts#0, Lit(1));
                assume true;
                stC##51 := stC'#43;
                assume true;
                env##52 := env'#45;
                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                assert Seq#Rank(stmts##50) < Seq#Rank(stmts#0) || (Seq#Rank(stmts##50) == Seq#Rank(stmts#0) && DtRank(stC##51) < DtRank(stC#1));
                call IntraModuleCall$$_module.__default.DoCLemma(this, stmts##50, stC##51, env##52);
                assume {:captureState "CachedBuilds0.dfy(814,9)"} true;
            }
            else
            {
            }
        }
        else
        {
        }
    }
    else
    {
        // ----- assert statement ----- CachedBuilds0.dfy(819,5)
        if (!_module.Statement.stmtVariable_q(stmt#34))
        {
        }

        assume !_module.Statement.stmtVariable_q(stmt#34) ==> true;
        assert _module.Statement.stmtVariable_q(stmt#34) || _module.Statement.stmtReturn_q(stmt#34);
        // ----- call statement ----- CachedBuilds0.dfy(820,5)
        assert _module.Statement.stmtReturn_q(stmt#34);
        assume true;
        expr##53 := _module.Statement.ret(stmt#34);
        assume true;
        stC##54 := stC#1;
        assume true;
        env##55 := env#2;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##53, stC##54, env##55);
        assume {:captureState "CachedBuilds0.dfy(820,5)"} true;
    }
}



procedure CheckWellformed$$_module.__default.EvalCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation {:induction expr#0} CheckWellformed$$_module.__default.EvalCLemma(this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var result#3: DatatypeType;
  var expr#4: DatatypeType;
  var stC#5: DatatypeType;
  var env#6: BoxType;
  var expr'#7: DatatypeType;
  var stC'#8: DatatypeType;
  var st#9: BoxType;
  var st#10: BoxType;
  var p#11: DatatypeType;
  var st#12: BoxType;
  var st#13: BoxType;
  var p#14: DatatypeType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var st#20: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(824,32): initial state"} true;
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(826,5): post-state"} true;
    expr#4 := expr#0;
    stC#5 := stC#1;
    env#6 := env#2;
    assume _module.__default.evalC#canCall($Heap, this, expr#0, stC#1, env#2);
    assume result#3 == _module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2);
    assume _module.__default.evalC#canCall($Heap, this, expr#0, stC#1, env#2);
    assume _module.Tuple.Pair_q(result#3);
    assume expr'#7 == $Unbox(_module.Tuple.fst(result#3)): DatatypeType;
    assume true;
    assume _module.Tuple.Pair_q(result#3);
    assume stC'#8 == $Unbox(_module.Tuple.snd(result#3)): DatatypeType;
    assume true;
    assume _module.StateC.S_q(stC#1);
    st#9 := _module.StateC.st(stC#1);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
    assume _module.StateC.S_q(stC'#8);
    st#10 := _module.StateC.st(stC'#8);
    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))))
    {
        havoc p#11;
        assume DtAlloc(p#11, $Heap) && DtType(p#11) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#12 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC'#8);
            st#13 := _module.StateC.st(stC'#8);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
        }

        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#11)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#11)])
        {
            assume _module.StateC.S_q(stC#1);
            p#14 := p#11;
            st#15 := _module.StateC.st(stC#1);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC#1));
            assume _module.StateC.S_q(stC'#8);
            p#16 := p#11;
            st#17 := _module.StateC.st(stC'#8);
            assume _module.__default.GetSt#canCall($Heap, this, p#11, _module.StateC.st(stC'#8));
        }
    }

    if (Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))) && (forall p#21: DatatypeType :: DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#8))))
    {
        havoc p#18;
        assume DtAlloc(p#18, $Heap) && DtType(p#18) == class._module.Path;
        assume _module.StateC.S_q(stC#1);
        st#19 := _module.StateC.st(stC#1);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#1));
        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#18)])
        {
            assume _module.StateC.S_q(stC'#8);
            st#20 := _module.StateC.st(stC'#8);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
        }

        if (!_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#18)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#8))[$Box(p#18)])
        {
        }
    }

    assume Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))) && (forall p#22: DatatypeType :: DtAlloc(p#22, $Heap) && DtType(p#22) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#22)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#22)] ==> _module.__default.GetSt($Heap, this, p#22, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#22, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))) && (forall p#23: DatatypeType :: DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#23)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#23)] ==> _module.Path.OpaquePath_q(p#23));
}



procedure InterModuleCall$$_module.__default.EvalCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#24: DatatypeType :: DtAlloc(p#24, $Heap) && DtType(p#24) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#24)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#24)] ==> _module.__default.GetSt($Heap, this, p#24, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#24, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#25: DatatypeType :: DtAlloc(p#25, $Heap) && DtType(p#25) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#25)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#25)] ==> _module.Path.OpaquePath_q(p#25));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#26: DatatypeType :: DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#26)] ==> _module.__default.GetSt($Heap, this, p#26, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#26, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#27: DatatypeType :: DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), stC#1: DatatypeType where DtAlloc(stC#1, $Heap) && DtType(stC#1) == class._module.StateC && $IsA#_module.StateC(stC#1), env#2: BoxType where GenericAlloc(env#2, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#28: DatatypeType :: DtAlloc(p#28, $Heap) && DtType(p#28) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#28)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#28)] ==> _module.__default.GetSt($Heap, this, p#28, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#28, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType)));
  ensures (forall p#29: DatatypeType :: DtAlloc(p#29, $Heap) && DtType(p#29) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#29)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, expr#0, stC#1, env#2))): DatatypeType))[$Box(p#29)] ==> _module.Path.OpaquePath_q(p#29));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation {:induction expr#0} Impl$$_module.__default.EvalCLemma(this: ref, expr#0: DatatypeType, stC#1: DatatypeType, env#2: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#1: HeapType;
  var expr#33: DatatypeType;
  var result#34: DatatypeType where DtAlloc(result#34, $Heap) && DtType(result#34) == class._module.Tuple;
  var expr#35: DatatypeType;
  var stC#36: DatatypeType;
  var env#37: BoxType;
  var cond'#38: DatatypeType where DtAlloc(cond'#38, $Heap) && DtType(cond'#38) == class._module.Expression;
  var stC'#39: DatatypeType where DtAlloc(stC'#39, $Heap) && DtType(stC'#39) == class._module.StateC;
  var $rhs#2: DatatypeType;
  var $rhs#3: DatatypeType;
  var expr##40: DatatypeType;
  var stC##41: DatatypeType;
  var env##42: BoxType;
  var expr##43: DatatypeType;
  var stC##44: DatatypeType;
  var env##45: BoxType;
  var result#46: DatatypeType where DtAlloc(result#46, $Heap) && DtType(result#46) == class._module.Tuple;
  var expr#47: DatatypeType;
  var stC#48: DatatypeType;
  var env#49: BoxType;
  var conj0'#50: DatatypeType where DtAlloc(conj0'#50, $Heap) && DtType(conj0'#50) == class._module.Expression;
  var stC'#51: DatatypeType where DtAlloc(stC'#51, $Heap) && DtType(stC'#51) == class._module.StateC;
  var $rhs#4: DatatypeType;
  var $rhs#5: DatatypeType;
  var expr##52: DatatypeType;
  var stC##53: DatatypeType;
  var env##54: BoxType;
  var result#55: DatatypeType where DtAlloc(result#55, $Heap) && DtType(result#55) == class._module.Tuple;
  var expr#56: DatatypeType;
  var stC#57: DatatypeType;
  var env#58: BoxType;
  var disj0'#59: DatatypeType where DtAlloc(disj0'#59, $Heap) && DtType(disj0'#59) == class._module.Expression;
  var stC'#60: DatatypeType where DtAlloc(stC'#60, $Heap) && DtType(stC'#60) == class._module.StateC;
  var $rhs#6: DatatypeType;
  var $rhs#7: DatatypeType;
  var expr##61: DatatypeType;
  var stC##62: DatatypeType;
  var env##63: BoxType;
  var expr##64: DatatypeType;
  var stC##65: DatatypeType;
  var env##66: BoxType;
  var resultFun#67: DatatypeType where DtAlloc(resultFun#67, $Heap) && DtType(resultFun#67) == class._module.Tuple;
  var expr#68: DatatypeType;
  var stC#69: DatatypeType;
  var env#70: BoxType;
  var fun'#71: DatatypeType where DtAlloc(fun'#71, $Heap) && DtType(fun'#71) == class._module.Expression;
  var stC'#72: DatatypeType where DtAlloc(stC'#72, $Heap) && DtType(stC'#72) == class._module.StateC;
  var $rhs#8: DatatypeType;
  var $rhs#9: DatatypeType;
  var expr##73: DatatypeType;
  var args##74: Seq BoxType;
  var stC##75: DatatypeType;
  var env##76: BoxType;
  var resultArgs#77: DatatypeType where DtAlloc(resultArgs#77, $Heap) && DtType(resultArgs#77) == class._module.Tuple;
  var expr#78: DatatypeType;
  var args#79: Seq BoxType;
  var stC#80: DatatypeType;
  var env#81: BoxType;
  var args'#83: Seq BoxType where (forall $i#10: int :: { Seq#Index(args'#83, $i#10) } 0 <= $i#10 && $i#10 < Seq#Length(args'#83) ==> DtAlloc($Unbox(Seq#Index(args'#83, $i#10)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#83, $i#10)): DatatypeType) == class._module.Expression);
  var stsC'#84: Set BoxType where (forall $t#11: BoxType :: { stsC'#84[$t#11] } stsC'#84[$t#11] ==> DtAlloc($Unbox($t#11): DatatypeType, $Heap) && DtType($Unbox($t#11): DatatypeType) == class._module.StateC);
  var $rhs#12: Seq BoxType;
  var $rhs#13: Set BoxType;
  var stsC''#85: Set BoxType where (forall $t#14: BoxType :: { stsC''#85[$t#14] } stsC''#85[$t#14] ==> DtAlloc($Unbox($t#14): DatatypeType, $Heap) && DtType($Unbox($t#14): DatatypeType) == class._module.StateC);
  var stsC#86: Set BoxType;
  var stCombinedC#87: DatatypeType where DtAlloc(stCombinedC#87, $Heap) && DtType(stCombinedC#87) == class._module.StateC;
  var stsC#88: Set BoxType;
  var prim#89: DatatypeType;
  var prim#90: DatatypeType;
  var args#91: Seq BoxType;
  var stC#92: DatatypeType;
  var cmd##93: DatatypeType;
  var deps##94: DatatypeType;
  var exts##95: DatatypeType;
  var stC##96: DatatypeType;
  var resultExec#97: DatatypeType where DtAlloc(resultExec#97, $Heap) && DtType(resultExec#97) == class._module.Tuple;
  var cmd#98: DatatypeType;
  var deps#99: DatatypeType;
  var exts#100: DatatypeType;
  var stC#101: DatatypeType;
  var stExecC#102: DatatypeType where DtAlloc(stExecC#102, $Heap) && DtType(stExecC#102) == class._module.StateC;
  var st#103: BoxType;
  var st#104: BoxType;
  var p#105: DatatypeType;
  var st#106: BoxType;
  var st#107: BoxType;
  var st#108: BoxType;
  var st#109: BoxType;
  var st#110: BoxType;
  var paths#111: Set BoxType;
  var st#112: BoxType;
  var p#113: DatatypeType;
  var st#114: BoxType;
  var p#115: DatatypeType;
  var st#116: BoxType;
  var $initHeapForallStmt#15: HeapType;
  var stC#118: DatatypeType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(824,32): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    assume $IsA#_module.StateC(stC#1);
    $initHeapForallStmt#1 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#1 == $Heap;
    assume (forall $ih#expr0#30: DatatypeType :: DtAlloc($ih#expr0#30, $initHeapForallStmt#1) && DtType($ih#expr0#30) == class._module.Expression && Lit(true) && DtRank($ih#expr0#30) < DtRank(expr#0) ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1)), _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $ih#expr0#30, stC#1, env#2))): DatatypeType))) && (forall p#31: DatatypeType :: DtAlloc(p#31, $Heap) && DtType(p#31) == class._module.Path ==> _module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#31)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $ih#expr0#30, stC#1, env#2))): DatatypeType))[$Box(p#31)] ==> _module.__default.GetSt($Heap, this, p#31, _module.StateC.st(stC#1)) == _module.__default.GetSt($Heap, this, p#31, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $ih#expr0#30, stC#1, env#2))): DatatypeType))) && (forall p#32: DatatypeType :: DtAlloc(p#32, $Heap) && DtType(p#32) == class._module.Path ==> !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#1))[$Box(p#32)] && _module.__default.DomSt($Heap, this, _module.StateC.st($Unbox(_module.Tuple.snd(_module.__default.evalC($LS($LZ), $Heap, this, $ih#expr0#30, stC#1, env#2))): DatatypeType))[$Box(p#32)] ==> _module.Path.OpaquePath_q(p#32)));
    $_reverifyPost := false;
    // ----- if statement ----- CachedBuilds0.dfy(834,3)
    expr#33 := expr#0;
    assume _module.__default.Value#canCall($Heap, this, expr#0);
    assume _module.__default.Value#canCall($Heap, this, expr#0);
    if (_module.__default.Value($Heap, this, expr#0))
    {
    }
    else
    {
        // ----- if statement ----- CachedBuilds0.dfy(835,10)
        assume true;
        if (_module.Expression.exprIdentifier_q(expr#0))
        {
        }
        else
        {
            // ----- if statement ----- CachedBuilds0.dfy(836,10)
            if (_module.Expression.exprIf_q(expr#0))
            {
                assert _module.Expression.exprIf_q(expr#0);
            }

            if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
            {
                assert _module.Expression.exprIf_q(expr#0);
                assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
            }

            assume (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true);
            if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litTrue())
            {
            }
            else
            {
                // ----- if statement ----- CachedBuilds0.dfy(837,10)
                if (_module.Expression.exprIf_q(expr#0))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                }

                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)))
                {
                    assert _module.Expression.exprIf_q(expr#0);
                    assert _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0));
                }

                assume (_module.Expression.exprIf_q(expr#0) ==> true) && (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) ==> true);
                if (_module.Expression.exprIf_q(expr#0) && _module.Expression.exprLiteral_q(_module.Expression.cond(expr#0)) && _module.Expression.lit(_module.Expression.cond(expr#0)) == #_module.Literal.litFalse())
                {
                }
                else
                {
                    // ----- if statement ----- CachedBuilds0.dfy(838,10)
                    assume true;
                    if (_module.Expression.exprIf_q(expr#0))
                    {
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(839,9)
                        // ----- assignment statement ----- CachedBuilds0.dfy(839,16)
                        assume true;
                        assert _module.Expression.exprIf_q(expr#0);
                        expr#35 := _module.Expression.cond(expr#0);
                        stC#36 := stC#1;
                        env#37 := env#2;
                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                        assume _module.__default.evalC#canCall($Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                        result#34 := _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.cond(expr#0), stC#1, env#2);
                        assume {:captureState "CachedBuilds0.dfy(839,16)"} true;
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(840,9)
                        // ----- var-declaration statement ----- CachedBuilds0.dfy(840,16)
                        // ----- update statement ----- CachedBuilds0.dfy(840,21)
                        assume true;
                        assume true;
                        assume _module.Tuple.Pair_q(result#34);
                        assume true;
                        $rhs#2 := $Unbox(_module.Tuple.fst(result#34)): DatatypeType;
                        assume _module.Tuple.Pair_q(result#34);
                        assume true;
                        $rhs#3 := $Unbox(_module.Tuple.snd(result#34)): DatatypeType;
                        cond'#38 := $rhs#2;
                        stC'#39 := $rhs#3;
                        assume {:captureState "CachedBuilds0.dfy(840,21)"} true;
                        // ----- if statement ----- CachedBuilds0.dfy(841,5)
                        if (_module.Expression.exprLiteral_q(cond'#38))
                        {
                            assert _module.Expression.exprLiteral_q(cond'#38);
                        }

                        assume _module.Expression.exprLiteral_q(cond'#38) ==> true;
                        if (_module.Expression.exprLiteral_q(cond'#38) && _module.Expression.lit(cond'#38) == #_module.Literal.litTrue())
                        {
                            // ----- call statement ----- CachedBuilds0.dfy(842,7)
                            assert _module.Expression.exprIf_q(expr#0);
                            assume true;
                            expr##40 := _module.Expression.ifTrue(expr#0);
                            assume true;
                            stC##41 := stC'#39;
                            assume true;
                            env##42 := env#2;
                            assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                            assert DtRank(expr##40) < DtRank(expr#0);
                            call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##40, stC##41, env##42);
                            assume {:captureState "CachedBuilds0.dfy(842,7)"} true;
                        }
                        else
                        {
                            // ----- if statement ----- CachedBuilds0.dfy(843,12)
                            if (_module.Expression.exprLiteral_q(cond'#38))
                            {
                                assert _module.Expression.exprLiteral_q(cond'#38);
                            }

                            assume _module.Expression.exprLiteral_q(cond'#38) ==> true;
                            if (_module.Expression.exprLiteral_q(cond'#38) && _module.Expression.lit(cond'#38) == #_module.Literal.litFalse())
                            {
                                // ----- call statement ----- CachedBuilds0.dfy(844,7)
                                assert _module.Expression.exprIf_q(expr#0);
                                assume true;
                                expr##43 := _module.Expression.ifFalse(expr#0);
                                assume true;
                                stC##44 := stC'#39;
                                assume true;
                                env##45 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr##43) < DtRank(expr#0);
                                call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##43, stC##44, env##45);
                                assume {:captureState "CachedBuilds0.dfy(844,7)"} true;
                            }
                            else
                            {
                            }
                        }
                    }
                    else
                    {
                        // ----- if statement ----- CachedBuilds0.dfy(846,10)
                        assume true;
                        if (_module.Expression.exprAnd_q(expr#0))
                        {
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(847,9)
                            // ----- assignment statement ----- CachedBuilds0.dfy(847,16)
                            assume true;
                            assert _module.Expression.exprAnd_q(expr#0);
                            expr#47 := _module.Expression.conj0(expr#0);
                            stC#48 := stC#1;
                            env#49 := env#2;
                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                            assume _module.__default.evalC#canCall($Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                            result#46 := _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.conj0(expr#0), stC#1, env#2);
                            assume {:captureState "CachedBuilds0.dfy(847,16)"} true;
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(848,9)
                            // ----- var-declaration statement ----- CachedBuilds0.dfy(848,17)
                            // ----- update statement ----- CachedBuilds0.dfy(848,22)
                            assume true;
                            assume true;
                            assume _module.Tuple.Pair_q(result#46);
                            assume true;
                            $rhs#4 := $Unbox(_module.Tuple.fst(result#46)): DatatypeType;
                            assume _module.Tuple.Pair_q(result#46);
                            assume true;
                            $rhs#5 := $Unbox(_module.Tuple.snd(result#46)): DatatypeType;
                            conj0'#50 := $rhs#4;
                            stC'#51 := $rhs#5;
                            assume {:captureState "CachedBuilds0.dfy(848,22)"} true;
                            // ----- if statement ----- CachedBuilds0.dfy(849,5)
                            if (_module.Expression.exprLiteral_q(conj0'#50))
                            {
                                assert _module.Expression.exprLiteral_q(conj0'#50);
                            }

                            assume _module.Expression.exprLiteral_q(conj0'#50) ==> true;
                            if (_module.Expression.exprLiteral_q(conj0'#50) && _module.Expression.lit(conj0'#50) == #_module.Literal.litTrue())
                            {
                                // ----- call statement ----- CachedBuilds0.dfy(850,7)
                                assert _module.Expression.exprAnd_q(expr#0);
                                assume true;
                                expr##52 := _module.Expression.conj1(expr#0);
                                assume true;
                                stC##53 := stC'#51;
                                assume true;
                                env##54 := env#2;
                                assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                assert DtRank(expr##52) < DtRank(expr#0);
                                call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##52, stC##53, env##54);
                                assume {:captureState "CachedBuilds0.dfy(850,7)"} true;
                            }
                            else
                            {
                                // ----- if statement ----- CachedBuilds0.dfy(851,12)
                                if (_module.Expression.exprLiteral_q(conj0'#50))
                                {
                                    assert _module.Expression.exprLiteral_q(conj0'#50);
                                }

                                assume _module.Expression.exprLiteral_q(conj0'#50) ==> true;
                                if (_module.Expression.exprLiteral_q(conj0'#50) && _module.Expression.lit(conj0'#50) == #_module.Literal.litFalse())
                                {
                                }
                                else
                                {
                                }
                            }
                        }
                        else
                        {
                            // ----- if statement ----- CachedBuilds0.dfy(853,10)
                            assume true;
                            if (_module.Expression.exprOr_q(expr#0))
                            {
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(854,9)
                                // ----- assignment statement ----- CachedBuilds0.dfy(854,16)
                                assume true;
                                assert _module.Expression.exprOr_q(expr#0);
                                expr#56 := _module.Expression.disj0(expr#0);
                                stC#57 := stC#1;
                                env#58 := env#2;
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                assume _module.__default.evalC#canCall($Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                result#55 := _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.disj0(expr#0), stC#1, env#2);
                                assume {:captureState "CachedBuilds0.dfy(854,16)"} true;
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(855,9)
                                // ----- var-declaration statement ----- CachedBuilds0.dfy(855,17)
                                // ----- update statement ----- CachedBuilds0.dfy(855,22)
                                assume true;
                                assume true;
                                assume _module.Tuple.Pair_q(result#55);
                                assume true;
                                $rhs#6 := $Unbox(_module.Tuple.fst(result#55)): DatatypeType;
                                assume _module.Tuple.Pair_q(result#55);
                                assume true;
                                $rhs#7 := $Unbox(_module.Tuple.snd(result#55)): DatatypeType;
                                disj0'#59 := $rhs#6;
                                stC'#60 := $rhs#7;
                                assume {:captureState "CachedBuilds0.dfy(855,22)"} true;
                                // ----- if statement ----- CachedBuilds0.dfy(856,5)
                                if (_module.Expression.exprLiteral_q(disj0'#59))
                                {
                                    assert _module.Expression.exprLiteral_q(disj0'#59);
                                }

                                assume _module.Expression.exprLiteral_q(disj0'#59) ==> true;
                                if (_module.Expression.exprLiteral_q(disj0'#59) && _module.Expression.lit(disj0'#59) == #_module.Literal.litTrue())
                                {
                                }
                                else
                                {
                                    // ----- if statement ----- CachedBuilds0.dfy(857,12)
                                    if (_module.Expression.exprLiteral_q(disj0'#59))
                                    {
                                        assert _module.Expression.exprLiteral_q(disj0'#59);
                                    }

                                    assume _module.Expression.exprLiteral_q(disj0'#59) ==> true;
                                    if (_module.Expression.exprLiteral_q(disj0'#59) && _module.Expression.lit(disj0'#59) == #_module.Literal.litFalse())
                                    {
                                        // ----- call statement ----- CachedBuilds0.dfy(858,7)
                                        assert _module.Expression.exprOr_q(expr#0);
                                        assume true;
                                        expr##61 := _module.Expression.disj1(expr#0);
                                        assume true;
                                        stC##62 := stC'#60;
                                        assume true;
                                        env##63 := env#2;
                                        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                        assert DtRank(expr##61) < DtRank(expr#0);
                                        call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##61, stC##62, env##63);
                                        assume {:captureState "CachedBuilds0.dfy(858,7)"} true;
                                    }
                                    else
                                    {
                                    }
                                }
                            }
                            else
                            {
                                // ----- if statement ----- CachedBuilds0.dfy(860,10)
                                assume true;
                                if (_module.Expression.exprInvocation_q(expr#0))
                                {
                                    // ----- call statement ----- CachedBuilds0.dfy(861,5)
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    assume true;
                                    expr##64 := _module.Expression.fun(expr#0);
                                    assume true;
                                    stC##65 := stC#1;
                                    assume true;
                                    env##66 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr##64) < DtRank(expr#0);
                                    call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##64, stC##65, env##66);
                                    assume {:captureState "CachedBuilds0.dfy(861,5)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(862,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(862,19)
                                    assume true;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    expr#68 := _module.Expression.fun(expr#0);
                                    stC#69 := stC#1;
                                    env#70 := env#2;
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                    assume _module.__default.evalC#canCall($Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                    resultFun#67 := _module.__default.evalC($LS($LZ), $Heap, this, _module.Expression.fun(expr#0), stC#1, env#2);
                                    assume {:captureState "CachedBuilds0.dfy(862,19)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(863,9)
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(863,15)
                                    // ----- update statement ----- CachedBuilds0.dfy(863,20)
                                    assume true;
                                    assume true;
                                    assume _module.Tuple.Pair_q(resultFun#67);
                                    assume true;
                                    $rhs#8 := $Unbox(_module.Tuple.fst(resultFun#67)): DatatypeType;
                                    assume _module.Tuple.Pair_q(resultFun#67);
                                    assume true;
                                    $rhs#9 := $Unbox(_module.Tuple.snd(resultFun#67)): DatatypeType;
                                    fun'#71 := $rhs#8;
                                    stC'#72 := $rhs#9;
                                    assume {:captureState "CachedBuilds0.dfy(863,20)"} true;
                                    // ----- call statement ----- CachedBuilds0.dfy(864,5)
                                    assume true;
                                    expr##73 := expr#0;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    assume true;
                                    args##74 := _module.Expression.args(expr#0);
                                    assume true;
                                    stC##75 := stC#1;
                                    assume true;
                                    env##76 := env#2;
                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                    assert DtRank(expr##73) <= DtRank(expr#0) && (DtRank(expr##73) == DtRank(expr#0) ==> true);
                                    call IntraModuleCall$$_module.__default.EvalArgsCLemma(this, expr##73, args##74, stC##75, env##76);
                                    assume {:captureState "CachedBuilds0.dfy(864,5)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(865,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(865,20)
                                    assume true;
                                    assert _module.Expression.exprInvocation_q(expr#0);
                                    expr#78 := expr#0;
                                    args#79 := _module.Expression.args(expr#0);
                                    stC#80 := stC#1;
                                    env#81 := env#2;
                                    assert (forall arg#82: DatatypeType :: DtAlloc(arg#82, $Heap) && DtType(arg#82) == class._module.Expression ==> Seq#Contains(args#79, $Box(arg#82)) ==> DtRank(arg#82) < DtRank(expr#78));
                                    assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                    assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                    resultArgs#77 := _module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, _module.Expression.args(expr#0), stC#1, env#2);
                                    assume {:captureState "CachedBuilds0.dfy(865,20)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(866,9)
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(866,16)
                                    // ----- update statement ----- CachedBuilds0.dfy(866,22)
                                    assume true;
                                    assume true;
                                    assume _module.Tuple.Pair_q(resultArgs#77);
                                    assume true;
                                    $rhs#12 := $Unbox(_module.Tuple.fst(resultArgs#77)): Seq BoxType;
                                    assume _module.Tuple.Pair_q(resultArgs#77);
                                    assume true;
                                    $rhs#13 := $Unbox(_module.Tuple.snd(resultArgs#77)): Set BoxType;
                                    args'#83 := $rhs#12;
                                    stsC'#84 := $rhs#13;
                                    assume {:captureState "CachedBuilds0.dfy(866,22)"} true;
                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(867,9)
                                    // ----- assignment statement ----- CachedBuilds0.dfy(867,16)
                                    assume true;
                                    assume true;
                                    stsC''#85 := Set#Union(Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#72)), stsC'#84);
                                    assume {:captureState "CachedBuilds0.dfy(867,16)"} true;
                                    // ----- if statement ----- CachedBuilds0.dfy(868,5)
                                    stsC#86 := stsC''#85;
                                    assume _module.__default.CompatibleC#canCall($Heap, this, stsC''#85);
                                    assume _module.__default.CompatibleC#canCall($Heap, this, stsC''#85);
                                    if (_module.__default.CompatibleC($Heap, this, stsC''#85))
                                    {
                                        // ----- var-declaration statement ----- CachedBuilds0.dfy(869,11)
                                        // ----- assignment statement ----- CachedBuilds0.dfy(869,23)
                                        assume true;
                                        stsC#88 := stsC''#85;
                                        assert !Set#Equal(stsC#88, Set#Empty(): Set BoxType);
                                        assume _module.__default.CombineC#canCall($Heap, this, stsC''#85);
                                        assume _module.__default.CombineC#canCall($Heap, this, stsC''#85);
                                        stCombinedC#87 := _module.__default.CombineC($LS($LZ), $Heap, this, stsC''#85);
                                        assume {:captureState "CachedBuilds0.dfy(869,23)"} true;
                                        // ----- if statement ----- CachedBuilds0.dfy(870,7)
                                        if (_module.Expression.exprLiteral_q(fun'#71))
                                        {
                                            assert _module.Expression.exprLiteral_q(fun'#71);
                                        }

                                        assume _module.Expression.exprLiteral_q(fun'#71) ==> true;
                                        if (_module.Expression.exprLiteral_q(fun'#71) && _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#71)))
                                        {
                                            // ----- if statement ----- CachedBuilds0.dfy(871,9)
                                            assert _module.Expression.exprLiteral_q(fun'#71);
                                            assert _module.Literal.litPrimitive_q(_module.Expression.lit(fun'#71));
                                            assume true;
                                            if (_module.Primitive.primExec_q(_module.Literal.prim(_module.Expression.lit(fun'#71))))
                                            {
                                                // ----- if statement ----- CachedBuilds0.dfy(872,11)
                                                prim#89 := #_module.Primitive.primExec();
                                                assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec());
                                                if (Seq#Length(args'#83) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()))
                                                {
                                                    prim#90 := #_module.Primitive.primExec();
                                                    args#91 := args'#83;
                                                    stC#92 := stCombinedC#87;
                                                    assert _module.Primitive.primExec_q(prim#90) ==> Seq#Length(args#91) == 3;
                                                    assert _module.Primitive.primCreatePath_q(prim#90) ==> Seq#Length(args#91) == 1;
                                                    assume _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), args'#83, stCombinedC#87);
                                                }

                                                assume _module.__default.Arity#canCall($Heap, this, #_module.Primitive.primExec()) && (Seq#Length(args'#83) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) ==> _module.__default.ValidArgsC#canCall($Heap, this, #_module.Primitive.primExec(), args'#83, stCombinedC#87));
                                                if (Seq#Length(args'#83) == _module.__default.Arity($Heap, this, #_module.Primitive.primExec()) && _module.__default.ValidArgsC($Heap, this, #_module.Primitive.primExec(), args'#83, stCombinedC#87))
                                                {
                                                    // ----- call statement ----- CachedBuilds0.dfy(873,13)
                                                    assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#83);
                                                    assume true;
                                                    cmd##93 := $Unbox(Seq#Index(args'#83, Lit(0))): DatatypeType;
                                                    assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#83);
                                                    assume true;
                                                    deps##94 := $Unbox(Seq#Index(args'#83, Lit(1))): DatatypeType;
                                                    assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#83);
                                                    assume true;
                                                    exts##95 := $Unbox(Seq#Index(args'#83, Lit(2))): DatatypeType;
                                                    assume true;
                                                    stC##96 := stCombinedC#87;
                                                    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
                                                    call IntraModuleCall$$_module.__default.ExecCProperty(this, cmd##93, deps##94, exts##95, stC##96);
                                                    assume {:captureState "CachedBuilds0.dfy(873,13)"} true;
                                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(874,17)
                                                    // ----- assignment statement ----- CachedBuilds0.dfy(874,28)
                                                    assume true;
                                                    assert 0 <= Lit(0) && Lit(0) < Seq#Length(args'#83);
                                                    assert 0 <= Lit(1) && Lit(1) < Seq#Length(args'#83);
                                                    assert 0 <= Lit(2) && Lit(2) < Seq#Length(args'#83);
                                                    cmd#98 := $Unbox(Seq#Index(args'#83, Lit(0))): DatatypeType;
                                                    deps#99 := $Unbox(Seq#Index(args'#83, Lit(1))): DatatypeType;
                                                    exts#100 := $Unbox(Seq#Index(args'#83, Lit(2))): DatatypeType;
                                                    stC#101 := stCombinedC#87;
                                                    assert _module.Expression.exprLiteral_q(cmd#98) && _module.Literal.litString_q(_module.Expression.lit(cmd#98)) && _module.Expression.exprLiteral_q(deps#99) && _module.Literal.litArrOfPaths_q(_module.Expression.lit(deps#99)) && _module.Expression.exprLiteral_q(exts#100) && _module.Literal.litArrOfStrings_q(_module.Expression.lit(exts#100));
                                                    assume _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index(args'#83, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(2))): DatatypeType, stCombinedC#87);
                                                    assume _module.__default.execC#canCall($Heap, this, $Unbox(Seq#Index(args'#83, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(2))): DatatypeType, stCombinedC#87);
                                                    resultExec#97 := _module.__default.execC($Heap, this, $Unbox(Seq#Index(args'#83, Lit(0))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(1))): DatatypeType, $Unbox(Seq#Index(args'#83, Lit(2))): DatatypeType, stCombinedC#87);
                                                    assume {:captureState "CachedBuilds0.dfy(874,28)"} true;
                                                    // ----- var-declaration statement ----- CachedBuilds0.dfy(875,17)
                                                    // ----- assignment statement ----- CachedBuilds0.dfy(875,25)
                                                    assume true;
                                                    assume _module.Tuple.Pair_q(resultExec#97);
                                                    assume true;
                                                    stExecC#102 := $Unbox(_module.Tuple.snd(resultExec#97)): DatatypeType;
                                                    assume {:captureState "CachedBuilds0.dfy(875,25)"} true;
                                                    // ----- assert statement ----- CachedBuilds0.dfy(877,13)
                                                    assume _module.StateC.S_q(stC'#72);
                                                    st#103 := _module.StateC.st(stC'#72);
                                                    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#72));
                                                    assume _module.StateC.S_q(stCombinedC#87);
                                                    st#104 := _module.StateC.st(stCombinedC#87);
                                                    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87));
                                                    assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#72)) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87));
                                                    assert Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC'#72)), _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)));
                                                    // ----- forall statement (proof) ----- CachedBuilds0.dfy(878,13)
                                                    if (*)
                                                    {
                                                        havoc p#105;
                                                        assume DtAlloc(p#105, $Heap) && DtType(p#105) == class._module.Path;
                                                        assume _module.StateC.S_q(stCombinedC#87);
                                                        st#106 := _module.StateC.st(stCombinedC#87);
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87));
                                                        if (_module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87))[$Box(p#105)])
                                                        {
                                                            assume _module.StateC.S_q(stExecC#102);
                                                            st#107 := _module.StateC.st(stExecC#102);
                                                            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stExecC#102));
                                                        }

                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87)) && (_module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87))[$Box(p#105)] ==> _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stExecC#102)));
                                                        assume _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87))[$Box(p#105)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stExecC#102))[$Box(p#105)];
                                                        // ----- assert statement ----- CachedBuilds0.dfy(881,15)
                                                        assume _module.StateC.S_q(stCombinedC#87);
                                                        st#108 := _module.StateC.st(stCombinedC#87);
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87));
                                                        assume _module.StateC.S_q(stExecC#102);
                                                        st#109 := _module.StateC.st(stExecC#102);
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stExecC#102));
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87)) && _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stExecC#102));
                                                        assert Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)), _module.__default.DomSt($Heap, this, _module.StateC.st(stExecC#102)));
                                                        // ----- assert statement ----- CachedBuilds0.dfy(882,15)
                                                        assume _module.StateC.S_q(stCombinedC#87);
                                                        assume _module.StateC.S_q(stCombinedC#87);
                                                        st#110 := _module.StateC.st(stCombinedC#87);
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87));
                                                        assume _module.StateC.S_q(stExecC#102);
                                                        paths#111 := _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87));
                                                        st#112 := _module.StateC.st(stExecC#102);
                                                        assert {:subsumption 0} Set#Subset(paths#111, _module.__default.DomSt($Heap, this, st#112));
                                                        assume _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)), _module.StateC.st(stExecC#102));
                                                        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stCombinedC#87)) && _module.__default.Restrict#canCall($Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)), _module.StateC.st(stExecC#102));
                                                        assert {:subsumption 0} _module.StateC.st(stCombinedC#87) == _module.__default.Restrict($LS($LS($LZ)), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)), _module.StateC.st(stExecC#102));
                                                        assume _module.StateC.st(stCombinedC#87) == _module.__default.Restrict($LS($LZ), $Heap, this, _module.__default.DomSt($Heap, this, _module.StateC.st(stCombinedC#87)), _module.StateC.st(stExecC#102));
                                                        assume _module.StateC.S_q(stCombinedC#87);
                                                        p#113 := p#105;
                                                        st#114 := _module.StateC.st(stCombinedC#87);
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#105, _module.StateC.st(stCombinedC#87));
                                                        assume _module.StateC.S_q(stExecC#102);
                                                        p#115 := p#105;
                                                        st#116 := _module.StateC.st(stExecC#102);
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#105, _module.StateC.st(stExecC#102));
                                                        assume _module.__default.GetSt#canCall($Heap, this, p#105, _module.StateC.st(stCombinedC#87)) && _module.__default.GetSt#canCall($Heap, this, p#105, _module.StateC.st(stExecC#102));
                                                        assert _module.__default.GetSt($Heap, this, p#105, _module.StateC.st(stCombinedC#87)) == _module.__default.GetSt($Heap, this, p#105, _module.StateC.st(stExecC#102));
                                                        assume false;
                                                    }
                                                    else
                                                    {
                                                        $initHeapForallStmt#15 := $Heap;
                                                        havoc $Heap, $Tick;
                                                        assume $initHeapForallStmt#15 == $Heap;
                                                        assume (forall p#117: DatatypeType :: DtAlloc(p#117, $initHeapForallStmt#15) && DtType(p#117) == class._module.Path && _module.__default.DomSt($initHeapForallStmt#15, this, _module.StateC.st(stCombinedC#87))[$Box(p#117)] && _module.__default.DomSt($initHeapForallStmt#15, this, _module.StateC.st(stExecC#102))[$Box(p#117)] ==> _module.__default.GetSt($Heap, this, p#117, _module.StateC.st(stCombinedC#87)) == _module.__default.GetSt($Heap, this, p#117, _module.StateC.st(stExecC#102)));
                                                    }

                                                    assume {:captureState "CachedBuilds0.dfy(878,13)"} true;
                                                }
                                                else
                                                {
                                                    // ----- if statement ----- CachedBuilds0.dfy(885,13)
                                                    stC#118 := stCombinedC#87;
                                                    assume _module.__default.ConsistentCache#canCall($Heap, this, stCombinedC#87);
                                                    assume _module.__default.ConsistentCache#canCall($Heap, this, stCombinedC#87);
                                                    if (_module.__default.ConsistentCache($Heap, this, stCombinedC#87))
                                                    {
                                                    }
                                                    else
                                                    {
                                                    }
                                                }
                                            }
                                            else
                                            {
                                            }
                                        }
                                        else
                                        {
                                        }
                                    }
                                    else
                                    {
                                    }
                                }
                                else
                                {
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



procedure CheckWellformed$$_module.__default.EvalArgsCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap));
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.EvalArgsCLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#4: DatatypeType;
  var result#6: DatatypeType;
  var expr#7: DatatypeType;
  var args#8: Seq BoxType;
  var stC#9: DatatypeType;
  var env#10: BoxType;
  var stsC'#12: Set BoxType;
  var stC'#13: DatatypeType;
  var st#14: BoxType;
  var st#15: BoxType;
  var stC'#16: DatatypeType;
  var p#17: DatatypeType;
  var st#18: BoxType;
  var st#19: BoxType;
  var p#20: DatatypeType;
  var st#21: BoxType;
  var p#22: DatatypeType;
  var st#23: BoxType;
  var stC'#25: DatatypeType;
  var p#26: DatatypeType;
  var st#27: BoxType;
  var st#28: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(894,14): initial state"} true;
    havoc arg#4;
    assume DtAlloc(arg#4, $Heap) && DtType(arg#4) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#4)))
    {
    }

    assume (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(897,5): post-state"} true;
    expr#7 := expr#0;
    args#8 := args#1;
    stC#9 := stC#2;
    env#10 := env#3;
    assert (forall arg#11: DatatypeType :: DtAlloc(arg#11, $Heap) && DtType(arg#11) == class._module.Expression ==> Seq#Contains(args#8, $Box(arg#11)) ==> DtRank(arg#11) < DtRank(expr#7));
    assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, args#1, stC#2, env#3);
    assume result#6 == _module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3);
    assume _module.__default.evalArgsC#canCall($Heap, this, expr#0, args#1, stC#2, env#3);
    assume _module.Tuple.Pair_q(result#6);
    assume stsC'#12 == $Unbox(_module.Tuple.snd(result#6)): Set BoxType;
    assume true;
    havoc stC'#13;
    assume DtAlloc(stC'#13, $Heap) && DtType(stC'#13) == class._module.StateC;
    if (stsC'#12[$Box(stC'#13)])
    {
        assume _module.StateC.S_q(stC#2);
        st#14 := _module.StateC.st(stC#2);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        assume _module.StateC.S_q(stC'#13);
        st#15 := _module.StateC.st(stC'#13);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#13));
    }

    if ((forall stC'#24: DatatypeType :: DtAlloc(stC'#24, $Heap) && DtType(stC'#24) == class._module.StateC ==> stsC'#12[$Box(stC'#24)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#24)))))
    {
        havoc stC'#16;
        assume DtAlloc(stC'#16, $Heap) && DtType(stC'#16) == class._module.StateC;
        havoc p#17;
        assume DtAlloc(p#17, $Heap) && DtType(p#17) == class._module.Path;
        if (stsC'#12[$Box(stC'#16)])
        {
            assume _module.StateC.S_q(stC#2);
            st#18 := _module.StateC.st(stC#2);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        }

        if (stsC'#12[$Box(stC'#16)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#17)])
        {
            assume _module.StateC.S_q(stC'#16);
            st#19 := _module.StateC.st(stC'#16);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#16));
        }

        if (stsC'#12[$Box(stC'#16)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#17)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#16))[$Box(p#17)])
        {
            assume _module.StateC.S_q(stC#2);
            p#20 := p#17;
            st#21 := _module.StateC.st(stC#2);
            assume _module.__default.GetSt#canCall($Heap, this, p#17, _module.StateC.st(stC#2));
            assume _module.StateC.S_q(stC'#16);
            p#22 := p#17;
            st#23 := _module.StateC.st(stC'#16);
            assume _module.__default.GetSt#canCall($Heap, this, p#17, _module.StateC.st(stC'#16));
        }
    }

    if ((forall stC'#24: DatatypeType :: DtAlloc(stC'#24, $Heap) && DtType(stC'#24) == class._module.StateC ==> stsC'#12[$Box(stC'#24)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#24)))) && (forall stC'#29: DatatypeType, p#30: DatatypeType :: DtAlloc(stC'#29, $Heap) && DtType(stC'#29) == class._module.StateC && DtAlloc(p#30, $Heap) && DtType(p#30) == class._module.Path ==> stsC'#12[$Box(stC'#29)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#30)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#29))[$Box(p#30)] ==> _module.__default.GetSt($Heap, this, p#30, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#30, _module.StateC.st(stC'#29))))
    {
        havoc stC'#25;
        assume DtAlloc(stC'#25, $Heap) && DtType(stC'#25) == class._module.StateC;
        havoc p#26;
        assume DtAlloc(p#26, $Heap) && DtType(p#26) == class._module.Path;
        if (stsC'#12[$Box(stC'#25)])
        {
            assume _module.StateC.S_q(stC#2);
            st#27 := _module.StateC.st(stC#2);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        }

        if (stsC'#12[$Box(stC'#25)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#26)])
        {
            assume _module.StateC.S_q(stC'#25);
            st#28 := _module.StateC.st(stC'#25);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#25));
        }

        if (stsC'#12[$Box(stC'#25)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#26)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#25))[$Box(p#26)])
        {
        }
    }

    assume (forall stC'#31: DatatypeType :: DtAlloc(stC'#31, $Heap) && DtType(stC'#31) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#31)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#31)))) && (forall stC'#32: DatatypeType, p#33: DatatypeType :: DtAlloc(stC'#32, $Heap) && DtType(stC'#32) == class._module.StateC && DtAlloc(p#33, $Heap) && DtType(p#33) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#32)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#33)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#32))[$Box(p#33)] ==> _module.__default.GetSt($Heap, this, p#33, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#33, _module.StateC.st(stC'#32))) && (forall stC'#34: DatatypeType, p#35: DatatypeType :: DtAlloc(stC'#34, $Heap) && DtType(stC'#34) == class._module.StateC && DtAlloc(p#35, $Heap) && DtType(p#35) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#34)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#35)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#34))[$Box(p#35)] ==> _module.Path.OpaquePath_q(p#35));
}



procedure InterModuleCall$$_module.__default.EvalArgsCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap));
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC'#36: DatatypeType :: DtAlloc(stC'#36, $Heap) && DtType(stC'#36) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#36)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#36))));
  ensures (forall stC'#37: DatatypeType, p#38: DatatypeType :: DtAlloc(stC'#37, $Heap) && DtType(stC'#37) == class._module.StateC && DtAlloc(p#38, $Heap) && DtType(p#38) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#37)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#38)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#37))[$Box(p#38)] ==> _module.__default.GetSt($Heap, this, p#38, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#38, _module.StateC.st(stC'#37)));
  ensures (forall stC'#39: DatatypeType, p#40: DatatypeType :: DtAlloc(stC'#39, $Heap) && DtType(stC'#39) == class._module.StateC && DtAlloc(p#40, $Heap) && DtType(p#40) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#39)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#40)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#39))[$Box(p#40)] ==> _module.Path.OpaquePath_q(p#40));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalArgsCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#1: int :: { Seq#Index(args#1, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#1)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap));
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC'#41: DatatypeType :: DtAlloc(stC'#41, $Heap) && DtType(stC'#41) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#41)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#41))));
  ensures (forall stC'#42: DatatypeType, p#43: DatatypeType :: DtAlloc(stC'#42, $Heap) && DtType(stC'#42) == class._module.StateC && DtAlloc(p#43, $Heap) && DtType(p#43) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#42)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#43)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#42))[$Box(p#43)] ==> _module.__default.GetSt($Heap, this, p#43, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#43, _module.StateC.st(stC'#42)));
  ensures (forall stC'#44: DatatypeType, p#45: DatatypeType :: DtAlloc(stC'#44, $Heap) && DtType(stC'#44) == class._module.StateC && DtAlloc(p#45, $Heap) && DtType(p#45) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#44)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#45)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#44))[$Box(p#45)] ==> _module.Path.OpaquePath_q(p#45));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalArgsCLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#2: int :: { Seq#Index(args#1, $i#2) } 0 <= $i#2 && $i#2 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#2)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#2)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  // user-defined preconditions
  requires (forall arg#5: DatatypeType :: DtAlloc(arg#5, $Heap) && DtType(arg#5) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#5)) ==> DtRank(arg#5) < DtRank(expr#0));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC'#46: DatatypeType :: DtAlloc(stC'#46, $Heap) && DtType(stC'#46) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#46)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#46))));
  ensures (forall stC'#47: DatatypeType, p#48: DatatypeType :: DtAlloc(stC'#47, $Heap) && DtType(stC'#47) == class._module.StateC && DtAlloc(p#48, $Heap) && DtType(p#48) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#47)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#48)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#47))[$Box(p#48)] ==> _module.__default.GetSt($Heap, this, p#48, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#48, _module.StateC.st(stC'#47)));
  ensures (forall stC'#49: DatatypeType, p#50: DatatypeType :: DtAlloc(stC'#49, $Heap) && DtType(stC'#49) == class._module.StateC && DtAlloc(p#50, $Heap) && DtType(p#50) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3))): Set BoxType)[$Box(stC'#49)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#50)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#49))[$Box(p#50)] ==> _module.Path.OpaquePath_q(p#50));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.EvalArgsCLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#6: HeapType;
  var expr##60: DatatypeType;
  var args##61: Seq BoxType;
  var stC##62: DatatypeType;
  var env##63: BoxType;
  var args'##64: Seq BoxType;
  var stsC'##65: Set BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(894,14): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    assume $IsA#_module.StateC(stC#2);
    $initHeapForallStmt#6 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#6 == $Heap;
    assume (forall $ih#expr3#51: DatatypeType, $ih#args4#52: Seq BoxType, $ih#stC5#53: DatatypeType :: DtAlloc($ih#expr3#51, $initHeapForallStmt#6) && DtType($ih#expr3#51) == class._module.Expression && (forall $i#7: int :: { Seq#Index($ih#args4#52, $i#7) } 0 <= $i#7 && $i#7 < Seq#Length($ih#args4#52) ==> DtAlloc($Unbox(Seq#Index($ih#args4#52, $i#7)): DatatypeType, $initHeapForallStmt#6) && DtType($Unbox(Seq#Index($ih#args4#52, $i#7)): DatatypeType) == class._module.Expression) && DtAlloc($ih#stC5#53, $initHeapForallStmt#6) && DtType($ih#stC5#53) == class._module.StateC && (forall arg#54: DatatypeType :: DtAlloc(arg#54, $initHeapForallStmt#6) && DtType(arg#54) == class._module.Expression ==> Seq#Contains($ih#args4#52, $Box(arg#54)) ==> DtRank(arg#54) < DtRank($ih#expr3#51)) && (DtRank($ih#expr3#51) < DtRank(expr#0) || (DtRank($ih#expr3#51) == DtRank(expr#0) && 0 <= Seq#Length($ih#args4#52) + 1 && Seq#Length($ih#args4#52) + 1 < Seq#Length(args#1) + 1)) ==> (forall stC'#55: DatatypeType :: DtAlloc(stC'#55, $Heap) && DtType(stC'#55) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, $ih#expr3#51, $ih#args4#52, $ih#stC5#53, env#3))): Set BoxType)[$Box(stC'#55)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC5#53)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#55)))) && (forall stC'#56: DatatypeType, p#57: DatatypeType :: DtAlloc(stC'#56, $Heap) && DtType(stC'#56) == class._module.StateC && DtAlloc(p#57, $Heap) && DtType(p#57) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, $ih#expr3#51, $ih#args4#52, $ih#stC5#53, env#3))): Set BoxType)[$Box(stC'#56)] && _module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC5#53))[$Box(p#57)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#56))[$Box(p#57)] ==> _module.__default.GetSt($Heap, this, p#57, _module.StateC.st($ih#stC5#53)) == _module.__default.GetSt($Heap, this, p#57, _module.StateC.st(stC'#56))) && (forall stC'#58: DatatypeType, p#59: DatatypeType :: DtAlloc(stC'#58, $Heap) && DtType(stC'#58) == class._module.StateC && DtAlloc(p#59, $Heap) && DtType(p#59) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC($LS($LZ), $Heap, this, $ih#expr3#51, $ih#args4#52, $ih#stC5#53, env#3))): Set BoxType)[$Box(stC'#58)] && !_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC5#53))[$Box(p#59)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#58))[$Box(p#59)] ==> _module.Path.OpaquePath_q(p#59)));
    $_reverifyPost := false;
    // ----- call statement ----- CachedBuilds0.dfy(907,3)
    assume true;
    expr##60 := expr#0;
    assume true;
    args##61 := args#1;
    assume true;
    stC##62 := stC#2;
    assume true;
    env##63 := env#3;
    assume true;
    args'##64 := Seq#Empty(): Seq BoxType;
    assume true;
    stsC'##65 := Set#Empty(): Set BoxType;
    assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
    assert 0 <= Seq#Length(args#1) + 1 || DtRank(expr##60) < DtRank(expr#0) || Seq#Length(args##61) == Seq#Length(args#1) + 1;
    assert DtRank(expr##60) < DtRank(expr#0) || (DtRank(expr##60) == DtRank(expr#0) && Seq#Length(args##61) < Seq#Length(args#1) + 1);
    call IntraModuleCall$$_module.__default.EvalArgsC_kLemma(this, expr##60, args##61, stC##62, env##63, args'##64, stsC'##65);
    assume {:captureState "CachedBuilds0.dfy(907,3)"} true;
}



procedure CheckWellformed$$_module.__default.EvalArgsC_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#1: int :: { Seq#Index(args'#4, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType) == class._module.Expression), stsC'#5: Set BoxType where (forall $t#2: BoxType :: { stsC'#5[$t#2] } stsC'#5[$t#2] ==> DtAlloc($Unbox($t#2): DatatypeType, $Heap) && DtType($Unbox($t#2): DatatypeType) == class._module.StateC));
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  modifies $Heap, $Tick;



implementation CheckWellformed$$_module.__default.EvalArgsC_kLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var arg#6: DatatypeType;
  var stC'#8: DatatypeType;
  var st#9: BoxType;
  var st#10: BoxType;
  var stC'#12: DatatypeType;
  var p#13: DatatypeType;
  var st#14: BoxType;
  var st#15: BoxType;
  var p#16: DatatypeType;
  var st#17: BoxType;
  var p#18: DatatypeType;
  var st#19: BoxType;
  var stC'#22: DatatypeType;
  var p#23: DatatypeType;
  var st#24: BoxType;
  var st#25: BoxType;
  var result#28: DatatypeType;
  var expr#29: DatatypeType;
  var args#30: Seq BoxType;
  var stC#31: DatatypeType;
  var env#32: BoxType;
  var args'#33: Seq BoxType;
  var stsC'#34: Set BoxType;
  var stsC''#36: Set BoxType;
  var stC''#37: DatatypeType;
  var st#38: BoxType;
  var st#39: BoxType;
  var stC''#40: DatatypeType;
  var p#41: DatatypeType;
  var st#42: BoxType;
  var st#43: BoxType;
  var p#44: DatatypeType;
  var st#45: BoxType;
  var p#46: DatatypeType;
  var st#47: BoxType;
  var stC''#49: DatatypeType;
  var p#50: DatatypeType;
  var st#51: BoxType;
  var st#52: BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(910,14): initial state"} true;
    havoc arg#6;
    assume DtAlloc(arg#6, $Heap) && DtType(arg#6) == class._module.Expression;
    if (Seq#Contains(args#1, $Box(arg#6)))
    {
    }

    assume (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
    havoc stC'#8;
    assume DtAlloc(stC'#8, $Heap) && DtType(stC'#8) == class._module.StateC;
    if (stsC'#5[$Box(stC'#8)])
    {
        assume _module.StateC.S_q(stC#2);
        st#9 := _module.StateC.st(stC#2);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        assume _module.StateC.S_q(stC'#8);
        st#10 := _module.StateC.st(stC'#8);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#8));
    }

    assume (forall stC'#11: DatatypeType :: DtAlloc(stC'#11, $Heap) && DtType(stC'#11) == class._module.StateC ==> stsC'#5[$Box(stC'#11)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#11))));
    havoc stC'#12;
    assume DtAlloc(stC'#12, $Heap) && DtType(stC'#12) == class._module.StateC;
    havoc p#13;
    assume DtAlloc(p#13, $Heap) && DtType(p#13) == class._module.Path;
    if (stsC'#5[$Box(stC'#12)])
    {
        assume _module.StateC.S_q(stC#2);
        st#14 := _module.StateC.st(stC#2);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
    }

    if (stsC'#5[$Box(stC'#12)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#13)])
    {
        assume _module.StateC.S_q(stC'#12);
        st#15 := _module.StateC.st(stC'#12);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#12));
    }

    if (stsC'#5[$Box(stC'#12)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#13)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#12))[$Box(p#13)])
    {
        assume _module.StateC.S_q(stC#2);
        p#16 := p#13;
        st#17 := _module.StateC.st(stC#2);
        assume _module.__default.GetSt#canCall($Heap, this, p#13, _module.StateC.st(stC#2));
        assume _module.StateC.S_q(stC'#12);
        p#18 := p#13;
        st#19 := _module.StateC.st(stC'#12);
        assume _module.__default.GetSt#canCall($Heap, this, p#13, _module.StateC.st(stC'#12));
    }

    assume (forall stC'#20: DatatypeType, p#21: DatatypeType :: DtAlloc(stC'#20, $Heap) && DtType(stC'#20) == class._module.StateC && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> stsC'#5[$Box(stC'#20)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#20))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#20)));
    havoc stC'#22;
    assume DtAlloc(stC'#22, $Heap) && DtType(stC'#22) == class._module.StateC;
    havoc p#23;
    assume DtAlloc(p#23, $Heap) && DtType(p#23) == class._module.Path;
    if (stsC'#5[$Box(stC'#22)])
    {
        assume _module.StateC.S_q(stC#2);
        st#24 := _module.StateC.st(stC#2);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
    }

    if (stsC'#5[$Box(stC'#22)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#23)])
    {
        assume _module.StateC.S_q(stC'#22);
        st#25 := _module.StateC.st(stC'#22);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC'#22));
    }

    if (stsC'#5[$Box(stC'#22)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#23)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#22))[$Box(p#23)])
    {
    }

    assume (forall stC'#26: DatatypeType, p#27: DatatypeType :: DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> stsC'#5[$Box(stC'#26)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
    havoc $Heap;
    assume old($Heap) == $Heap;
    assume {:captureState "CachedBuilds0.dfy(919,5): post-state"} true;
    expr#29 := expr#0;
    args#30 := args#1;
    stC#31 := stC#2;
    env#32 := env#3;
    args'#33 := args'#4;
    stsC'#34 := stsC'#5;
    assert (forall arg#35: DatatypeType :: DtAlloc(arg#35, $Heap) && DtType(arg#35) == class._module.Expression ==> Seq#Contains(args#30, $Box(arg#35)) ==> DtRank(arg#35) < DtRank(expr#29));
    assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5);
    assume result#28 == _module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5);
    assume _module.__default.evalArgsC_k#canCall($Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5);
    assume _module.Tuple.Pair_q(result#28);
    assume stsC''#36 == $Unbox(_module.Tuple.snd(result#28)): Set BoxType;
    assume true;
    havoc stC''#37;
    assume DtAlloc(stC''#37, $Heap) && DtType(stC''#37) == class._module.StateC;
    if (stsC''#36[$Box(stC''#37)])
    {
        assume _module.StateC.S_q(stC#2);
        st#38 := _module.StateC.st(stC#2);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        assume _module.StateC.S_q(stC''#37);
        st#39 := _module.StateC.st(stC''#37);
        assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC''#37));
    }

    if ((forall stC''#48: DatatypeType :: DtAlloc(stC''#48, $Heap) && DtType(stC''#48) == class._module.StateC ==> stsC''#36[$Box(stC''#48)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#48)))))
    {
        havoc stC''#40;
        assume DtAlloc(stC''#40, $Heap) && DtType(stC''#40) == class._module.StateC;
        havoc p#41;
        assume DtAlloc(p#41, $Heap) && DtType(p#41) == class._module.Path;
        if (stsC''#36[$Box(stC''#40)])
        {
            assume _module.StateC.S_q(stC#2);
            st#42 := _module.StateC.st(stC#2);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        }

        if (stsC''#36[$Box(stC''#40)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#41)])
        {
            assume _module.StateC.S_q(stC''#40);
            st#43 := _module.StateC.st(stC''#40);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC''#40));
        }

        if (stsC''#36[$Box(stC''#40)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#41)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#40))[$Box(p#41)])
        {
            assume _module.StateC.S_q(stC#2);
            p#44 := p#41;
            st#45 := _module.StateC.st(stC#2);
            assume _module.__default.GetSt#canCall($Heap, this, p#41, _module.StateC.st(stC#2));
            assume _module.StateC.S_q(stC''#40);
            p#46 := p#41;
            st#47 := _module.StateC.st(stC''#40);
            assume _module.__default.GetSt#canCall($Heap, this, p#41, _module.StateC.st(stC''#40));
        }
    }

    if ((forall stC''#48: DatatypeType :: DtAlloc(stC''#48, $Heap) && DtType(stC''#48) == class._module.StateC ==> stsC''#36[$Box(stC''#48)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#48)))) && (forall stC''#53: DatatypeType, p#54: DatatypeType :: DtAlloc(stC''#53, $Heap) && DtType(stC''#53) == class._module.StateC && DtAlloc(p#54, $Heap) && DtType(p#54) == class._module.Path ==> stsC''#36[$Box(stC''#53)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#54)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#53))[$Box(p#54)] ==> _module.__default.GetSt($Heap, this, p#54, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#54, _module.StateC.st(stC''#53))))
    {
        havoc stC''#49;
        assume DtAlloc(stC''#49, $Heap) && DtType(stC''#49) == class._module.StateC;
        havoc p#50;
        assume DtAlloc(p#50, $Heap) && DtType(p#50) == class._module.Path;
        if (stsC''#36[$Box(stC''#49)])
        {
            assume _module.StateC.S_q(stC#2);
            st#51 := _module.StateC.st(stC#2);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC#2));
        }

        if (stsC''#36[$Box(stC''#49)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#50)])
        {
            assume _module.StateC.S_q(stC''#49);
            st#52 := _module.StateC.st(stC''#49);
            assume _module.__default.DomSt#canCall($Heap, this, _module.StateC.st(stC''#49));
        }

        if (stsC''#36[$Box(stC''#49)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#50)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#49))[$Box(p#50)])
        {
        }
    }

    assume (forall stC''#55: DatatypeType :: DtAlloc(stC''#55, $Heap) && DtType(stC''#55) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#55)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#55)))) && (forall stC''#56: DatatypeType, p#57: DatatypeType :: DtAlloc(stC''#56, $Heap) && DtType(stC''#56) == class._module.StateC && DtAlloc(p#57, $Heap) && DtType(p#57) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#56)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#57)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#56))[$Box(p#57)] ==> _module.__default.GetSt($Heap, this, p#57, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#57, _module.StateC.st(stC''#56))) && (forall stC''#58: DatatypeType, p#59: DatatypeType :: DtAlloc(stC''#58, $Heap) && DtType(stC''#58) == class._module.StateC && DtAlloc(p#59, $Heap) && DtType(p#59) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#58)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#59)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#58))[$Box(p#59)] ==> _module.Path.OpaquePath_q(p#59));
}



procedure InterModuleCall$$_module.__default.EvalArgsC_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#0: int :: { Seq#Index(args#1, $i#0) } 0 <= $i#0 && $i#0 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#0)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#0)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#1: int :: { Seq#Index(args'#4, $i#1) } 0 <= $i#1 && $i#1 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#1)): DatatypeType) == class._module.Expression), stsC'#5: Set BoxType where (forall $t#2: BoxType :: { stsC'#5[$t#2] } stsC'#5[$t#2] ==> DtAlloc($Unbox($t#2): DatatypeType, $Heap) && DtType($Unbox($t#2): DatatypeType) == class._module.StateC));
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall stC'#11: DatatypeType :: DtAlloc(stC'#11, $Heap) && DtType(stC'#11) == class._module.StateC ==> stsC'#5[$Box(stC'#11)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#11))));
  requires (forall stC'#20: DatatypeType, p#21: DatatypeType :: DtAlloc(stC'#20, $Heap) && DtType(stC'#20) == class._module.StateC && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> stsC'#5[$Box(stC'#20)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#20))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#20)));
  requires (forall stC'#26: DatatypeType, p#27: DatatypeType :: DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> stsC'#5[$Box(stC'#26)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC''#60: DatatypeType :: DtAlloc(stC''#60, $Heap) && DtType(stC''#60) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#60)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#60))));
  ensures (forall stC''#61: DatatypeType, p#62: DatatypeType :: DtAlloc(stC''#61, $Heap) && DtType(stC''#61) == class._module.StateC && DtAlloc(p#62, $Heap) && DtType(p#62) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#61)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#62)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#61))[$Box(p#62)] ==> _module.__default.GetSt($Heap, this, p#62, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#62, _module.StateC.st(stC''#61)));
  ensures (forall stC''#63: DatatypeType, p#64: DatatypeType :: DtAlloc(stC''#63, $Heap) && DtType(stC''#63) == class._module.StateC && DtAlloc(p#64, $Heap) && DtType(p#64) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#63)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#64)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#63))[$Box(p#64)] ==> _module.Path.OpaquePath_q(p#64));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure IntraModuleCall$$_module.__default.EvalArgsC_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#3: int :: { Seq#Index(args#1, $i#3) } 0 <= $i#3 && $i#3 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#3)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#3)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#4: int :: { Seq#Index(args'#4, $i#4) } 0 <= $i#4 && $i#4 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#4)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#4)): DatatypeType) == class._module.Expression), stsC'#5: Set BoxType where (forall $t#5: BoxType :: { stsC'#5[$t#5] } stsC'#5[$t#5] ==> DtAlloc($Unbox($t#5): DatatypeType, $Heap) && DtType($Unbox($t#5): DatatypeType) == class._module.StateC));
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall stC'#11: DatatypeType :: DtAlloc(stC'#11, $Heap) && DtType(stC'#11) == class._module.StateC ==> stsC'#5[$Box(stC'#11)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#11))));
  requires (forall stC'#20: DatatypeType, p#21: DatatypeType :: DtAlloc(stC'#20, $Heap) && DtType(stC'#20) == class._module.StateC && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> stsC'#5[$Box(stC'#20)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#20))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#20)));
  requires (forall stC'#26: DatatypeType, p#27: DatatypeType :: DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> stsC'#5[$Box(stC'#26)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC''#65: DatatypeType :: DtAlloc(stC''#65, $Heap) && DtType(stC''#65) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#65)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#65))));
  ensures (forall stC''#66: DatatypeType, p#67: DatatypeType :: DtAlloc(stC''#66, $Heap) && DtType(stC''#66) == class._module.StateC && DtAlloc(p#67, $Heap) && DtType(p#67) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#66)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#67)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#66))[$Box(p#67)] ==> _module.__default.GetSt($Heap, this, p#67, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#67, _module.StateC.st(stC''#66)));
  ensures (forall stC''#68: DatatypeType, p#69: DatatypeType :: DtAlloc(stC''#68, $Heap) && DtType(stC''#68) == class._module.StateC && DtAlloc(p#69, $Heap) && DtType(p#69) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#68)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#69)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#68))[$Box(p#69)] ==> _module.Path.OpaquePath_q(p#69));
  // frame condition
  free ensures old($Heap) == $Heap;



procedure Impl$$_module.__default.EvalArgsC_kLemma(this: ref where this != null && read($Heap, this, alloc) && dtype(this) == class._module.__default, expr#0: DatatypeType where DtAlloc(expr#0, $Heap) && DtType(expr#0) == class._module.Expression && $IsA#_module.Expression(expr#0), args#1: Seq BoxType where (forall $i#6: int :: { Seq#Index(args#1, $i#6) } 0 <= $i#6 && $i#6 < Seq#Length(args#1) ==> DtAlloc($Unbox(Seq#Index(args#1, $i#6)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args#1, $i#6)): DatatypeType) == class._module.Expression), stC#2: DatatypeType where DtAlloc(stC#2, $Heap) && DtType(stC#2) == class._module.StateC && $IsA#_module.StateC(stC#2), env#3: BoxType where GenericAlloc(env#3, $Heap), args'#4: Seq BoxType where (forall $i#7: int :: { Seq#Index(args'#4, $i#7) } 0 <= $i#7 && $i#7 < Seq#Length(args'#4) ==> DtAlloc($Unbox(Seq#Index(args'#4, $i#7)): DatatypeType, $Heap) && DtType($Unbox(Seq#Index(args'#4, $i#7)): DatatypeType) == class._module.Expression), stsC'#5: Set BoxType where (forall $t#8: BoxType :: { stsC'#5[$t#8] } stsC'#5[$t#8] ==> DtAlloc($Unbox($t#8): DatatypeType, $Heap) && DtType($Unbox($t#8): DatatypeType) == class._module.StateC)) returns ($_reverifyPost: bool);
  free requires 0 == $ModuleContextHeight && 44 == $FunctionContextHeight;
  // user-defined preconditions
  requires (forall arg#7: DatatypeType :: DtAlloc(arg#7, $Heap) && DtType(arg#7) == class._module.Expression ==> Seq#Contains(args#1, $Box(arg#7)) ==> DtRank(arg#7) < DtRank(expr#0));
  requires (forall stC'#11: DatatypeType :: DtAlloc(stC'#11, $Heap) && DtType(stC'#11) == class._module.StateC ==> stsC'#5[$Box(stC'#11)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#11))));
  requires (forall stC'#20: DatatypeType, p#21: DatatypeType :: DtAlloc(stC'#20, $Heap) && DtType(stC'#20) == class._module.StateC && DtAlloc(p#21, $Heap) && DtType(p#21) == class._module.Path ==> stsC'#5[$Box(stC'#20)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#21)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#20))[$Box(p#21)] ==> _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#21, _module.StateC.st(stC'#20)));
  requires (forall stC'#26: DatatypeType, p#27: DatatypeType :: DtAlloc(stC'#26, $Heap) && DtType(stC'#26) == class._module.StateC && DtAlloc(p#27, $Heap) && DtType(p#27) == class._module.Path ==> stsC'#5[$Box(stC'#26)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#27)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC'#26))[$Box(p#27)] ==> _module.Path.OpaquePath_q(p#27));
  modifies $Heap, $Tick;
  // user-defined postconditions
  ensures (forall stC''#70: DatatypeType :: DtAlloc(stC''#70, $Heap) && DtType(stC''#70) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#70)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#70))));
  ensures (forall stC''#71: DatatypeType, p#72: DatatypeType :: DtAlloc(stC''#71, $Heap) && DtType(stC''#71) == class._module.StateC && DtAlloc(p#72, $Heap) && DtType(p#72) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#71)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#72)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#71))[$Box(p#72)] ==> _module.__default.GetSt($Heap, this, p#72, _module.StateC.st(stC#2)) == _module.__default.GetSt($Heap, this, p#72, _module.StateC.st(stC''#71)));
  ensures (forall stC''#73: DatatypeType, p#74: DatatypeType :: DtAlloc(stC''#73, $Heap) && DtType(stC''#73) == class._module.StateC && DtAlloc(p#74, $Heap) && DtType(p#74) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, expr#0, args#1, stC#2, env#3, args'#4, stsC'#5))): Set BoxType)[$Box(stC''#73)] && !_module.__default.DomSt($Heap, this, _module.StateC.st(stC#2))[$Box(p#74)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#73))[$Box(p#74)] ==> _module.Path.OpaquePath_q(p#74));
  // frame condition
  free ensures old($Heap) == $Heap;



implementation Impl$$_module.__default.EvalArgsC_kLemma(this: ref, expr#0: DatatypeType, args#1: Seq BoxType, stC#2: DatatypeType, env#3: BoxType, args'#4: Seq BoxType, stsC'#5: Set BoxType) returns ($_reverifyPost: bool)
{
  var $_Frame: <beta>[ref,Field beta]bool;
  var $initHeapForallStmt#14: HeapType;
  var arg#91: DatatypeType where DtAlloc(arg#91, $Heap) && DtType(arg#91) == class._module.Expression;
  var expr##92: DatatypeType;
  var stC##93: DatatypeType;
  var env##94: BoxType;
  var result#95: DatatypeType where DtAlloc(result#95, $Heap) && DtType(result#95) == class._module.Tuple;
  var expr#96: DatatypeType;
  var stC#97: DatatypeType;
  var env#98: BoxType;
  var arg'#99: DatatypeType where DtAlloc(arg'#99, $Heap) && DtType(arg'#99) == class._module.Expression;
  var stC'#100: DatatypeType where DtAlloc(stC'#100, $Heap) && DtType(stC'#100) == class._module.StateC;
  var $rhs#18: DatatypeType;
  var $rhs#19: DatatypeType;
  var expr##101: DatatypeType;
  var args##102: Seq BoxType;
  var stC##103: DatatypeType;
  var env##104: BoxType;
  var args'##105: Seq BoxType;
  var stsC'##106: Set BoxType;

    $_Frame := (lambda<alpha> $o: ref, $f: Field alpha :: $o != null && read($Heap, $o, alloc) ==> false);
    assume {:captureState "CachedBuilds0.dfy(910,14): initial state"} true;
    assume $IsA#_module.Expression(expr#0);
    assume $IsA#_module.StateC(stC#2);
    $initHeapForallStmt#14 := $Heap;
    havoc $Heap, $Tick;
    assume $initHeapForallStmt#14 == $Heap;
    assume (forall $ih#expr9#75: DatatypeType, $ih#args10#76: Seq BoxType, $ih#stC11#77: DatatypeType, $ih#args'12#78: Seq BoxType, $ih#stsC'13#79: Set BoxType :: DtAlloc($ih#expr9#75, $initHeapForallStmt#14) && DtType($ih#expr9#75) == class._module.Expression && (forall $i#15: int :: { Seq#Index($ih#args10#76, $i#15) } 0 <= $i#15 && $i#15 < Seq#Length($ih#args10#76) ==> DtAlloc($Unbox(Seq#Index($ih#args10#76, $i#15)): DatatypeType, $initHeapForallStmt#14) && DtType($Unbox(Seq#Index($ih#args10#76, $i#15)): DatatypeType) == class._module.Expression) && DtAlloc($ih#stC11#77, $initHeapForallStmt#14) && DtType($ih#stC11#77) == class._module.StateC && (forall $i#16: int :: { Seq#Index($ih#args'12#78, $i#16) } 0 <= $i#16 && $i#16 < Seq#Length($ih#args'12#78) ==> DtAlloc($Unbox(Seq#Index($ih#args'12#78, $i#16)): DatatypeType, $initHeapForallStmt#14) && DtType($Unbox(Seq#Index($ih#args'12#78, $i#16)): DatatypeType) == class._module.Expression) && (forall $t#17: BoxType :: { $ih#stsC'13#79[$t#17] } $ih#stsC'13#79[$t#17] ==> DtAlloc($Unbox($t#17): DatatypeType, $initHeapForallStmt#14) && DtType($Unbox($t#17): DatatypeType) == class._module.StateC) && (forall arg#80: DatatypeType :: DtAlloc(arg#80, $initHeapForallStmt#14) && DtType(arg#80) == class._module.Expression ==> Seq#Contains($ih#args10#76, $Box(arg#80)) ==> DtRank(arg#80) < DtRank($ih#expr9#75)) && (forall stC'#81: DatatypeType :: DtAlloc(stC'#81, $initHeapForallStmt#14) && DtType(stC'#81) == class._module.StateC ==> $ih#stsC'13#79[$Box(stC'#81)] ==> Set#Subset(_module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st($ih#stC11#77)), _module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st(stC'#81)))) && (forall stC'#82: DatatypeType, p#83: DatatypeType :: DtAlloc(stC'#82, $initHeapForallStmt#14) && DtType(stC'#82) == class._module.StateC && DtAlloc(p#83, $initHeapForallStmt#14) && DtType(p#83) == class._module.Path ==> $ih#stsC'13#79[$Box(stC'#82)] && _module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st($ih#stC11#77))[$Box(p#83)] && _module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st(stC'#82))[$Box(p#83)] ==> _module.__default.GetSt($initHeapForallStmt#14, this, p#83, _module.StateC.st($ih#stC11#77)) == _module.__default.GetSt($initHeapForallStmt#14, this, p#83, _module.StateC.st(stC'#82))) && (forall stC'#84: DatatypeType, p#85: DatatypeType :: DtAlloc(stC'#84, $initHeapForallStmt#14) && DtType(stC'#84) == class._module.StateC && DtAlloc(p#85, $initHeapForallStmt#14) && DtType(p#85) == class._module.Path ==> $ih#stsC'13#79[$Box(stC'#84)] && !_module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st($ih#stC11#77))[$Box(p#85)] && _module.__default.DomSt($initHeapForallStmt#14, this, _module.StateC.st(stC'#84))[$Box(p#85)] ==> _module.Path.OpaquePath_q(p#85)) && (DtRank($ih#expr9#75) < DtRank(expr#0) || (DtRank($ih#expr9#75) == DtRank(expr#0) && 0 <= Seq#Length($ih#args10#76) && Seq#Length($ih#args10#76) < Seq#Length(args#1))) ==> (forall stC''#86: DatatypeType :: DtAlloc(stC''#86, $Heap) && DtType(stC''#86) == class._module.StateC ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, $ih#expr9#75, $ih#args10#76, $ih#stC11#77, env#3, $ih#args'12#78, $ih#stsC'13#79))): Set BoxType)[$Box(stC''#86)] ==> Set#Subset(_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC11#77)), _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#86)))) && (forall stC''#87: DatatypeType, p#88: DatatypeType :: DtAlloc(stC''#87, $Heap) && DtType(stC''#87) == class._module.StateC && DtAlloc(p#88, $Heap) && DtType(p#88) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, $ih#expr9#75, $ih#args10#76, $ih#stC11#77, env#3, $ih#args'12#78, $ih#stsC'13#79))): Set BoxType)[$Box(stC''#87)] && _module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC11#77))[$Box(p#88)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#87))[$Box(p#88)] ==> _module.__default.GetSt($Heap, this, p#88, _module.StateC.st($ih#stC11#77)) == _module.__default.GetSt($Heap, this, p#88, _module.StateC.st(stC''#87))) && (forall stC''#89: DatatypeType, p#90: DatatypeType :: DtAlloc(stC''#89, $Heap) && DtType(stC''#89) == class._module.StateC && DtAlloc(p#90, $Heap) && DtType(p#90) == class._module.Path ==> ($Unbox(_module.Tuple.snd(_module.__default.evalArgsC_k($LS($LZ), $Heap, this, $ih#expr9#75, $ih#args10#76, $ih#stC11#77, env#3, $ih#args'12#78, $ih#stsC'13#79))): Set BoxType)[$Box(stC''#89)] && !_module.__default.DomSt($Heap, this, _module.StateC.st($ih#stC11#77))[$Box(p#90)] && _module.__default.DomSt($Heap, this, _module.StateC.st(stC''#89))[$Box(p#90)] ==> _module.Path.OpaquePath_q(p#90)));
    $_reverifyPost := false;
    // ----- if statement ----- CachedBuilds0.dfy(928,3)
    assume true;
    if (Seq#Equal(args#1, Seq#Empty(): Seq BoxType))
    {
    }
    else
    {
        // ----- var-declaration statement ----- CachedBuilds0.dfy(930,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(930,13)
        assume true;
        assert 0 <= Lit(0) && Lit(0) < Seq#Length(args#1);
        assume true;
        arg#91 := $Unbox(Seq#Index(args#1, Lit(0))): DatatypeType;
        assume {:captureState "CachedBuilds0.dfy(930,13)"} true;
        // ----- call statement ----- CachedBuilds0.dfy(931,5)
        assume true;
        expr##92 := arg#91;
        assume true;
        stC##93 := stC#2;
        assume true;
        env##94 := env#3;
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert DtRank(expr##92) < DtRank(expr#0);
        call IntraModuleCall$$_module.__default.EvalCLemma(this, expr##92, stC##93, env##94);
        assume {:captureState "CachedBuilds0.dfy(931,5)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(932,9)
        // ----- assignment statement ----- CachedBuilds0.dfy(932,16)
        assume true;
        expr#96 := arg#91;
        stC#97 := stC#2;
        env#98 := env#3;
        assume _module.__default.evalC#canCall($Heap, this, arg#91, stC#2, env#3);
        assume _module.__default.evalC#canCall($Heap, this, arg#91, stC#2, env#3);
        result#95 := _module.__default.evalC($LS($LZ), $Heap, this, arg#91, stC#2, env#3);
        assume {:captureState "CachedBuilds0.dfy(932,16)"} true;
        // ----- var-declaration statement ----- CachedBuilds0.dfy(933,9)
        // ----- var-declaration statement ----- CachedBuilds0.dfy(933,15)
        // ----- update statement ----- CachedBuilds0.dfy(933,20)
        assume true;
        assume true;
        assume _module.Tuple.Pair_q(result#95);
        assume true;
        $rhs#18 := $Unbox(_module.Tuple.fst(result#95)): DatatypeType;
        assume _module.Tuple.Pair_q(result#95);
        assume true;
        $rhs#19 := $Unbox(_module.Tuple.snd(result#95)): DatatypeType;
        arg'#99 := $rhs#18;
        stC'#100 := $rhs#19;
        assume {:captureState "CachedBuilds0.dfy(933,20)"} true;
        // ----- call statement ----- CachedBuilds0.dfy(934,5)
        assume true;
        expr##101 := expr#0;
        assert 0 <= Lit(1) && Lit(1) <= Seq#Length(args#1);
        assume true;
        args##102 := Seq#Drop(args#1, Lit(1));
        assume true;
        stC##103 := stC#2;
        assume true;
        env##104 := env#3;
        assume true;
        args'##105 := Seq#Append(args'#4, Seq#Build(Seq#Empty(): Seq BoxType, $Box(arg'#99)));
        assume true;
        stsC'##106 := Set#Union(stsC'#5, Set#UnionOne(Set#Empty(): Set BoxType, $Box(stC'#100)));
        assert (forall<alpha> $o: ref, $f: Field alpha :: false ==> $_Frame[$o, $f]);
        assert 0 <= Seq#Length(args#1) || DtRank(expr##101) < DtRank(expr#0) || Seq#Length(args##102) == Seq#Length(args#1);
        assert DtRank(expr##101) < DtRank(expr#0) || (DtRank(expr##101) == DtRank(expr#0) && Seq#Length(args##102) < Seq#Length(args#1));
        call IntraModuleCall$$_module.__default.EvalArgsC_kLemma(this, expr##101, args##102, stC##103, env##104, args'##105, stsC'##106);
        assume {:captureState "CachedBuilds0.dfy(934,5)"} true;
    }
}


