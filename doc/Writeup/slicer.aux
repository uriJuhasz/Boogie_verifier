\relax 
\providecommand \oddpage@label [2]{}
\citation{Dijkstra:1975:GCN:360933.360975}
\citation{DBLP:conf/cav/BarrettCDHJKRT11}
\citation{DBLP:conf/tacas/MouraB08}
\citation{HJL99}
\citation{DBLP:conf/cade/RiazanovV99}
\citation{Korovin2008}
\citation{BaumgartnerPelzerTinelli12}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}Introduction}{1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\citation{LeinoP16}
\citation{DBLP:conf/cade/RiazanovV99}
\citation{DBLP:conf/popl/GulwaniMT08}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}Outline}{3}}
\citation{Dijkstra:1975:GCN:360933.360975}
\citation{Leino:2005:EWP:1066417.1710882}
\citation{Leino:2005:EWP:1066417.1710882}
\citation{DBLP:conf/cav/BarrettDS02}
\citation{DBLP:journals/jacm/DetlefsNS05}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}Control Flow}{4}}
\citation{GRASP}
\citation{DPLLJoin}
\citation{DBLP:conf/tacas/AlbarghouthiGC12}
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces Example for the information contained in the CFG\relax }}{5}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{snippet_1.1}{{1.1}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {1.3}Locality and Scope}{5}}
\citation{DBLP:conf/csl/KorovinV07}
\@writefile{lof}{\contentsline {figure}{\numberline {1.2}{\ignorespaces Example for the incompleteness of scoped annotation in universal CNF.  The \lstinline |random| function is specified as \lstinline |a$\leq $random(a,b)<b|  A possible scoped annotation at \lstinline |n$_1$| that is sufficient to prove the assertion is   \lstinline |$\exists i \cdot (0\leq i < $length(a)$ \land $a[$i$]=true)|  However, this annotation is not in the fragment of universal CNF which is used by many provers, and into which there is a validty preserving conversion from FOLE.  A possible non-scoped universal CNF annotation is  \indent \lstinline |(b$\Rightarrow ($$0\leq $j$<$length(a) $\land $ a[j]=true)) $\land $ ($\lnot $b $\Rightarrow $ a[0]=true)|  There is no scoped annotation for universal CNF \relax }}{7}}
\newlabel{snippet_1.4}{{1.2}{7}}
\@writefile{toc}{\contentsline {section}{\numberline {1.4}Bounded Fragments}{7}}
\citation{DBLP:journals/jacm/ClarkeGJLV03}
\citation{DBLP:conf/ecoop/HeuleKMS13}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}Preliminaries}{9}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:preliminaries}{{2}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces language\relax }}{10}}
\newlabel{section:preliminaries:semantics}{{2}{11}}
\newlabel{section:preliminaties:ordering}{{2}{13}}
\citation{WinklerZanklMiddeldorp12}
\citation{KovacsMoserVoronkov11}
\citation{KovacsVoronkov09}
\citation{McMillan08}
\citation{BachmairGanzingerSuperposition}
\newlabel{section:preliminaries:superposition}{{2}{15}}
\citation{BachmairGanzinger94}
\@writefile{lof}{\contentsline {figure}{\numberline {2.2}{\ignorespaces The ground superposition calculus \ensuremath  {\mathbf  {SP_{g}}}  $\succ $ is a reduction ordering.  The numbered conditions on the right are the side conditions of each inference rule.  The calculus combines ordered resolution with unfailing Knuth Bendix completion.  Equality resolution ($\ensuremath  {\mathrm  {res_{=}}}$) allows the elimination of maximal false literals.  Positive superposition ($\ensuremath  {\mathrm  {sup_{=}}}$) ensures that the set of maximal positive literals of non-redundant clauses is a convergent rewrite system.  Negative superposition ($\ensuremath  {\mathrm  {sup_{\not =}}}$) allows rewriting maximal dis-equalities by the term-rewrite system defined by maximal positive literals, and together with equality resolution is a generalization of ordered resolution for equality.  Equality factoring ($\ensuremath  {\mathrm  {fact}}$) is a version of ordered factorting. \relax }}{17}}
\newlabel{fig_ground_superposition}{{2.2}{17}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.3}{\ignorespaces simplification rules  $\cancel  {\ensuremath  {\mathrm  {C}}}$ denotes that the premise $\ensuremath  {\mathrm  {C}}$ is redundant after the addition of the conclusion to the clause-set and hence can be removed. \relax }}{18}}
\newlabel{fig_superposition_simp}{{2.3}{18}}
\citation{BarnettCDJL05}
\citation{Leino:2005:EWP:1066417.1710882}
\@writefile{lof}{\contentsline {figure}{\numberline {2.4}{\ignorespaces The $\ensuremath  {\mathrm  {\mathbf  {CC}}}$ calculus  We denote by $\ensuremath  {\mathrm  {\ensuremath  {\mathrm  {\overline  {s=t}}}}}$ for two tuples $\ensuremath  {\mathrm  {\ensuremath  {\mathrm  {\overline  {s}}},\ensuremath  {\mathrm  {\overline  {t}}}}}$ of the same arity the set of non-trivial equalities between corresponding elements of the tuples - formally:  $\ensuremath  {\mathrm  {\ensuremath  {\mathrm  {\overline  {s=t}}}}}$ is the set $\ensuremath  {\left \{\mathrm  {s_i = t_i \mid i \in 0..\ensuremath  {\left |\mathrm  {s}\right |}-1 \land s_i \not \equiv t_i}\right \}}$.  The rule $\ensuremath  {\mathrm  {tra_{\bowtie  }}}$ is the transitivity rule.  The rule $\ensuremath  {\mathrm  {res}}$ is similar to equality resolution.  The rule $\ensuremath  {\mathrm  {con}}$ encodes standard congruence closure, except that the side condition $\ensuremath  {\mathrm  {\ensuremath  {\ensuremath  {\mathrm  {f}}(\ensuremath  {\mathrm  {\overline  {s}}})} \lhd C}}$, where C is any (dis)equality, ensures that no new equivalence classes are introduced in any derivation. \relax }}{19}}
\newlabel{calculus_CC}{{2.4}{19}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.5}{\ignorespaces The \ensuremath  {\mathrm  {\mathbf  {CC_I}}} calculus  The rule \ensuremath  {\mathrm  {con_I}} follows the definition of congruence closure. \relax }}{19}}
\newlabel{calculus_CC_I}{{2.5}{19}}
\newlabel{section:preliminaries_programs}{{2}{19}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.6}{\ignorespaces Example for VC encoding - source program\relax }}{20}}
\newlabel{CFG_source_program}{{2.6}{20}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.7}{\ignorespaces Example for VC encoding - Boogie program  All variables have been split to DSA versions.  All assignments are converted to \lstinline |assume| statementes.  The loop return edge has been cut and the body begins with a fresh version for each variable, an \lstinline |assume| of the invariant and negation of the loop condition, and ends with an \lstinline |assert| of the loop invariant on the latest DSA versions.  The code after the loop also uses a fresh DSA version of all variables and \lstinline |assume|s the invariant. (we did not detail a modifies clause for the loop) \relax }}{21}}
\newlabel{CFG_Boogie}{{2.7}{21}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.8}{\ignorespaces Example for VC encoding - our encoding  Showing that the post-states of both $\ensuremath  {\mathrm  {n_{1a},n_{2a}}}$ is infeasible proves the Boogie program and hence the source program. \relax }}{22}}
\newlabel{CFG_ours}{{2.8}{22}}
\newlabel{section_path_condition}{{2}{25}}
\citation{GulwaniTiwariNecula04}
\citation{DBLP:conf/aaai/HertelBPG08}
\@input{background.aux}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Unit ground first order logic with equality}{34}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:ugfole}{{3}{34}}
\@input{ugfole_cc_graphs.aux}
\@input{ugfole_cc_cfg.aux}
\@input{ugfole_information_propagation.aux}
\@input{ugfole_joins.aux}
\@input{ugfole_related_work.aux}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Ground first order logic with equality}{106}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:gfole}{{4}{106}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}The fragment of GFOLE}{106}}
\newlabel{section:gfole_basic}{{4.1}{106}}
\citation{Leino:2005:EWP:1066417.1710882}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces Ground superposition calculus - \ensuremath  {\mathbf  {SP_{g}}}  Clauses are sets of literals (rather than sequences or multi-sets).  The ordering $\succ $ is any reduction ordering.  The rule \ensuremath  {\mathrm  {res_{=}}} eliminates a false literal.  The rules \ensuremath  {\mathrm  {sup_{=},sup_{\not =}}} perform conditional rewriting of the maximal term in the second premise.  The rule \ensuremath  {\mathrm  {fact_{=}}} is an instance of factoring required because superposition only targets the maximal term. \relax }}{107}}
\newlabel{superposition_calculus.1}{{4.1}{107}}
\citation{DBLP:conf/nfm/GurfinkelCS11}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces Example program for simple VC comparison\relax }}{109}}
\newlabel{snippet4.1.1}{{4.2}{109}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.1}Basic clause propagation}{111}}
\newlabel{section_basic_clause_propagation}{{4.1.1}{111}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces Verification algorithm with lazy propagation.  \lstinline |inferences(c,done)| returns all possible inference rule instances from \ensuremath  {\mathbf  {SP_{g}}}{} between the clause \lstinline |c| and clauses in \lstinline |done|.  The difference from the version in 3.25\hbox {} is that we import clauses for the entire \lstinline |todo| queue in one call, rather than repeated calls per clause. \relax }}{112}}
\newlabel{verification_algorithm_v_3}{{4.3}{112}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.4}{\ignorespaces Basic recursive import  The implementation uses the method \lstinline |traverseBF| to traverse the CFG first backwards and then forwards starting at the current node, calling the visitors \lstinline |importBW|,\lstinline |importFW| respectively.  The backward visitor propagates the request backwards except for cached requests and the forward visitor propagates clauses forward. \relax }}{113}}
\newlabel{basic_verification.4.recursiveImport}{{4.4}{113}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.5}{\ignorespaces Basic recursive import - Request  A request consists of left- and right-hand-side maximal terms.  Adding and removing requests are the standard set operations. \relax }}{114}}
\newlabel{basic_verification.4.request}{{4.5}{114}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.6}{\ignorespaces Example program for VC verification comparison  The ordering is \ensuremath  {\mathrm  {e \succ d \succ c \succ b \succ a \succ u \succ T}}  The node \ensuremath  {\mathrm  {n_5}} was added to ensure all joins are binary \relax }}{115}}
\newlabel{snippet4.1.2}{{4.6}{115}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.7}{\ignorespaces Simple flat VC for figure \nobreakspace  {}4.6\hbox {}  maximal terms are underlined   We use the literal ordering:  \ensuremath  {\mathrm  {n_5 \succ n_4 \succ n_3 \succ n_2 \succ n_1 \succ n_0 \succ c_0 \succ c_1}}  Where all path literals are smaller than all equality literals \relax }}{116}}
\newlabel{snippet4.1.2_flatvc}{{4.7}{116}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.8}{\ignorespaces Modular proof for figure \nobreakspace  {}4.6\hbox {}  Each node number is followed by the set of predecessors.  The literal ordering is \ensuremath  {\mathrm  {e \succ d \succ c \succ b \succ a \succ u}}.  We do not distinguish the lhs and rhs of requests for simplicity.  \leavevmode {\color  {blue}Blue premises in square brakcets are imported by a local request}  \leavevmode {\color  {cyan}Cyan premises in square brackets are imported by a successor request}  Parenthesized numbers are premises for an inference  \relax }}{119}}
\newlabel{snippet4.1.2_modular_proof}{{4.8}{119}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.9}{\ignorespaces simplification rules  $\cancel  {\ensuremath  {\mathrm  {C}}}$ denotes that the premise $\ensuremath  {\mathrm  {C}}$ is redundant after the addition of the conclusion to the clause-set and hence can be removed. \relax }}{120}}
\newlabel{simp_rules.1}{{4.9}{120}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.2}Redundancy elimination}{120}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.10}{\ignorespaces Simple example for VC comparison with simplification  The ordering is \ensuremath  {\mathrm  {e \succ d \succ c \succ b \succ a \succ u \succ T}}.  The node \ensuremath  {\mathrm  {n_5}} was added to ensure all joins are binary. \relax }}{121}}
\newlabel{snippet4.1.2.1}{{4.10}{121}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.11}{\ignorespaces Modular VC for figure \nobreakspace  {}4.10\hbox {} with simplifications  maximal terms are underlined   The literal ordering is \ensuremath  {\mathrm  {e \succ d \succ c \succ b \succ a \succ u \succ T}} \relax }}{122}}
\newlabel{snippet4.1.2.1_flatvc.2}{{4.11}{122}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.12}{\ignorespaces Simple flat VC for figure \nobreakspace  {}4.10\hbox {}  maximal terms are underlined \relax }}{123}}
\newlabel{snippet4.1.2.1_flatvc.1}{{4.12}{123}}
\citation{Voronkov14}
\citation{GRASP}
\citation{DPLLJoin}
\@writefile{lof}{\contentsline {figure}{\numberline {4.13}{\ignorespaces Proof for flat VC of figure \nobreakspace  {}4.10\hbox {}  Maximal terms are underlined.  \leavevmode {\color  {blue}Blue indices} are clauses used in the proof.  \relax }}{125}}
\newlabel{snippet4.1.2.1_flatvc.1a}{{4.13}{125}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.14}{\ignorespaces Simple per-path VC proof for figure \nobreakspace  {}4.10\hbox {}  The proof is shown separately for each path. \relax }}{126}}
\newlabel{snippet4.1.2.1_pathvc}{{4.14}{126}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.3}Improvements to the base algorithm}{127}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.15}{\ignorespaces Example for forward propagation of unit clauses for simplification  \relax }}{128}}
\newlabel{snippet4.1.2.2}{{4.15}{128}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.16}{\ignorespaces Recursive import request including literals.  A request consists of equality and inequality maximal terms, and a set of atoms \lstinline |As|.  A clause matches a request if there is a valid inference in the calculus, and in addition if there is a unit clause that can be used in a simplifying inference.  \relax }}{129}}
\newlabel{basic_verification.4.request_literals}{{4.16}{129}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.17}{\ignorespaces Ground superposition for predicates\relax }}{130}}
\newlabel{GSP_Predicate}{{4.17}{130}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.18}{\ignorespaces Example for predicate symbols \relax }}{130}}
\newlabel{snippet4.1.2.3}{{4.18}{130}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.19}{\ignorespaces Example for branch conditions on a path  \relax }}{131}}
\newlabel{snippet4.1.4.4}{{4.19}{131}}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}Completeness}{131}}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Joins}{132}}
\newlabel{section:gfole:joins}{{4.3}{132}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.20}{\ignorespaces Example for simple clause join  \relax }}{133}}
\newlabel{snippet4.1.3.0}{{4.20}{133}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.21}{\ignorespaces Example for clause join  \relax }}{134}}
\newlabel{snippet4.1.3.1}{{4.21}{134}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.22}{\ignorespaces Modular VC for figure \nobreakspace  {}4.21\hbox {}  maximal terms are underlined   The literal ordering is \ensuremath  {\mathrm  {e \succ d \succ c \succ b \succ a \succ u}}  Eager simplification is not applied except for \ensuremath  {\mathrm  {simp_=}} \relax }}{135}}
\newlabel{snippet4.1.3.1_modular.1}{{4.22}{135}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.23}{\ignorespaces Modular VC for figure \nobreakspace  {}4.21\hbox {} with clause join  The main difference is at node \ensuremath  {\mathrm  {n_3}} \relax }}{136}}
\newlabel{snippet4.1.3.1_modular.2}{{4.23}{136}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.24}{\ignorespaces Example for exponential clause join for unit propagation with sequential joins  \relax }}{140}}
\newlabel{snippet4.1.3.6}{{4.24}{140}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.25}{\ignorespaces Example for exponential clause join for unit propagation with nested branches  \relax }}{141}}
\newlabel{snippet4.1.3.7}{{4.25}{141}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.26}{\ignorespaces Example for join after unit propagation  \relax }}{142}}
\newlabel{snippet4.1.3.8}{{4.26}{142}}
\citation{RobinsonVoronkov2001}
\citation{RegerSudaVoronkov15}
\citation{BaumgartnerWaldmann13}
\@writefile{toc}{\contentsline {section}{\numberline {4.4}Term, literal and clause ordering}{144}}
\newlabel{section:gfole:ordering}{{4.4}{144}}
\citation{DBLP:conf/cav/BarrettDS02}
\citation{Voronkov14}
\@writefile{toc}{\contentsline {section}{\numberline {4.5}Related work}{145}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.1}Theorem proving and CFGs}{145}}
\citation{DBLP:conf/vmcai/GulwaniT07}
\citation{Baader2001445}
\citation{GRASP}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.2}Clause join}{146}}
\citation{NieuwenhuisOliveras03}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Scoping and Interpolation}{147}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:scoping}{{5}{147}}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}Basics}{147}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.1}Notation}{148}}
\citation{McMillan04}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces Minimal scope\relax }}{151}}
\newlabel{snippet4.2.1}{{5.1}{151}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces Minimal scope - unit ground fragment\relax }}{151}}
\newlabel{snippet4.2.2}{{5.2}{151}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}CFG Node Scope}{151}}
\newlabel{section:scoping:node_scope}{{5.2}{151}}
\citation{BaumgartnerWaldmann13}
\citation{BaumgartnerWaldmann13}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces Intermediate scope  We assume the standard heap axioms without extensionality \relax }}{152}}
\newlabel{snippet4.2.4}{{5.3}{152}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.4}{\ignorespaces Scoping and reachability  \lstinline |x.f| at the initial state is unreachable at the assertion,  which is equivalent to \ensuremath  {\mathrm  {rd(h_0,x,f)}} having no equivalent ground term at \ensuremath  {\mathrm  {n_2}}.  Without scoping we would use the mixed term \ensuremath  {\mathrm  {rd(h_1,rd(h_0,x,f),g}} to instantiate the quantifier. \relax }}{153}}
\newlabel{snippet4.2.4.1}{{5.4}{153}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.5}{\ignorespaces Scoping DSA join\relax }}{155}}
\newlabel{snippet4.2.5}{{5.5}{155}}
\citation{FuchsGoelGrundyKrsticTinelli2012}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}Ground Unit Interpolation}{157}}
\newlabel{section:scoping:ugfole}{{5.3}{157}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.1}The problem}{157}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.2}Basic graph-based algorithm}{157}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.6}{\ignorespaces Propagation guarantee\relax }}{158}}
\newlabel{fig_propagation_guarantee}{{5.6}{158}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.7}{\ignorespaces Simple unit ground interpolation example.  The only interpolation clause is \ensuremath  {\mathrm  {a \not =b \lor c=d}}.\relax }}{158}}
\newlabel{example_4.2.1.1_0}{{5.7}{158}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.8}{\ignorespaces  Simple unit ground interpolation example  Initial state.  Circles represent EC-nodes - GTs{}.  \leavevmode {\color  {blue}Dashed blue edges} represent source edges - edges between GTs{} of different graphs whose EC shares a term.  Dashed black edges represent dis-equality edges. \relax }}{159}}
\newlabel{example_4.2.1.1_1}{{5.8}{159}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.9}{\ignorespaces  Simple unit ground interpolation example  After \lstinline |$\ensuremath  {\mathrm  {g^t}}$.assume(a=b)|  Bold text marks where \ensuremath  {\mathrm  {g^t}} performed congruence closure \relax }}{159}}
\newlabel{example_4.2.1.1_2}{{5.9}{159}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.10}{\ignorespaces  Simple unit ground interpolation example  After \lstinline |$\ensuremath  {\mathrm  {g^b}}$.assume(c=d)|  Here, \ensuremath  {\mathrm  {g^b \models  \ensuremath  {\square }}} \relax }}{159}}
\newlabel{example_4.2.1.1_3}{{5.10}{159}}
\citation{FuchsGoelGrundyKrsticTinelli2012}
\citation{DBLP:conf/vmcai/DSilvaKPW10}
\@writefile{lof}{\contentsline {figure}{\numberline {5.11}{\ignorespaces Interpolation with new terms  The interpolant is \ensuremath  {\mathrm  {a\not =b \lor d=g(c)}}.  \relax }}{161}}
\newlabel{example_4.2.1.2_0}{{5.11}{161}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.12}{\ignorespaces Interpolation with new terms  The interpolant is \ensuremath  {\mathrm  {a \not =b \lor c=d, a \not =b \lor e=f(e)}}.  The term \ensuremath  {\mathrm  {f(e)}} does not appear in the initial problem at all. \relax }}{161}}
\newlabel{example_4.2.1.3_0}{{5.12}{161}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.3}Selecting equations to communicate}{161}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.13}{\ignorespaces  Interpolation with new terms  Initial state \relax }}{162}}
\newlabel{example_4.2.1.2_1}{{5.13}{162}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.14}{\ignorespaces  Interpolation with new terms  After \lstinline |$\ensuremath  {\mathrm  {g^b}}$.assume(a=b)| \relax }}{162}}
\newlabel{example_4.2.1.2_2}{{5.14}{162}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.15}{\ignorespaces  Interpolation with new terms  After \lstinline |$\ensuremath  {\mathrm  {g^b}}$.assume(c=d)| \relax }}{163}}
\newlabel{example_4.2.1.2_3}{{5.15}{163}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.16}{\ignorespaces  Interpolation with new terms  After \lstinline |$\ensuremath  {\mathrm  {g^b}}$.update| \relax }}{163}}
\newlabel{example_4.2.1.2_4}{{5.16}{163}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.17}{\ignorespaces  Interpolation with new terms, final state  After \lstinline |$\ensuremath  {\mathrm  {g^b}}$.assume(e=f(e))| The interpolant is \ensuremath  {\left \{\mathrm  {a\not =b \lor c=d,a \not =b \lor e = f(e)}\right \}}  f(e) does not appear in the original problem \relax }}{164}}
\newlabel{example_4.2.1.2_5}{{5.17}{164}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.18}{\ignorespaces Example for order dependence in extracted interpolants  The interpolant extracted by our algorithm is either   \ensuremath  {\left \{\mathrm  {a\not =b \lor e_1=e_2,a\not =b \lor c \not =d \lor e_3=e_4}\right \}} or   \ensuremath  {\left \{\mathrm  {c\not =d \lor e_3=e_4,a\not =b \lor c \not =d \lor e_1=e_2}\right \}},  depending on the order in which we communicate equalities.  The optimal interpolant is:  \ensuremath  {\left \{\mathrm  {a\not =b \lor e_1=e_2,c\not =d \lor e_3=e_4}\right \}} \relax }}{164}}
\newlabel{example_4.2.1.3}{{5.18}{164}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.19}{\ignorespaces Example for incomparable interpolants  The two possible interpolants are:  \ensuremath  {\left \{\mathrm  {a\not =b \lor e_1=e_2}\right \}}  \ensuremath  {\left \{\mathrm  {c\not =d \lor e_1=e_2}\right \}}  Neither is inherently preferable to the other. \relax }}{164}}
\newlabel{example_4.2.1.4}{{5.19}{164}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.20}{\ignorespaces Example for incomparable interpolants - transitivity  The three possible interpolants are:  \ensuremath  {\left \{\mathrm  {a\not =b \lor a \not =c \lor e_1=e_2}\right \}}  \ensuremath  {\left \{\mathrm  {a\not =b \lor b \not =c \lor e_1=e_2}\right \}}  \ensuremath  {\left \{\mathrm  {a\not =c \lor b \not =c \lor e_1=e_2}\right \}}  \relax }}{164}}
\newlabel{example_4.2.1.5}{{5.20}{164}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.4}Relevance calculations}{165}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.21}{\ignorespaces Example for relevance dependencies  The only possible interpolant is \ensuremath  {\mathrm  {a \not =b \lor c=d}}.  Removing any of the clauses from \ensuremath  {\mathrm  {N^t}} makes \ensuremath  {\mathrm  {a=b}} irrelevant for interpolation \relax }}{165}}
\newlabel{f.fs.ug.rc.1}{{5.21}{165}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.22}{\ignorespaces Relevance algorithm\relax }}{167}}
\newlabel{relevance_algorithm}{{5.22}{167}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.23}{\ignorespaces Definition of \ensuremath  {=_{\Gamma }}{}  These equations are the standard transitive congruence closure of $\Gamma $, except that we only allow a congruence closure instance if at least one side of the conclusion is in \ensuremath  {\mathrm  {g^t}} \relax }}{168}}
\newlabel{eqg_def}{{5.23}{168}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.24}{\ignorespaces Definition of \ensuremath  {\mathrm  {I^{\Gamma }}}  \relax }}{168}}
\newlabel{Igamma_def}{{5.24}{168}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.25}{\ignorespaces Definition of G - goal pairs\relax }}{168}}
\newlabel{goals_def}{{5.25}{168}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.26}{\ignorespaces Definition of R - relevant pairs  Where:  \ensuremath  {\mathrm  {\ensuremath  {\left \{\mathrm  {\ensuremath  {\mathrm  {\overline  {s}}},\ensuremath  {\mathrm  {\overline  {t}}}}\right \}} \in R \ensuremath  {\mathrel {\mathop {\kern \z@ \Leftrightarrow }\limits ^{\triangle }}}\forall i \cdot (s_i \not \equiv t_i \Rightarrow \ensuremath  {\left \{\mathrm  {s_i,t_i}\right \}} \in R)}}  The first rule is inverse congruence closure and the second inverse transitive closure, bounded by \ensuremath  {=_{\Gamma }}.  The relevant equalities are \ensuremath  {\mathrm  {u=v}} s.t. \ensuremath  {\mathrm  {\ensuremath  {\left \{\mathrm  {u,v}\right \}} \in R \cap (I^t)^2}}. \relax }}{169}}
\newlabel{R_def}{{5.26}{169}}
\newlabel{goal_relevance_CFG}{{5.3.4}{170}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.5}Scoping in the CFG}{170}}
\citation{BlancGuptaKovacsKragl13}
\@writefile{lof}{\contentsline {figure}{\numberline {5.27}{\ignorespaces Example for interpolation in the CFG\relax }}{171}}
\newlabel{example_scoping_DAG_interpolation.0}{{5.27}{171}}
\citation{BachmairGanzingerSuperposition}
\citation{DBLP:conf/rta/NieuwenhuisO05}
\citation{FuchsGoelGrundyKrsticTinelli2012}
\@writefile{lof}{\contentsline {figure}{\numberline {5.28}{\ignorespaces Example for justification clauses  The justifications for \ensuremath  {\mathrm  {d=e}} are:  \ensuremath  {\left \{\mathrm  {a=b,a=c}\right \}}  The interpolation clauses are:  \ensuremath  {\mathrm  {a\not =b \lor d=e}} \ensuremath  {\mathrm  {a\not =c \lor d=e}} \relax }}{173}}
\newlabel{example_4.2.2.1}{{5.28}{173}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.29}{\ignorespaces Example for CFG approximations  Here, for the root node, we can use \ensuremath  {\left \{\mathrm  {c_1=d_1,c_2=d_2,a=b}\right \}} as the approximation for the equalities on all paths, rather than apply the algorithm twice, once for \ensuremath  {\left \{\mathrm  {c_1=d_1,a=b}\right \}} and once for \ensuremath  {\left \{\mathrm  {c_2=d_2,a=b}\right \}} \relax }}{173}}
\newlabel{example_4.2.1.8_program}{{5.29}{173}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.30}{\ignorespaces Example for CFG over-approximation  Here, for the root node, if we use \ensuremath  {\left \{\mathrm  {c_1=d_1,c_2=d_2,a=b}\right \}}   we produce the interpolation clause \ensuremath  {\mathrm  {c_1 \not =c_1 \lor c_2 \not =d_2 \lor e_3=e_4}},  which is useless as the body holds on any path \relax }}{174}}
\newlabel{example_4.2.1.9_program}{{5.30}{174}}
\newlabel{extracting_justification}{{5.3.5}{174}}
\citation{DBLP:conf/esop/NieuwenhuisR92}
\@writefile{lof}{\contentsline {figure}{\numberline {5.31}{\ignorespaces Justification extraction algorithm  The algorithm finds the fixed point for the equations in figure 5.32\hbox {}.  The algorithm first calculates the subset of $\Gamma $ that is relevant, using the algorithm from figure 5.22\hbox {}.  The algorithm works bottom-up, starting at interface equalities in $\Gamma $.  The map \lstinline |m| is an under-approximation of the function P, constructed as a fixed point.  The method \lstinline |enqueueSuperTerms| ensures changes in \lstinline |m| are propagated, until saturation. \relax }}{176}}
\newlabel{PR_algorithm}{{5.31}{176}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.32}{\ignorespaces Justification extraction from \ensuremath  {\mathrm  {g_n^i}}  A justification is a set of dis-equalities on I.  PR(s,t) is a partial function, only defined if \ensuremath  {\mathrm  {s' = t'}}  The set PR(s,t) is the least fixed point of the above equations.  The building blocks of justifications are negations of equalities in $\Gamma $.  The rules mimic transitivity, reflexivity and congruence closure, collecting justifications for equality. \relax }}{177}}
\newlabel{PR_def}{{5.32}{177}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.33}{\ignorespaces Example for transitive propagation of goals  The goal \ensuremath  {\left \{\mathrm  {c_3,d_3}\right \}} is propagated as \ensuremath  {\mathrm  {c_2,d_2}} to \ensuremath  {\mathrm  {N_1}}.\relax }}{177}}
\newlabel{example_4.2.2.3}{{5.33}{177}}
\citation{DBLP:journals/cacm/BackusBGKMPRSVWWW60}
\citation{Craig57a}
\citation{lyndon1959}
\citation{DBLP:conf/cav/McMillan03}
\citation{McMillan05}
\citation{McMillan05}
\citation{BonacinaJohansson2015}
\citation{FuchsGoelGrundyKrsticTinelli2012}
\citation{DBLP:conf/rta/NieuwenhuisO05}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.6}Related work}{178}}
\citation{DBLP:conf/fmcad/KroeningW07}
\citation{JhalaMcMillan06}
\citation{DBLP:conf/fmcad/VizelG09}
\citation{DBLP:conf/vstte/RummerHK13}
\citation{AlbarghouthiGurfinkelChechik12}
\citation{BlancGuptaKovacsKragl13}
\citation{AlbarghouthiGurfinkelChechik12}
\citation{DBLP:conf/vmcai/Bradley11}
\citation{DBLP:conf/fmcad/EenMB11}
\citation{BachmairGanzingerSuperposition}
\citation{McMillan08}
\citation{BaumgartnerWaldmann13}
\citation{KovacsVoronkov09}
\@writefile{toc}{\contentsline {section}{\numberline {5.4}Ground Clause Interpolation}{181}}
\newlabel{section:scoping:gfole}{{5.4}{181}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.1}Basics}{181}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.34}{\ignorespaces  The ordering is:  \ensuremath  {\mathrm  {\leavevmode {\color  {red}x} \ensuremath  {\succ \mid }d \succ c \succ b \succ a \ensuremath  {\succ \mid }\leavevmode {\color  {blue}l}}}\relax }}{182}}
\newlabel{example.3.1.1.3.1}{{5.34}{182}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.2}Approximation of the bottom model}{183}}
\newlabel{def_maxTerms}{{5.4.1}{183}}
\newlabel{def_maxTermsi}{{5.4.2}{183}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.35}{\ignorespaces  The calculation of the simple over-approximation $\Gamma $ of the model for \ensuremath  {\mathrm  {N^b}}  The first rule communicates a maximal interface equality directly.  The second rule defines M as the maximal terms of clauses in \ensuremath  {\mathrm  {N^b}} that are in \ensuremath  {\mathfrak  {L}^{\ensuremath  {\mathrm  {I}}}}{} but for which the normal form in the candidate model is not representable in \ensuremath  {\mathfrak  {L}^{\ensuremath  {\mathrm  {I}}}}- this corresponds exactly to our requests.  The third rule equates any two super terms of requested terms that are sub-terms of maximal terms (one positive) - an over-approximation. \relax }}{184}}
\newlabel{SP_P}{{5.35}{184}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.36}{\ignorespaces interpolation over-approximation example  The ordering satisfies \ensuremath  {\mathrm  {c \succ b \succ f(h(a,\leavevmode {\color  {blue}m})) \succ h(a,\leavevmode {\color  {blue}m}) \succ \leavevmode {\color  {blue}l}}} \relax }}{184}}
\newlabel{example.4.1.3.2.1}{{5.36}{184}}
\citation{DBLP:conf/cade/NieuwenhuisR92}
\@writefile{lof}{\contentsline {figure}{\numberline {5.37}{\ignorespaces Top interface disagreement set definition  \ensuremath  {\mathrm  {\textbf  {idas}_{\Gamma }(s,t)}} is a partial function, only defined if \ensuremath  {\mathrm  {s \ensuremath  {=_{\Gamma }}t}} \relax }}{185}}
\newlabel{idasg_def}{{5.37}{185}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.3}Interpolation ordering}{186}}
\newlabel{lemma_succ_i}{{5.4.1}{186}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.4}Interpolation superposition calculus}{186}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.38}{\ignorespaces  The interpolation superposition calculus \ensuremath  {\mathrm  {SP_I}} \relax }}{187}}
\newlabel{SP_I}{{5.38}{187}}
\newlabel{coloured_set}{{5.4.3}{188}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.5}Ordering for Interpolation}{188}}
\citation{BaumgartnerWaldmann13}
\citation{McMillan08}
\@writefile{lof}{\contentsline {figure}{\numberline {5.39}{\ignorespaces Interpolation ordering for trees\relax }}{189}}
\newlabel{snippet4.5.1}{{5.39}{189}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.40}{\ignorespaces Interpolation ordering for trees - additional DSA versions\relax }}{189}}
\newlabel{snippet4.5.1b}{{5.40}{189}}
\citation{BaumgartnerWaldmann13}
\citation{DBLP:journals/aaecc/BachmairGW94}
\citation{BaumgartnerWaldmann13}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.6}Related and future work}{190}}
\citation{DBLP:journals/aaecc/BachmairGW94}
\citation{BaumgartnerWaldmann13}
\citation{McMillan08}
\citation{DBLP:books/el/RV01/NieuwenhuisR01}
\citation{BaumgartnerWaldmann13}
\citation{DBLP:journals/aaecc/BachmairGW94}
\citation{BaumgartnerWaldmann13}
\citation{SuperpositionModuloShostak}
\citation{Shostak84}
\citation{DBLP:conf/frocos/BarrettDS02}
\citation{KovacsVoronkov09}
\citation{McMillan08}
\citation{KovacsVoronkov09}
\citation{McMillan08}
\citation{BaumgartnerWaldmann13}
\citation{McMillan08}
\citation{LudwigWaldmann07}
\citation{KovacsMoserVoronkov11}
\citation{KovacsVoronkov09}
\citation{McMillan08}
\@writefile{toc}{\contentsline {chapter}{\numberline {6}Bounded fragments}{195}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:bounds}{{6}{195}}
\@writefile{toc}{\contentsline {section}{\numberline {6.1}Term depth}{195}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.1}Relative depth}{196}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.1}{\ignorespaces Relative term depth example\relax }}{197}}
\newlabel{snippet4.1}{{6.1}{197}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.2}{\ignorespaces Relative term depth example  Translated clauses are given in comments\relax }}{197}}
\newlabel{snippet4.2}{{6.2}{197}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.3}{\ignorespaces Equational proof of program from 6.2\hbox {} at\ensuremath  {\mathrm  {t_2}}\relax }}{198}}
\newlabel{snippet4.2_proof}{{6.3}{198}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.4}{\ignorespaces Relative term depth example 2\relax }}{200}}
\newlabel{snippet4.3}{{6.4}{200}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.5}{\ignorespaces Relative term depth limitation\relax }}{201}}
\newlabel{snippet4.4}{{6.5}{201}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.2}Enforcing the depth restriction}{201}}
\citation{DBLP:journals/jacm/Ben-SassonW01}
\@writefile{toc}{\contentsline {section}{\numberline {6.2}Size bounds for clauses}{202}}
\@writefile{toc}{\contentsline {section}{\numberline {6.3}Derivation depth}{203}}
\newlabel{section:derivation_depth}{{6.3}{203}}
\@writefile{toc}{\contentsline {section}{\numberline {6.4}Summary}{204}}
\citation{Baaz2001273}
\citation{BachmairGanzingerSuperposition}
\citation{KovacsMoserVoronkov11}
\@writefile{toc}{\contentsline {chapter}{\numberline {7}Quantification}{205}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:quantification}{{7}{205}}
\@writefile{toc}{\contentsline {section}{\numberline {7.1}Preliminaries}{205}}
\citation{Baader2001445}
\citation{Baader2001445}
\citation{BachmairGanzingerSuperposition}
\@writefile{lof}{\contentsline {figure}{\numberline {7.1}{\ignorespaces Transfinite Knuth Bendix Ordering (tkbo)\relax }}{208}}
\newlabel{fig_tkbo}{{7.1}{208}}
\citation{Sekar20011853}
\@writefile{lof}{\contentsline {figure}{\numberline {7.2}{\ignorespaces Superposition  The main differences from the ground case are:  The ordering \ensuremath  {\mathrm  {\succeq }} is partial (although potentially total on ground terms,literals and clauses).  Side condition (vi) for both superposition rules means that we do not need to consider superposition into a variable, which is undesirable as variables unify with all terms, it can be shown that the calculus is complete even with this condition.  In all ordering side conditions above (both for terms and literals), \ensuremath  {\mathrm  {u\sigma \not \preceq v\sigma }} is an over-approximation of \ensuremath  {\mathrm  {\exists \tau \cdot FV(u\sigma \tau ,v\sigma \tau )=\emptyset \land u\sigma \tau \succ v\sigma \tau }}  which we use as it is easier to compute.  In fact, for requests, we employ a coarser approximation \ensuremath  {\mathrm  {u \not \preceq v}} rather than \ensuremath  {\mathrm  {u\sigma \not \preceq v\sigma }}, as it is much easier to cache and propagate, and check the stricter side-conditions only when performing actual inferences. This also includes condition \ensuremath  {\mathrm  {(vii)}} of \ensuremath  {\mathrm  {sup_=}} which requires both premises. \relax }}{209}}
\newlabel{fig_superposition_calculus}{{7.2}{209}}
\citation{Baader2001445}
\citation{Paterson1978158}
\citation{DBLP:conf/stoc/Kozen77}
\citation{Baader2001445}
\@writefile{toc}{\contentsline {section}{\numberline {7.2}Propagation and requests}{211}}
\newlabel{section:fole:ECgraphs}{{7.2}{212}}
\@writefile{toc}{\contentsline {section}{\numberline {7.3}Quantifiers in bounded fragments}{213}}
\citation{DBLP:journals/corr/abs-1202-6148}
\citation{Reynolds:2014:FCI:2682923.2682957}
\citation{DBLP:conf/cade/DrossCKP12}
\@writefile{toc}{\contentsline {section}{\numberline {7.4}Instantiation}{214}}
\citation{KovacsVoronkov09}
\@writefile{toc}{\contentsline {section}{\numberline {7.5}Scoping for quantified clauses}{215}}
\newlabel{section:fole:scoping}{{7.5}{215}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.1}Incompleteness}{215}}
\citation{BaumgartnerWaldmann13}
\@writefile{lof}{\contentsline {figure}{\numberline {7.3}{\ignorespaces Scoping and heap reachability  \lstinline |x.f| at the initial state is unreachable at the assertion,  which is equivalent to \ensuremath  {\mathrm  {rd(h_0,x,f)}} having no equivalent ground term at \ensuremath  {\mathrm  {n_2}}.  Without scoping we use the mixed term \ensuremath  {\mathrm  {rd(h_1,rd(h_0,x,f),g}} to instantiate the quantifier. \relax }}{216}}
\newlabel{snippet4.2.4.1b}{{7.3}{216}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.2}Completeness for some restricted cases}{216}}
\@writefile{toc}{\contentsline {chapter}{\numberline {8}Implementation and experimental results}{217}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:implementation}{{8}{217}}
\@writefile{toc}{\contentsline {section}{\numberline {8.1}Order of evaluation}{217}}
\@writefile{lof}{\contentsline {figure}{\numberline {8.1}{\ignorespaces Example for order of evaluation  We consider the fragments of ground superposition   where $z\succ y \succ x \succ 2 \succ 1 \succ 0$\relax }}{218}}
\newlabel{snippet_7.1}{{8.1}{218}}
\@writefile{lof}{\contentsline {figure}{\numberline {8.2}{\ignorespaces Example for order of evaluation - simplifications  We assume $Q(c)\succ P(b)$ and $c\succ b \succ a$\relax }}{218}}
\newlabel{snippet_7.2}{{8.2}{218}}
\@writefile{lof}{\contentsline {figure}{\numberline {8.3}{\ignorespaces Example for order of evaluation - heaps  We use the DSA versions of the heap $H_0,H_1,H_2,H_3$  We use the fragment of UGFOLE plus the fragment of ground heaps  For superposition, the ordering is   $H_1 \succ g \ensuremath  {\succ \mid }H_2 \succ y \ensuremath  {\succ \mid }H_3 \succ H_0 \succ f \succ x$ \relax }}{219}}
\newlabel{snippet_7.3}{{8.3}{219}}
\newlabel{section:heaps}{{8.1}{219}}
\@writefile{toc}{\contentsline {section}{\numberline {8.2}Implementation}{221}}
\citation{Kotelnikov:2016:VF:2854065.2854071}
\citation{Rdch2011}
\@writefile{toc}{\contentsline {section}{\numberline {8.3}Experimental results}{224}}
\citation{CDW14}
\citation{DBLP:conf/cav/BarrettCDHJKRT11}
\citation{DBLP:conf/tacas/MouraB08}
\citation{DBLP:conf/cade/2009}
\citation{Voronkov14}
\citation{DBLP:conf/cade/BaumgartnerBW15}
\citation{DBLP:journals/jacm/DetlefsNS05}
\citation{DBLP:conf/cav/GeM09}
\citation{DBLP:conf/fmcad/ReynoldsTM14}
\citation{DBLP:conf/tacas/LeinoR10}
\@writefile{lot}{\contentsline {table}{\numberline {8.1}{\ignorespaces Results of running the verifier as an optimization pre-process  Base stands for the baseline Boogie performance with Z3 as a backend. The Opt column is the time taken for our tool run as an optimizer, the Z3 column is the time taken for Z3 on the optimized output of our tool and the last column is percentage of time taken by our tool and Z3 from the baseline time of only Z3. TO means timeout - more than 600 seconds.\relax }}{229}}
\newlabel{fig_results_overall}{{8.1}{229}}
\@writefile{lot}{\contentsline {table}{\numberline {8.2}{\ignorespaces The effect of scoping on the run time and number of assertions proven.  We show the total time taken for the first n passes.  The last column shows the improvement for four passes - empty when our tool timed out without scoping.  The \lstinline |tree_insert| took about 75 seconds in the pre-processing stage that modifies the CFG-node scope so that a total order can be defined, because of an inefficiency in the implementation which we believe is fixable.\relax }}{230}}
\newlabel{fig_results_scoping}{{8.2}{230}}
\@writefile{lot}{\contentsline {table}{\numberline {8.3}{\ignorespaces The effect of term depth bounds on run-time and number of assertions proven.\relax }}{230}}
\newlabel{fig_bounded_depth}{{8.3}{230}}
\@writefile{toc}{\contentsline {chapter}{\numberline {9}Conclusion and future work}{232}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:conclusions}{{9}{232}}
\@writefile{toc}{\contentsline {section}{\numberline {9.1}Main contributions}{232}}
\citation{DBLP:conf/fmcad/SheeranS98}
\citation{McMillan03Interpolation}
\citation{BaumgartnerWaldmann13}
\citation{McMillan08}
\@writefile{toc}{\contentsline {section}{\numberline {9.2}Experience and directions for future work}{233}}
\@writefile{toc}{\contentsline {chapter}{\numberline {A}Appendix}{235}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {A.1}Interpolation}{235}}
\@input{appendix_interpolation.aux}
\@input{appendix_scoping.aux}
\@input{gfole_ec_graphs.aux}
\bibdata{slicer}
\bibcite{AlbarghouthiGurfinkelChechik12}{AGC12a}
\bibcite{DBLP:conf/tacas/AlbarghouthiGC12}{AGC12b}
\bibcite{CAV2014}{BB14}
\bibcite{DBLP:journals/cacm/BackusBGKMPRSVWWW60}{BBG{$^{+}$}60}
\bibcite{DBLP:conf/cade/BaumgartnerBW15}{BBW15}
\citation{DBLP:conf/cade/2015}
\bibcite{BarnettCDJL05}{BCD{$^{+}$}05}
\bibcite{DBLP:conf/cav/BarrettCDHJKRT11}{BCD{$^{+}$}11}
\bibcite{DPLLJoin}{BDdM08}
\bibcite{DBLP:conf/cav/BarrettDS02}{BDS02a}
\bibcite{DBLP:conf/frocos/BarrettDS02}{BDS02b}
\bibcite{Baaz2001273}{BEL{$^{+}$}01}
\bibcite{BachmairGanzingerSuperposition}{BG91}
\bibcite{BachmairGanzinger94}{BG94a}
\bibcite{DBLP:journals/logcom/BachmairG94}{BG94b}
\bibcite{BjornerGurfinkel2015}{BG15}
\bibcite{BlancGuptaKovacsKragl13}{BGKK13}
\bibcite{BjornerGurfinkelKorovinLahav2013}{BGKL13}
\bibcite{DBLP:journals/aaecc/BachmairGW94}{BGW94}
\bibcite{BonacinaJohansson2015}{BJ15}
\bibcite{BjÃ¶rk2009}{Bj{\"o}09}
\bibcite{DBLP:conf/cade/2013}{Bon13}
\bibcite{BaumgartnerPelzerTinelli12}{BPT12}
\bibcite{DBLP:conf/vmcai/Bradley11}{Bra11}
\bibcite{Bradley12}{Bra12}
\bibcite{Baader2001445}{BS01}
\citation{DBLP:books/el/RobinsonV01}
\bibcite{BachmairTiwari00}{BT00}
\bibcite{DBLP:journals/corr/abs-1202-6148}{BT12}
\bibcite{BaylessValBallHoosHu2013}{BVB{$^{+}$}13}
\bibcite{DBLP:journals/jacm/Ben-SassonW01}{BW01}
\bibcite{BaumgartnerWaldmann13}{BW13}
\citation{DBLP:conf/cade/2013}
\bibcite{CousotCousot77}{CC77}
\bibcite{DBLP:journals/entcs/ConchonCKL08}{CCKL08}
\bibcite{CDW14}{CDW14}
\bibcite{DBLP:journals/jacm/ClarkeGJLV03}{CGJ{$^{+}$}03}
\bibcite{ChangLeino2005}{CL05}
\bibcite{DBLP:conf/vmcai/2007}{CP07}
\bibcite{Craig57a}{Cra57}
\bibcite{DBLP:conf/cade/DrossCKP12}{DCKP12}
\bibcite{Dijkstra:1975:GCN:360933.360975}{Dij75}
\bibcite{DBLP:conf/vmcai/DSilvaKPW10}{DKPW10}
\bibcite{DBLP:journals/cacm/DavisLL62}{DLL62}
\bibcite{DBLP:conf/tacas/MouraB08}{dMB08}
\citation{DBLP:conf/tacas/2008}
\bibcite{DBLP:journals/jacm/DetlefsNS05}{DNS05}
\bibcite{DowneySethiTarjan}{DST80}
\bibcite{DBLP:conf/fmcad/EenMB11}{EMB11}
\bibcite{FuchsGoelGrundyKrsticTinelli2012}{FGG{$^{+}$}12}
\bibcite{DBLP:conf/cav/FlanaganJOS03}{FJOS03}
\citation{DBLP:conf/cav/2003}
\bibcite{DBLP:conf/cade/2015}{FM15}
\bibcite{Fuchs:Darwin:Thesis:2004}{Fuc04}
\bibcite{DBLP:conf/nfm/GurfinkelCS11}{GCS11}
\bibcite{DBLP:conf/cav/GeM09}{GdM09}
\bibcite{SuperpositionModuloShostak}{GHW03}
\bibcite{DBLP:conf/popl/GulwaniMT08}{GMT08}
\bibcite{GulwaniNecula07}{GN07}
\bibcite{DBLP:journals/aml/GradelOR99}{GOR99}
\bibcite{GulwaniTiwari07}{GT07a}
\citation{DBLP:conf/vmcai/2007}
\bibcite{DBLP:conf/vmcai/GulwaniT07}{GT07b}
\citation{DBLP:conf/vmcai/2007}
\bibcite{GulwaniTiwariNecula04}{GTN04}
\bibcite{DBLP:conf/aaai/HertelBPG08}{HBPG08}
\bibcite{HJL99}{HJL99}
\bibcite{DBLP:conf/ecoop/HeuleKMS13}{HKMS13}
\bibcite{DBLP:conf/csl/ImmermanRRSY04}{IRR{$^{+}$}04}
\bibcite{JhalaMcMillan06}{JM06}
\bibcite{DBLP:conf/cav/2003}{JS03}
\bibcite{Kildall73}{Kil73}
\bibcite{Kotelnikov:2016:VF:2854065.2854071}{KKRV16}
\bibcite{KovacsMoserVoronkov11}{KMV11}
\bibcite{Korovin2008}{Kor08}
\bibcite{DBLP:conf/stoc/Kozen77}{Koz77}
\bibcite{DBLP:conf/cade/KorovinS10}{KS10}
\bibcite{DBLP:conf/csl/KorovinV07}{KV07}
\bibcite{KovacsVoronkov09}{KV09}
\citation{DBLP:conf/cade/2009}
\bibcite{DBLP:conf/fmcad/KroeningW07}{KW07}
\bibcite{Leino:2005:EWP:1066417.1710882}{Lei05}
\bibcite{LeinoP16}{LP16}
\bibcite{DBLP:conf/tacas/LeinoR10}{LR10}
\bibcite{LudwigWaldmann07}{LW07}
\bibcite{lyndon1959}{Lyn59}
\bibcite{DBLP:conf/cav/McMillan03}{McM03a}
\citation{DBLP:conf/cav/2003}
\bibcite{McMillan03Interpolation}{McM03b}
\citation{DBLP:conf/cav/2003}
\bibcite{McMillan04}{McM04}
\bibcite{McMillan05}{McM05}
\bibcite{McMillan08}{McM08}
\citation{DBLP:conf/tacas/2008}
\bibcite{MullerOlmSeidl04}{MS04}
\bibcite{MuellerSchwerhoffSummers16b}{MSS16}
\bibcite{NelsonOppenUnionFind}{NO77}
\bibcite{DBLP:journals/toplas/NelsonO79}{NO79}
\bibcite{NelsonOppen80}{NO80}
\bibcite{NieuwenhuisOliveras03}{NO03}
\bibcite{DBLP:conf/rta/NieuwenhuisO05}{NO05}
\bibcite{DBLP:conf/esop/NieuwenhuisR92}{NR92a}
\bibcite{DBLP:conf/cade/NieuwenhuisR92}{NR92b}
\bibcite{DBLP:books/el/RV01/NieuwenhuisR01}{NR01}
\citation{DBLP:books/el/RobinsonV01}
\bibcite{Paterson1978158}{PW78}
\bibcite{DBLP:conf/vstte/RummerHK13}{RHK13}
\bibcite{Robinson:1965:MLB:321250.321253}{Rob65}
\bibcite{DBLP:conf/tacas/2008}{RR08}
\bibcite{RegerSudaVoronkov15}{RSV15}
\citation{DBLP:conf/cade/2015}
\bibcite{Reynolds:2014:FCI:2682923.2682957}{RTdM14a}
\bibcite{DBLP:conf/fmcad/ReynoldsTM14}{RTdM14b}
\bibcite{DBLP:conf/cade/ReynoldsTGKDB13}{RTG{$^{+}$}13}
\citation{DBLP:conf/cade/2013}
\bibcite{Rdch2011}{Rud11}
\bibcite{DBLP:conf/cade/RiazanovV99}{RV99}
\bibcite{RobinsonVoronkov2001}{RV01a}
\bibcite{DBLP:books/el/RobinsonV01}{RV01b}
\bibcite{DBLP:conf/cade/2009}{Sch09}
\bibcite{Shostak84}{Sho84}
\bibcite{Sekar20011853}{SRV01}
\bibcite{DBLP:conf/fmcad/SheeranS98}{SS98}
\bibcite{GRASP}{SS99}
\bibcite{Vagvolgyi03b}{V{\'{a}}g03}
\bibcite{DBLP:conf/fmcad/VizelG09}{VG09}
\bibcite{VizelGurfinkel2014}{VG14}
\citation{CAV2014}
\bibcite{Voronkov14}{Vor14}
\citation{CAV2014}
\bibcite{WinklerZanklMiddeldorp12}{WZM12}
\bibstyle{alpha}
