%\section{Overview}
%Since the first mathematical proofs of computer programs (\cite{FLOYD67},\cite{DBLP:journals/cacm/Hoare69}), many approaches and tools have been developed for automating the proofs and proof-checking of properties of programs.
%
%An automated theorem prover (ATP) receives as input a formula in some logic - often some fragment of first order logic with equality (FOLE) and sometimes with additional theories such as linear integer arithmetic (LIA) - and outputs whether the formula is valid in that logic, and optionally, if it is valid, outputs a proof and otherwise outputs a counter-example (a model for the negation of the formula).
%As first order logic is only semi-decidable, ATPs will, for some inputs, either not terminate, run out of resources (time, memory) or simply return unknown.
%
%In order to verify a program using an ATP, the correctness condition for the program (or for some properties of the program) is encoded into a logical formula and sent to the ATP, often using some variant of weakest preconditions (\cite{Dijkstra:1975:GCN:360933.360975}). The condition sufficient to show that the program is correct is often composed of several properties that have to hold at certain points in the program (e.g. a certain variable must be greater than zero or not null at some point in the program), as was suggested by the original annotation by Floyd. The weakest precondition calculus calculates the weakest condition that, when holds at the initial point of the program, ensures that all properties hold. The VC generated by a verifier may include additional properties that originate in a verification methodology, such as properties modeling aliasing control or concurrency.
%In this setting, a counter-example represents a valid trace of the program in which at least one property does not hold, and a proof represents an actual proof of correctness of the program. An unknown result from the prover gives no information about the program.
 %%(in theory, if a prover logs its proof-search, some lemmas can be mined from the log of a failed proof, but proof-logging might affect the performance of a prover). 
%
%Other tools that infer and prove properties about programs include abstract interpretation based tools (\cite{CousotCousot77}) and other static analysis which analyze the program, annotating each program point with a condition proven to hold at that program point. Such tools often work either with fragments of logic that are decidable or with a decidable subset of a fragment. 
%The annotation calculated by such a tool may be sufficient in proving only some of the properties needed to show program correctness, but it can be injected to another tool, refined using a stronger fragment and used for program debugging.\\
%Many static analyzers work in a fragment where the complexity of the analysis is known, and hence a user can expect consistent analysis results when running the tool on the same program, even if more properties are added or an extension is added to the program. Most static analysis tools handle a logical fragment which is insufficient for proving the whole program, and specifically cannot handle an arbitrary fragment modeled using quantified axioms, which are sometimes handled by VCG - often a new analyzer has to be built for a new fragment.
%
%This work is an attempt at taking the generality of ATPs and the predictability and incrementallity of analysis tools, 
%by allowing a more intimate interaction between the verifier and the prover. Such interaction can allow the prover to take advantage of some of the program properties that are lost or made implicit in the conversion to a VC. 
%The main areas in which we can exploit additional information are detailed in the next sections.
%
%We focus on improving the verification process rather than the inference of invariants, and hence we assume that specification, and particularly loop invariants, are given for the program, and the objective is to verify that the program satisfies the given specification. 
%We assume the program and specification have been encoded into an intermediate language such as Boogie (\cite{BarnettCDJL05}). While such an encoding necessarily loses some information and is at a lower level of abstraction than the original program, this allows us to develop techniques that are applicable to several programming languages and verification methodologies.
%We detail our exact assumptions about the input in chapter \ref{chapter:preliminaries}, here we only mention that we assume that the input CFG is a DAG, and that it is in dynamic single assignment (DSA) form (essentially, each program variable is assigned at most once on each directed path in the CFG).
%
%All of our techniques are incremental (no derivation is repeated, with some exceptions) and allow the extraction of intermediate results at any time, and also allow the addition of additional properties and program extensions at any point. Intermediate results are useful for quick feedback to the user of the verification tool and for interaction with other verification and analysis tools.
