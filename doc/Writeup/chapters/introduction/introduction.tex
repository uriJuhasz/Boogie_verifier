\chapter{Introduction}
Recent advances in the technology of automated theorem proving (ATP) and abstract interpretation allow the automated verification of increasingly large and complex programs.
Fully automated verification tools can annotate a program with loop and recursion invariants and verify that the annotated program is correct according to a given specification. 

In this thesis we are interested in verifying the correctness of (manually or automatically) annotated programs rather than the inference of invariants - this verification problem is interesting in itself when user-given annotations are available and is commonly a sub-problem for more automated tools that try to verify approximations of the program (such as bounded loop unrolling) and approximations of the annotation (such as loop invariants generated by abstract interpretation or by interpolation on the proof of an unrolled program).

Popular program verification techniques (for annotated programs) include variants of verification condition (VC) generation (VCG) and symbolic execution.

In VCG based verification, an annotated program and a specification are encoded in a mathematical formula that holds iff the program satisfies the specification, as pioneered by the work of Dijkstra with weakest preconditions (\cite{Dijkstra:1975:GCN:360933.360975}). This formula can be fed to an automated theorem prover. VCG allows the use of general first order logic (FOL) theorem provers, whether based on SMT solving (e.g. \cite{DBLP:conf/cav/BarrettCDHJKRT11},\cite{DBLP:conf/tacas/MouraB08}), completion (\cite{HJL99},\cite{DBLP:conf/cade/RiazanovV99}) instantiation (\cite{Korovin2008}), or other (\cite{BaumgartnerPelzerTinelli12}), although SMT solvers are, by far, the most common. 
One of the main disadvantages of VCG is that the translation to FOL loses some explicit information about the program which can be useful for the proof search, such as the control structure of the program and the scope of variables.

Symbolic execution simulates executing the program on each possible path, using symbolic values rather than concrete values for variables. The symbolic execution engine evaluates the feasibility of a program path by using a constraint solver (often a SAT or SMT solver) to check the satisfiability of the branch conditions on a path with the calculated symbolic values - hence, essentially, several small VCs are sent to the solver, each for a specific path in the program. Symbolic execution tools are sensitive to the problem of path explosion - the number of feasible paths in a program can be exponential in the size of the program, even though the reasoning needed for proving two non-disjoint paths can be very similar.

SMT solvers have made significant progress in recent years, and are quite efficient and reliable in solving problems that involve ground FOL combined with other ground theories, notably linear integer and rational arithmetic and arrays. However, when the VC includes quantified formulae, SMT solvers are, in general, not complete, and the performance and even termination of the solver is very sensitive to the input formula, even to parts that are logically unrelated to the proof (as noted e.g. in \cite{LeinoP16}).
Quantified VCs are needed for modeling abstractions such as sets and sequences used in specifications, for encoding some invariants and for modeling used in some verification methodologies, such as permissions or dynamic frames for alias control.

The instability of SMT solvers in the presence of quantifiers makes verifiers based on SMT solvers less accessible even to people that are familiar with program proofs, specification and first order logic - users need understanding of the working of the SMT solver in order to understand why verification fails, especially for a program that previously verified and has been modified only slightly. 
In addition, as FOL is only semi-decidable, any theoretically complete tool will not be bounded in its run-time.
For users, it is sometimes useful to know that if a proof for a property of the program was found using a certain effort of the verifier, and the program has been modified but the proof of the property carries over to the modified program, then the property will be proven if the same effort is spent by the verifier on the modified program, regardless of other properties and unrelated modifications of the program. Classic resource limitations on the prover, such as memory and time, cannot usually satisfy this requirement.
In addition, if some of the properties of a program are easy to prove while others require longer time or do not hold, it is useful to show the user of a verification tool intermediate results, such as proven properties, while still searching for proofs for the harder properties. Such intermediate results can also be used to cooperate between verification and analysis tools. While the verifier can be run for each property separately, this is often highly inefficient as the proofs of different properties of the same program often share a large number of lemmas.

ATPs based on superposition (e.g. \cite{DBLP:conf/cade/RiazanovV99}) handle quantifiers efficiently, 
and, in addition, can be modified to search incrementally for proofs of increasing complexity - for example, the proof depth can be bounded (by blocking inferences of maximal depth). Such ATPs have seen much less use in program verification as superposition is not very efficient in handling ground and propositional formulae, which are often the majority of the VC for program verification. In addition, the extensions suggested for superposition based solvers to support linear arithmetic are not as efficient as those for SMT solvers, and integer arithmetic is often needed for program verification.

Program analysis tools based on abstract interpretation calculate an over-approximation of the set of feasible program states at each program point, by applying an abstraction to the state and transition relation of the program.
If the approximation satisfies the specification for that program point, so does the program.
For a given abstraction, it is sometimes possible for a programmer to predict which properties of a program will be proved, and the approximation at each program point is not affected by modifications to disjoint parts of the program - hence the results of the tool are more stable and predictable to non-expert users. Abstract interpretation can be applied in abstractions of increasing strength, so that the user can expect that properties proven in a certain abstraction will be proven with the same abstraction if the proof is valid for the modified program.
Very few abstract interpreters were suggested for quantified domains (e.g. \cite{DBLP:conf/popl/GulwaniMT08}),
and they often have to lose precision at join points as they are not goal sensitive - the analyzer at a join point cannot predict what precision is needed to prove properties later in the program.

\textbf{Main contribution:}\\
In this thesis we propose a generic verification algorithm that is based on a tighter integration between theorem proving and verification. 
Our algorithm is based on the idea of having a local theorem prover at each program point rather than one global prover, and allowing these provers to exchange information in order to search for a proof for the entire program. Information is exchanged only on-demand between provers rather than eagerly as often in abstract interpretation.
Our algorithm is incremental and applies successively stronger logical fragments in order to prove a program, allowing the report of intermediate results to the user. For a given fragment, the proof of each property is independent from the proofs of other properties, but the proofs can still share lemmas. 

We have instantiated our algorithm for the fragment of ground equalities using a form of congruence closure graphs, and for general FOL using superposition. We have also implemented a hierarchy of bounded fragments that restrict the proof-tree shape in various ways, including the size of terms and proof depth.

We show how our algorithm can take advantage of the scoping inherent in many programming languages, 
so that the vocabulary of each prover is small and local - we show how to preserve completeness under scoping using interpolation for ground FOL.

As we have implemented only very basic support for linear integer arithmetic, our tool cannot prove many VCs on its own. 
However, as intermediate results are usable at any stage, 
we can use the tool as an optimizing pre-processor before running an SMT solver or other tool.

\section{Outline}
In the rest of this chapter we give an overview of the main ideas in this thesis.
In chapter \ref{chapter:preliminaries} we discuss the theoretical background that we assume, our notation and the structure of input programs that we can handle.
In chapter \ref{chapter:ugfole} we present our verification algorithm and instantiate it for unit ground equalities using a form of congruence closure graphs.
In chapter \ref{chapter:gfole} we instantiate our algorithm for ground clauses using ground superposition.
In chapter \ref{chapter:scoping} we show how our algorithm is adapted to search for local proofs, and the use of interpolation to preserve completeness for local proofs in the ground case.
Chapter \ref{chapter:bounds} introduces several restrictions on the shape of proofs that define a hierarchy of decidable logical fragments with predictable complexity, whose limit is the complete fragment of first order logic, thus allowing incremental verification in fragments of increasing strength.
We show how the algorithm developed for ground clauses is extended to quantified clauses in chapter \ref{chapter:quantification}.
In chapter \ref{chapter:implementation} we discuss some implementation issues and present experimental results for an implementation of some of the ideas in this thesis.
We conclude in chapter \ref{chapter:conclusions} and discuss future work.

\input{chapters/introduction/main_ideas}
