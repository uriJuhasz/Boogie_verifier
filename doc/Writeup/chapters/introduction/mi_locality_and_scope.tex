\section{Locality and Scope}
Many current programming languages support scoping for program variables, where a variable can be accessed only in a certain area of the program. For example, a loop counter may be in scope only within the loop body.
An encoding of a program VC most often represents program variables in some form of dynamic single assignment (DSA) form - this form ensures that each program variable is assigned at most once on each program path (usually a program to program transformation replaces each occurrence of a a program variable with some indexed version of that variable to ensure this property. SSA is a specific case of DSA.). Also, a VC for the unrolling of a program (e.g. as in \cite{DBLP:conf/tacas/AlbarghouthiGC12}) often uses some form of DSA. 
Note that the original WP encoding of Dijkstra does not introduce any new symbols, DSA or otherwise, and instead represents, for each post-condition and each path in the program, the final value of each program variable that occurs in the post-condition expressed as an expression over the initial value of the program variables. 
As the number of such paths can be exponential in the program size, additional symbols must be introduced to keep the VC in size polynomial in the input size.

%Consider the example in figure \ref{snippet_1.2}:
%\begin{figure}
%\begin{lstlisting}
%x:=0
%if (*)
	%x := x+1
%if (*)
	%x := x+2
%if (*)
	%x := x+4
%assert x<8
%\end{lstlisting}
%\caption{Example for the use of DSA\\
%The VC for $n$ sequential branches that update a variable is of size proportional to $2^n$ \\
%without DSA and propotional to $n$ with DSA}
%\label{snippet_1.2}
%\end{figure}
%the VC generated by the original WP calculus of Dijkstra (simplifying for associativity and non-deterministic branches) is \\
%$((0+0)+0)+0<8 \land$\\
%$((0+0)+0)+4<8 \land$\\
%$((0+0)+2)+0<8 \land$\\
%$((0+0)+2)+4<8 \land$\\
%$((0+1)+0)+0<8 \land$\\
%$((0+1)+0)+4<8 \land$\\
%$((0+1)+2)+0<8 \land$\\
%$((0+1)+2)+4<8$
%
%\noindent
%The DSA version of the program is shown in figure \ref{snippet_1.2_DSA}
%\begin{figure}
%\begin{lstlisting}
%if (*)
	%x$_1$ := x$_0$+1
%else
	%x$_1$ := x$_0$+0
%if (*)
	%x$_2$ := x$_1$+2
%else
	%x$_2$ := x$_1$+0
%if (*)
	%x$_3$ := x$_2$+4
%else
	%x$_3$ := x$_2$+0
%assert x$_3$<8
%\end{lstlisting}
%\caption{The DSA conversion of \ref{snippet_1.2}}
%\label{snippet_1.2_DSA}
%\end{figure}
%and a possible VC generated using DSA is:\\
%$(\pv{x}_1 = \pv{x}_0+0 \lor \pv{x}_1 = \pv{x}_0+1) \land$\\
%$(\pv{x}_2 = \pv{x}_1+0 \lor \pv{x}_2 = \pv{x}_1+2) \land$\\
%$(\pv{x}_3 = \pv{x}_3+0 \lor \pv{x}_3 = \pv{x}_2+4) \land$\\
%$(\pv{x}_3<8)$

Intuitively, the state of an execution of the program is defined by the current program point and the values of all program variables.
For heap manipulating programs, the heap must be modeled in some way so that the value of the heap at different program points is representable as a FOL term, or we face the same problem of exponential sized WP. 
For example, the Boogie encoding of a program models the heap as an update-able map, for which Boogie emits axioms to the prover - the update-able map behaves as other program variables and hence has several DSA versions.
For assertions that refer to earlier versions of variables - specifically, post-conditions that refer to both the initial and final value of a variable - each earlier version of a variable that is later referenced has to be added to the state.

With this intuition in mind, we can expect that program annotation in the style of Floyd, where each program point is annotated by a formula that describes the set of possible states at that point, will include only the \emph{current} DSA version of each variable.
In terms of FOLE, this means that the only constants that participate in the program annotation at a given program point are the constants that represent the latest DSA versions of each program variable (more care is needed with join points, where we must ensure that each program variable has the same current DSA version on all the predecessors of the join).

We call program annotations that only mention the current DSA version \newdef{scoped annotation}. 
The search space for a scoped annotation depends on the number of variables in the source program, 
while the search space for a non-scoped annotation depends on the number of DSA versions times the number of source program variables - thus looking for only scoped proofs can reduce the proof search-space significantly in some cases.
This reduction is especially significant with some techniques for handling quantifiers, where the number of scoped ground instances of a quantified axiom is much smaller than the number of global ground instances.

Remember that the axioms defining the semantics of statements (whether by Floyd, Hoare or others) always correlate the state before and after the execution of the statement, and hence each axiom instance can relate to more than one program point (generally, assignment and \lstinline|skip| statement axioms refer to two program locations while a binary branch or join axiom refers to three). In addition, each sub-formula of the axiom refers to one specific program location - for example, in the Hoare axiom $\m{Q[x\mapsto v]\{}$\lstinline|x:=v|$\m{\}Q}$, the sub-formula $\m{Q[x\mapsto v]}$ refers to the program point before the statement and $\m{Q}$ refers to the program point after the statement.  
For a scoped proof, this means that we must only consider axiom instances where each sub-formula only contains the DSA versions of variables relevant for the program point it refers to.

The technique we develop in this work can be used to search for a scoped proof, and we mention some logical fragments where this is complete. In other cases we can prioritize the search for a scoped proof over a non-scoped proof or limit the scope in a less strict way while still preserving completeness.


\begin{figure}
\begin{lstlisting}
method m(n : Integer,b:Boolean)
	requires n>0
	
	//new array initialized to all false
	a := new Array[Boolean](n)
	a[0]:=true
	if (b)
		a[0] := false
		j := random(0,n)
		a[j] := true
n$_1$:
	assert $\exists i \cdot 0\leq i < $length(a)$\land$a[$i$]=true
\end{lstlisting}
\caption{Example for the incompleteness of scoped annotation in universal CNF.\\
The \lstinline|random| function is specified as \lstinline|a$\leq$random(a,b)<b|\\
A possible scoped annotation at \lstinline|n$_1$| that is sufficient to prove the assertion is \\
\lstinline|$\exists i \cdot (0\leq i < $length(a)$ \land $a[$i$]=true)|\\
However, this annotation is not in the fragment of universal CNF which is used by many provers, and into which there is a validty preserving conversion from FOLE.\\
A possible non-scoped universal CNF annotation is\\
\indent\lstinline|(b$\Rightarrow ($$0\leq$j$<$length(a) $\land$ a[j]=true)) $\land$ ($\lnot$b $\Rightarrow$ a[0]=true)|\\
There is no scoped annotation for universal CNF
}
\label{snippet_1.4}
\end{figure}

%The program converted to Boogie style is shown in figure \ref{snippet_1.4_Boogie}.
%\begin{figure}
%\begin{lstlisting}
%method m(n : Integer,b:Boolean)
	%assume n>0
	%
	%assume a$\neq$null
	%assume length(a$_0$)$=$n
	%assume $\forall i \cdot (0\leq i < $n$ \Rightarrow $a$_0$[$i$]$=0$
	%if (b){
		%assume $0\leq$j$<$n div 2+1
		%assume a$_1$=a$_0$[j:=5]
	%}else{
		%assume n div 2+1$\leq$k$<$n
		%assume a$_1$=a$_0$[k:=5]
	%}
%n$_1$:
	%assert $\exists i \cdot 0\leq i < $|a|$ \land $a[$i$]=5
	%//negated $\color{gray}{\forall i \cdot 0\leq i < }$|a|$\color{gray}{ \Rightarrow }$a[$\color{gray}{i}$]$\color{gray}{\neq}$ 5
%\end{lstlisting}
%\caption{Example for the incompleteness of scoped annotation - Boogie version\\
%The symbols \lstinline|j,k| are not in scope at \lstinline|n$_1$|\\
%A possible scoped annotation at \lstinline|n$_1$| that is sufficient to prove the assertion is \\
%\lstinline|$\exists i \cdot 0\leq i < $|a|$ \land $a[$i$]=5|\\
%A possible non-scoped annotation is\\
%\indent\lstinline|b$\Rightarrow ($$0\leq$j$<$n div 2+1 $\land$ a$_1$=a$_0$[j:=5]) $\land$|\\
%\indent\lstinline|$\lnot$b $\Rightarrow$ (n div 2+1$\leq$k$<$n$\land$ a$_1$=a$_0$[k:=5])|\\
%There is no annotation for universal clausal FOLE
%}
%\label{snippet_1.4_Boogie}
%\end{figure}
Scoped proofs do not exist for all logical fragments, for example, consider the code in figure \ref{snippet_1.4} - it is easy to see that any scoped annotation at \lstinline|n$_1$| must include an existential quantifier, and hence there is no scoped proof in universal CNF (most calculi used by automated theorem provers do not generate existential conclusions).

We discuss scoped proofs in chapter \ref{chapter:scoping} and also their relation to interpolation. We do not always look for scoped proofs because some logical fragments do not admit a scoped annotation, and sometimes the size of a minimal scoped annotation is significantly larger that of a minimal non-scoped annotation.

