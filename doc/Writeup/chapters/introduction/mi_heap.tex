\section{Heaps}
	Programs using the heap have always posed a challenge for analysis and verification.
	Potential aliasing between two different heap access paths is a generally undecidable problem and for many interesting subsets and over-approximations of the problem computationally very hard.
	As proofs of bigger programs are often intractable and whole program techniques often do not scale, a compositional approach is followed by many tools.
	In order for a modular verifier to be able to reason about method calls without using the method body, some form of aliasing specification must be provided or inferred - so several aliasing specification methodologies have been developed, such as ownership types \cite{DBLP:conf/ecoop/ClarkeNP01},\cite{DBLP:books/sp/Muller02}, separation logic \cite{DBLP:conf/lics/Reynolds02}, permissions \cite{DBLP:conf/sas/Boyland03} and dynamic frames \cite{DBLP:conf/fm/Kassios06},\cite{DBLP:conf/lpar/Leino10}.
Heaps are often represented as a map from a location and sometimes a field identifier to a locations or value and so we can expect to benefit from specialized reasoning procedures about non-extensional maps, which are supported by some provers (in our experience extensionality is not often needed for heaps, as opposed to e.g. sequences and sets).

	In the DSA form of a program VC, every assignment to the heap, and, in general, every entry and return to and from a heap manipulating method or loop body, adds a new DSA version of the whole heap, and specifies which locations in the heap are modified and which are preserved using some form of a frame axiom. For heap writes the classical axioms (\cite{Mccarthy62towardsa}) are often used and some verifiers include a decision procedure for the array theory which can be used for heaps. For other cases, the choice of frame axioms depend on the methodology used.
	For theorem provers, heap axioms pose a challenge as, for programs that manipulate the heap intensively, a long sequence of instances of heap axioms are needed in order to find the possible values of a heap location. 
	Such deep instances are usually avoided for general axioms as they enlarge the proof search space significantly and it is often not clear how deep a tool should look for the instances of one axiom vs. another axiom, but for heap axioms the number of instances is limited by the number of heap operations on any path in the program CFG.
	
		We developed a technique for dedicated handling of the heap which is aware of the interaction between heap manipulation and program flow. The technique allows the instantiation of heap axioms on demand (when a heap-read term is produced by another fragment) and ensures that the necessary axioms are instantiated for each such heap-read. As opposed to techniques used in symbolic execution, 
		handles the first two cases by eagerly applying map read-over-write axioms for heap reads that appear in the program and propagating heap information along the CFG accordingly - for example, a read of a heap location in the post-condition of a method (and hence the last DSA version of the heap) will traverse the DSA chain of the heap for that heap location, using all derived known equalities and dis-equalities on heap-locations and field ids to find the all possible values for that heap location, or the equivalent DSA versions where some property was assumed on that heap location. For framing we detect the framing axioms and apply them when propagating heap information even if the instantiation or superposition logic does not.\\
		Arbitrary quantification on heap locations (and, if needed, arbitrary heap operations) are handled using axioms and superposition.\\
		The technique can be applied at any stage of the proving process and hence is interleaved with other prover steps, as opposed to being applied only as a pre-process.
	
	
	
	
	The verification conditions generated from a program and specification in one of these methodologies includes several elements:
	\begin{itemize}
		\item The direct encoding of original programming language heap access - that is, direct reads and writes of the heap by the program - these can be handled, in general, quite well by a verifier as long as no loops are involved. 
		A problem we have encountered is that determining the value of a heap location at a later stage of a program which has paths with many heap-writes requires many quantifier instantiations of the heap read-over-write axiom. Some SMT solvers limit the instantiation depth of a term (a term is less likely to be used in instantiating a quantified axiom if more instantiations were needed to generate the term)
		\item Assertions about specific heap locations - pre- and post- conditions, loop invariants and method call and return specifications can all introduce assumptions about a specific heap location, without ever assigning it (e.g. in an OOP language a method pre-condition often includes the assertion that \lstinline|this!=null|) - thus some heap locations are accessed without ever being assigned, with only partial information
		\item Assertions that quantify over heap locations - assertions usually quantify over only a portion of the heap (e.g. the set of nodes of one linked list), the exception being assertions or axioms that refer to global properties such as type-correctness, but modular verification methodologies often try to avoid such quantification. References to a portion of the heap require a description of the portion, such as a set of heap locations - for example, an assertion that states that all values in a given integer linked list are positive needs some way to describe the set of locations that belong to the linked list. Some methodologies use a direct encoding of the set of heap locations (such as Dynamic Frames) while other methodologies use recursive predicates and functions to describe a subset of the heap locations.
		For a VC, supporting a directly represented set of heap locations requires handling some set operations, either as a native theory or using axioms. 
		Recursive predicates and functions cannot be axiomatized directly in FOLE as some form of transitive closure is needed. Some verification methodologies infer, or require users to specify, when to instantiate (\emph{unfold}) the axiom defining the recursive predicate, so that the encoding for the ATP is simple. 
		Axioms that describe recursive predicates and functions in FOLE without transitive closure are limited in that there are elements for which they cannot be used to prove that the element does not belong to the set described by the recursive predicate, however these axioms can be used effectively to prove positive properties about heap portions.
	\item Framing - modular verification methodologies need some way to abstract and specify the heap behaviour of method calls - essentially correlating the values of the heap in the pre-state with the one in the post-state.
		The most basic part of this specification is specifying which parts of the heap are not modified by a call, and each verifier has to encode this non-modification in the VC.
		In all the examples we have inspected, including Chalice, Spec\# and Dafny, the frame axiom follows the same template, which is of the form $\forall x,f \cdot \m{P}(x,f) \Rightarrow \m{H_0}(x,f)=\m{H_1}(x,f)$ where $x,f$ is a heap location and field-id and \m{H_0,H_1} are the pre- and post-heaps, respectively (in some cases \m{H_0,H_1} are also quantified in a global axiom).
		\end{itemize}
