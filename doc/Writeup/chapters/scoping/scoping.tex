\chapter{Scoping and Interpolation}\label{chapter:scoping}
We have referred to scoping several times in the previous chapters, and given some examples that hint at the motivation. 
In this chapter we start by defining scoping in our context, and show how we determine the scope of each CFG-node.
We continue by showing an algorithm for generating an interpolant for two sets of unit ground equality clauses - interpolants are closely related to scoping and are needed to achieve verification completeness.
Next we discuss the changes needed to the algorithm to make it applicable to inteprolants for sequences and trees.
We then extend the algorithm to non-unit clauses and DAG-shaped CFGs, generalizing the previous algorithms.

\textbf{Motivation:}
The basic intuition behind using scoping in verification is that of a search for local, small proofs that are composed into a whole-program proof.
Scoping exists in many programming languages which define which program variables are accessible at which program point.
A Hoare annotation of a program usually does not include a program variable name at any point in the program where the variable is not in scope - that is, before its declaration or at a parallel CFG-node (opposite branch) to the declaration.
For a passive program after DSA transformation, scoping can have an even stronger effect, as at most two DSA versions of each program variable can be in scope at the same time. In general, scoping reduces the proof-search-space for the prover at each CFG-node, but in some extreme cases can admit only proofs exponentially longer than the minimal non-local proof.

If we restrict the signature of the clauses that can occur at each CFG-node, 
we lose the completeness guarantee offered by the superposition calculus as even ground superposition is not complete for scoped proofs (local proofs). Several techniques have been developed for deriving interpolants from scoped superposition proofs, and in this chapter we show how we adapt some of these techniques to restore completeness for the ground fragment, and improve the coverage of the non-ground fragment. We also suggest a method to calculate a scope for each CFG-node that is not minimal, but sufficient to preserve completeness.

\input{chapters/scoping/scoping_basics}
\input{chapters/scoping/scoping_node_scope}
\input{chapters/scoping/scoping_ugfole}
\input{chapters/scoping/scoping_gfole}
