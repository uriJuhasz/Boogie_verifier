In this section we will give first an informal explanation of how the algorithm works and the reasoning behind it, and later the formal definitions.

%====================================================================================================================
%====================================================================================================================
\section{Objectives}
Currently one of the main methods to prove the correctness of a program is verification condition generation (VCG).
There are many varieties of this but generally this means encoding the correctness condition of a program into a logical formula, usually in first order logic with equality (FOLE), and then giving this formula to an automated theorem prover that either proves it holds or, if it does not hold, sometimes can give a counter example.

There are several weaknesses with most instances of this approach which we try to improve upon:
\begin{itemize}
	\item Specialization - most theorem provers are geared towards either general first order logic or specific domains such as linear arithmetic, very few have a built in theories specialized for verification - e.g. the handling of the CFG, memory. The evolution of SMT provers has shown that dedicated decision procedures can have a big advantage over axiomatization and the usage of a generic reasoning engine.
	\item Predictability - most theorem provers can be run with different sets of parameters, defining, among other things, the logic fragment in which to search the proof and possibly time or resource limitations. Such provers are usually unpredictable in terms of the time taken to prove or refute a formula (even for decidable fragments), and the exact fragment of logic that they actually manage to reason about in a given time is usually not well defined. This is as opposed to some static analysis tools, which are not complete for FOLE but have complexity bounds for the fragments they can handle, and where the domain is usually well defined.
	\item Usability of partial results - in most instances of VCG, when either some property does not hold or its proof times-out/diverges, we get no information about other properties, even if the prover actually generated a proof for them. Also, lemmas generated by the prover are discarded when we get a counter-example/diverge - as opposed to abstract interpretation tools that generate an annotation to the program even if this annotation is insufficient to prove all the properties. If we want to be able to combine the proving tool with other tools (e.g. static analyzers or symbolic execution), we must be able to use intermediate results.
\end{itemize}

\subsection{Criteria}
Based on the above, our criteria for a verification algorithm are:
\begin{itemize}
	\item Predictability: the algorithm should be runnable at a basic level in which it is a decision procedure with strict time and memory bounds for a restricted fragment of the logic, that should be useful in practice (as a simple static analysis).
	\item Specialization: the algorithm should admit dedicated decision procedures for sub-fragments, such as memory or linear arithmetic
	\item Partial results: the algorithm should provide some annotations for the program for any run, and running the algorithm with a larger fragment over the annotations produced with a smaller fragment should be able to reuse this annotation with minimal duplication of effort
	\item Completeness: the algorithm should have a mode (set of parameters) for which it is a complete semi-decision procedure (for annotations in FOLE) - this could be run with or without a time-out, and should preferably allow a gradual increase in the fragment handled (and of course usability of sub-results at each stage)
	\item Interoperability: the algorithm should admit cooperating with other verification/analysis methods - specifically it should be possible to extract partial results (as above), use these in another tool and then inject the new knowledge gained to the algorithm in order to continue from the point we have stopped without lose of information (no or little duplication of work)
\end{itemize}
